"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[4250],{18572:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"programming-languages/javascript/currying-iife","title":"Currying and IIFE","description":"JavaScript has several advanced functional programming concepts that make it highly versatile. Two such concepts are currying and Immediately Invoked Function Expressions (IIFE). This note explains these concepts in detail, with examples.","source":"@site/docs/programming-languages/javascript/currying-iife.md","sourceDirName":"programming-languages/javascript","slug":"/programming-languages/javascript/currying-iife","permalink":"/docs/programming-languages/javascript/currying-iife","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming-languages/javascript/currying-iife.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735588931000,"sidebarPosition":14,"frontMatter":{"sidebar_position":14},"sidebar":"tutorialSidebar","previous":{"title":"Callbacks and Higher-Order Functions","permalink":"/docs/programming-languages/javascript/callback-hof"},"next":{"title":"Prototypes and Inheritance","permalink":"/docs/programming-languages/javascript/prototype-inheritance"}}');var t=i(74848),s=i(28453);const a={sidebar_position:14},o="Currying and IIFE",l={},c=[{value:"Currying",id:"currying",level:2},{value:"How Currying Works",id:"how-currying-works",level:3},{value:"Syntax and Example",id:"syntax-and-example",level:3},{value:"Key Points About Currying",id:"key-points-about-currying",level:3},{value:"Real-World Use Cases of Currying",id:"real-world-use-cases-of-currying",level:3},{value:"Function Composition",id:"function-composition",level:4},{value:"Event Handlers",id:"event-handlers",level:4},{value:"API Request Utility",id:"api-request-utility",level:4},{value:"Automatic Currying with Utility Libraries",id:"automatic-currying-with-utility-libraries",level:4},{value:"Advantages of Currying",id:"advantages-of-currying",level:3},{value:"Disadvantages",id:"disadvantages",level:3},{value:"Immediately Invoked Function Expressions (IIFE)",id:"immediately-invoked-function-expressions-iife",level:2},{value:"Syntax of IIFE",id:"syntax-of-iife",level:3},{value:"Purpose of IIFE",id:"purpose-of-iife",level:3},{value:"Example of IIFE",id:"example-of-iife",level:3},{value:"Use Cases of IIFE",id:"use-cases-of-iife",level:3},{value:"Advantages of IIFE",id:"advantages-of-iife",level:3},{value:"Disadvantages of IIFE",id:"disadvantages-of-iife",level:3},{value:"IIFE vs. Currying",id:"iife-vs-currying",level:3}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"currying-and-iife",children:"Currying and IIFE"})}),"\n",(0,t.jsxs)(e.p,{children:["JavaScript has several advanced functional programming concepts that make it highly versatile. Two such concepts are ",(0,t.jsx)(e.strong,{children:"currying"})," and ",(0,t.jsx)(e.strong,{children:"Immediately Invoked Function Expressions (IIFE)"}),". This note explains these concepts in detail, with examples."]}),"\n",(0,t.jsx)(e.h2,{id:"currying",children:"Currying"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Currying"})," is a functional programming technique where a function is transformed into a sequence of functions, each taking a single argument. Instead of taking all arguments at once, the function takes the first argument, returns another function to take the next argument, and so on, until all arguments are supplied. When all arguments are provided, the original function is executed."]}),"\n",(0,t.jsx)(e.p,{children:"In simpler terms, currying converts a function with multiple arguments into a series of nested functions, each accepting one argument."}),"\n",(0,t.jsx)(e.h3,{id:"how-currying-works",children:"How Currying Works"}),"\n",(0,t.jsxs)(e.p,{children:["The primary idea behind currying is ",(0,t.jsx)(e.strong,{children:"partial application"})," of arguments. This makes functions more reusable and composable."]}),"\n",(0,t.jsx)(e.h3,{id:"syntax-and-example",children:"Syntax and Example"}),"\n",(0,t.jsx)(e.p,{children:"Here\u2019s an example of a regular function and its curried version:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"// Regular function\nfunction multiply(a: number, b: number, c: number): number {\n  return a * b * c;\n}\n\nconsole.log(multiply(2, 3, 4)); // Output: 24\n\n// Curried function\nfunction curriedMultiply(a: number) {\n  return function (b: number) {\n    return function (c: number) {\n      return a * b * c;\n    };\n  };\n}\n\nconst multiplyBy2 = curriedMultiply(2);\nconst multiplyBy2And3 = multiplyBy2(3);\nconsole.log(multiplyBy2And3(4)); // Output: 24\n"})}),"\n",(0,t.jsx)(e.h3,{id:"key-points-about-currying",children:"Key Points About Currying"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Decomposition"}),": Currying breaks down a function into smaller, more manageable pieces."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reusability"}),": Functions can be partially applied and reused."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Declarative Code"}),": Currying improves readability by creating more specific and clear function calls."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"real-world-use-cases-of-currying",children:"Real-World Use Cases of Currying"}),"\n",(0,t.jsx)(e.h4,{id:"function-composition",children:"Function Composition"}),"\n",(0,t.jsx)(e.p,{children:"Currying allows for creating reusable utilities."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"function add(a: number) {\n  return function (b: number) {\n    return a + b;\n  };\n}\n\nconst add5 = add(5);\nconsole.log(add5(10)); // Output: 15\n"})}),"\n",(0,t.jsx)(e.h4,{id:"event-handlers",children:"Event Handlers"}),"\n",(0,t.jsx)(e.p,{children:"You can pre-configure a handler for specific actions using currying."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'function eventHandler(type: string) {\n  return function (message: string) {\n    console.log(`[${type}] ${message}`);\n  };\n}\n\nconst errorHandler = eventHandler("Error");\nconst infoHandler = eventHandler("Info");\n\nerrorHandler("Something went wrong!"); // Output: [Error] Something went wrong!\ninfoHandler("Operation successful!"); // Output: [Info] Operation successful!\n'})}),"\n",(0,t.jsx)(e.h4,{id:"api-request-utility",children:"API Request Utility"}),"\n",(0,t.jsx)(e.p,{children:"Currying can help set up configurable functions for API calls."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'function apiRequest(baseUrl: string) {\n  return function (endpoint: string) {\n    return function (params: Record<string, string>) {\n      const query = Object.entries(params)\n        .map(([key, value]) => `${key}=${value}`)\n        .join("&");\n      return `${baseUrl}/${endpoint}?${query}`;\n    };\n  };\n}\n\nconst githubApi = apiRequest("https://api.github.com");\nconst searchUsers = githubApi("search/users");\nconsole.log(searchUsers({ q: "john", page: "1" }));\n// Output: https://api.github.com/search/users?q=john&page=1\n'})}),"\n",(0,t.jsx)(e.h4,{id:"automatic-currying-with-utility-libraries",children:"Automatic Currying with Utility Libraries"}),"\n",(0,t.jsxs)(e.p,{children:["Manually currying can become verbose. Utility libraries like ",(0,t.jsx)(e.strong,{children:"Lodash"})," or ",(0,t.jsx)(e.strong,{children:"Ramda"})," provide functions to automatically curry any function."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'import _ from "lodash";\n\nconst curriedFunction = _.curry((a, b, c) => a + b + c);\nconsole.log(curriedFunction(1)(2)(3)); // Output: 6\n'})}),"\n",(0,t.jsx)(e.h3,{id:"advantages-of-currying",children:"Advantages of Currying"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Improved Reusability"}),": Functions can be reused in different configurations."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Easier Composition"}),": Currying makes it easier to compose functions in functional programming."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Declarative Syntax"}),": It leads to cleaner, more readable code."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"disadvantages",children:"Disadvantages"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Performance Overhead"}),": Currying may introduce slight performance overhead due to multiple function calls."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Verbosity"}),": It can make code harder to understand for beginners."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"immediately-invoked-function-expressions-iife",children:"Immediately Invoked Function Expressions (IIFE)"}),"\n",(0,t.jsxs)(e.p,{children:["An ",(0,t.jsx)(e.strong,{children:"Immediately Invoked Function Expression (IIFE)"})," is a JavaScript function that is executed immediately after its definition. It is a self-executing anonymous function, often used to create a new scope and avoid polluting the global namespace."]}),"\n",(0,t.jsx)(e.h3,{id:"syntax-of-iife",children:"Syntax of IIFE"}),"\n",(0,t.jsx)(e.p,{children:"The syntax of an IIFE involves wrapping the function in parentheses and immediately invoking it."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'(function () {\n  console.log("IIFE executed!");\n})();\n'})}),"\n",(0,t.jsx)(e.p,{children:"Or, using the arrow function syntax:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'(() => {\n  console.log("IIFE executed!");\n})();\n'})}),"\n",(0,t.jsx)(e.h3,{id:"purpose-of-iife",children:"Purpose of IIFE"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Encapsulation"}),": Variables inside an IIFE are not accessible outside of it, preventing pollution of the global namespace."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Isolation"}),": IIFEs are commonly used to isolate code blocks and avoid variable name conflicts."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Execution Context"}),": IIFEs execute immediately, making them suitable for initialization code."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-of-iife",children:"Example of IIFE"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:"const result = (function () {\n  const a = 10;\n  const b = 20;\n  return a + b;\n})();\n\nconsole.log(result); // Output: 30\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Here, the variables ",(0,t.jsx)(e.code,{children:"a"})," and ",(0,t.jsx)(e.code,{children:"b"})," are encapsulated within the IIFE and do not pollute the global scope."]}),"\n",(0,t.jsx)(e.h3,{id:"use-cases-of-iife",children:"Use Cases of IIFE"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Module Pattern"}),"\nIIFEs are often used to implement the module pattern, providing private state and methods."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'const Counter = (function () {\n  let count = 0;\n\n  return {\n    increment: function () {\n      count++;\n      console.log(count);\n    },\n    reset: function () {\n      count = 0;\n      console.log("Counter reset");\n    },\n  };\n})();\n\nCounter.increment(); // Output: 1\nCounter.increment(); // Output: 2\nCounter.reset(); // Output: Counter reset\n'})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Avoiding Global Scope Pollution"}),"\nIIFEs prevent variables from leaking into the global scope."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'(function () {\n  const temp = "I\'m inside an IIFE!";\n  console.log(temp);\n})();\n\n// console.log(temp); // Error: temp is not defined\n'})}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"One-Time Initialization"}),"\nIIFEs are useful for running one-time setup code."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-typescript",children:'(() => {\n  console.log("Application initialized!");\n})();\n'})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"advantages-of-iife",children:"Advantages of IIFE"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Encapsulation"}),": Keeps the code modular and prevents conflicts."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Global Scope Protection"}),": Reduces the risk of overwriting global variables."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Execution Control"}),": Executes code immediately without the need for external invocation."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"disadvantages-of-iife",children:"Disadvantages of IIFE"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Readability"}),": For beginners, the syntax of IIFE can be confusing."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Debugging"}),": Debugging code inside an IIFE can be tricky due to its immediate execution."]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"iife-vs-currying",children:"IIFE vs. Currying"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:(0,t.jsx)(e.strong,{children:"Aspect"})}),(0,t.jsx)(e.th,{children:(0,t.jsx)(e.strong,{children:"IIFE"})}),(0,t.jsx)(e.th,{children:(0,t.jsx)(e.strong,{children:"Currying"})})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Definition"})}),(0,t.jsx)(e.td,{children:"A function executed immediately after being defined."}),(0,t.jsx)(e.td,{children:"A technique to transform a function into a series of functions, each taking one argument."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Purpose"})}),(0,t.jsx)(e.td,{children:"Used for encapsulation, isolation, and immediate execution."}),(0,t.jsx)(e.td,{children:"Used for partial application, function composition, and improving reusability."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Execution"})}),(0,t.jsx)(e.td,{children:"Executes immediately without external invocation."}),(0,t.jsx)(e.td,{children:"Requires arguments to be provided over multiple calls to eventually execute the logic."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Use Cases"})}),(0,t.jsx)(e.td,{children:"Module pattern, avoiding global scope pollution, one-time initialization."}),(0,t.jsx)(e.td,{children:"Function composition, reusable utilities, declarative function calls."})]})]})]})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>o});var r=i(96540);const t={},s=r.createContext(t);function a(n){const e=r.useContext(s);return r.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),r.createElement(s.Provider,{value:e},n.children)}}}]);