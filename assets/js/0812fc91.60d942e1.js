"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[5517],{4760:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"databases/database-engineering/pooling","title":"Connection Pooling","description":"This note is complete, reviewed, and considered stable.","source":"@site/docs/databases/database-engineering/pooling.md","sourceDirName":"databases/database-engineering","slug":"/databases/database-engineering/pooling","permalink":"/docs/databases/database-engineering/pooling","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-engineering/pooling.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1768496927000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/databases/database-engineering/introduction"},"next":{"title":"Transactions","permalink":"/docs/databases/database-engineering/transactions"}}');var t=i(74848),s=i(28453);const a={sidebar_position:2},l="Connection Pooling",c={},r=[{value:"Naive ways to connect to a database (and why they fail)",id:"naive-ways-to-connect-to-a-database-and-why-they-fail",level:2},{value:"One connection per request",id:"one-connection-per-request",level:3},{value:"Why this approach fails",id:"why-this-approach-fails",level:4},{value:"Single shared global connection",id:"single-shared-global-connection",level:3},{value:"Why this approach fails",id:"why-this-approach-fails-1",level:4},{value:"Core idea of connection pooling",id:"core-idea-of-connection-pooling",level:2},{value:"How connection pooling works internally",id:"how-connection-pooling-works-internally",level:2},{value:"Pool initialization",id:"pool-initialization",level:3},{value:"Request lifecycle with pooling",id:"request-lifecycle-with-pooling",level:3},{value:"Pool exhaustion and waiting",id:"pool-exhaustion-and-waiting",level:3},{value:"Key characteristics of a connection pool",id:"key-characteristics-of-a-connection-pool",level:2},{value:"Pool size",id:"pool-size",level:3},{value:"Connection reuse",id:"connection-reuse",level:3},{value:"Advantages of connection pooling over other approaches",id:"advantages-of-connection-pooling-over-other-approaches",level:2},{value:"Performance advantage",id:"performance-advantage",level:3},{value:"Scalability advantage",id:"scalability-advantage",level:3},{value:"Database protection",id:"database-protection",level:3},{value:"Resource efficiency",id:"resource-efficiency",level:3},{value:"Fault tolerance",id:"fault-tolerance",level:3},{value:"Connection pooling vs concurrency (important distinction)",id:"connection-pooling-vs-concurrency-important-distinction",level:2},{value:"Common production failure modes",id:"common-production-failure-modes",level:2},{value:"Connection leaks",id:"connection-leaks",level:3},{value:"Oversized pools",id:"oversized-pools",level:3},{value:"Long-running transactions",id:"long-running-transactions",level:3},{value:"Real-world implementations",id:"real-world-implementations",level:2}];function d(e){const n={admonition:"admonition",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"connection-pooling",children:"Connection Pooling"})}),"\n",(0,t.jsx)(n.admonition,{title:"Status",type:"tip",children:(0,t.jsx)(n.p,{children:"This note is complete, reviewed, and considered stable."})}),"\n",(0,t.jsxs)(n.p,{children:["A database connection is a ",(0,t.jsx)(n.strong,{children:"persistent communication channel"})," between an application and a database server."]}),"\n",(0,t.jsx)(n.p,{children:"Establishing a connection involves:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"TCP handshake"}),"\n",(0,t.jsx)(n.li,{children:"Authentication (credentials, certificates, SSL)"}),"\n",(0,t.jsx)(n.li,{children:"Allocating memory and worker resources on the database"}),"\n",(0,t.jsx)(n.li,{children:"Registering a session in the database\u2019s internal state"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This makes connection creation ",(0,t.jsx)(n.strong,{children:"significantly more expensive"})," than executing most queries."]}),"\n",(0,t.jsx)(n.h2,{id:"naive-ways-to-connect-to-a-database-and-why-they-fail",children:"Naive ways to connect to a database (and why they fail)"}),"\n",(0,t.jsx)(n.h3,{id:"one-connection-per-request",children:"One connection per request"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Request arrives\n\u2192 Open database connection\n\u2192 Execute query\n\u2192 Close connection\n\u2192 Send response\n"})}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant App\n    participant DB\n\n    Client->>App: HTTP Request\n    App->>DB: Open Connection\n    App->>DB: Execute Query\n    App->>DB: Close Connection\n    App->>Client: Response"})}),"\n",(0,t.jsx)(n.h4,{id:"why-this-approach-fails",children:"Why this approach fails"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Connection setup dominates request latency"}),"\n",(0,t.jsx)(n.li,{children:"High CPU and memory usage on the database"}),"\n",(0,t.jsx)(n.li,{children:"Connection storms during traffic spikes"}),"\n",(0,t.jsx)(n.li,{children:"Poor scalability beyond low traffic"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This model is acceptable only for scripts or extremely low-load systems."}),"\n",(0,t.jsx)(n.h3,{id:"single-shared-global-connection",children:"Single shared global connection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"Create one DB connection\nReuse it for all requests\n"})}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    R1[Request 1]\n    R2[Request 2]\n    R3[Request 3]\n    Conn[(Single DB Connection)]\n    DB[(Database)]\n\n    R1 --\x3e Conn\n    R2 --\x3e Conn\n    R3 --\x3e Conn\n    Conn --\x3e DB"})}),"\n",(0,t.jsx)(n.h4,{id:"why-this-approach-fails-1",children:"Why this approach fails"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No real concurrency"}),"\n",(0,t.jsx)(n.li,{children:"Thread safety issues"}),"\n",(0,t.jsx)(n.li,{children:"One broken connection breaks the entire system"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"core-idea-of-connection-pooling",children:"Core idea of connection pooling"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Connection pooling"})," means:"]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsx)(n.p,{children:"Maintain a fixed number of pre-opened database connections and reuse them across requests."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Connections are ",(0,t.jsx)(n.strong,{children:"borrowed"}),", not created or destroyed per request."]}),"\n",(0,t.jsx)(n.h2,{id:"how-connection-pooling-works-internally",children:"How connection pooling works internally"}),"\n",(0,t.jsx)(n.h3,{id:"pool-initialization",children:"Pool initialization"}),"\n",(0,t.jsx)(n.p,{children:"At application startup:"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    App[Application Start]\n    Pool[Connection Pool]\n    C1[(Conn 1)]\n    C2[(Conn 2)]\n    C3[(Conn 3)]\n    DB[(Database)]\n\n    App --\x3e Pool\n    Pool --\x3e C1 --\x3e DB\n    Pool --\x3e C2 --\x3e DB\n    Pool --\x3e C3 --\x3e DB"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Connections are created once"}),"\n",(0,t.jsx)(n.li,{children:"Stored in an idle state"}),"\n",(0,t.jsx)(n.li,{children:"Kept alive for reuse"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"request-lifecycle-with-pooling",children:"Request lifecycle with pooling"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant App\n    participant Pool\n    participant DB\n\n    Client->>App: Request\n    App->>Pool: Borrow connection\n    Pool--\x3e>App: Connection\n    App->>DB: Execute query\n    DB->>App: Query Response\n    App->>Pool: Return connection\n    App->>Client: Response"})}),"\n",(0,t.jsx)(n.p,{children:"Key rule:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Connections must always be returned to the pool"})}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pool-exhaustion-and-waiting",children:"Pool exhaustion and waiting"}),"\n",(0,t.jsx)(n.p,{children:"When all connections are busy:"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:'flowchart LR\n    Req[Incoming Request]\n    Pool["Connection Pool\\n(All Busy)"]\n    Wait[Wait / Queue]\n    DB[(Database)]\n\n    Req --\x3e Pool\n    Pool --\x3e Wait\n    Wait --\x3e Pool\n    Pool --\x3e DB'})}),"\n",(0,t.jsxs)(n.p,{children:["This introduces ",(0,t.jsx)(n.strong,{children:"backpressure"}),", protecting the database."]}),"\n",(0,t.jsx)(n.h2,{id:"key-characteristics-of-a-connection-pool",children:"Key characteristics of a connection pool"}),"\n",(0,t.jsx)(n.h3,{id:"pool-size",children:"Pool size"}),"\n",(0,t.jsx)(n.p,{children:"The pool enforces a maximum number of concurrent database connections."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Small pool \u2192 higher wait times"}),"\n",(0,t.jsx)(n.li,{children:"Large pool \u2192 database overload"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The pool size is a ",(0,t.jsx)(n.strong,{children:"control knob"}),", not a performance booster."]}),"\n",(0,t.jsx)(n.h3,{id:"connection-reuse",children:"Connection reuse"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    Req1[Request A]\n    Req2[Request B]\n    Req3[Request C]\n    Conn[(Reusable Connection)]\n\n    Req1 --\x3e Conn\n    Req2 --\x3e Conn\n    Req3 --\x3e Conn"})}),"\n",(0,t.jsx)(n.p,{children:"The same connection serves many requests over time, amortizing setup costs."}),"\n",(0,t.jsx)(n.h2,{id:"advantages-of-connection-pooling-over-other-approaches",children:"Advantages of connection pooling over other approaches"}),"\n",(0,t.jsx)(n.h3,{id:"performance-advantage",children:"Performance advantage"}),"\n",(0,t.jsx)(n.p,{children:"Compared to per-request connections:"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart TB\n    A[Per-request connections]\n    B[Connection pooling]\n\n    A --\x3e|Repeated setup| Slow[High Latency]\n    B --\x3e|Reuse connections| Fast[Low Latency]"})}),"\n",(0,t.jsx)(n.p,{children:"Pooling removes repeated connection overhead from the critical path."}),"\n",(0,t.jsx)(n.h3,{id:"scalability-advantage",children:"Scalability advantage"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    Threads[Many App Threads]\n    Pool[Few DB Connections]\n    DB[(Database)]\n\n    Threads --\x3e Pool --\x3e DB"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Application concurrency \u2260 database concurrency"}),"\n",(0,t.jsxs)(n.li,{children:["Pool acts as a ",(0,t.jsx)(n.strong,{children:"gatekeeper"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"database-protection",children:"Database protection"}),"\n",(0,t.jsx)(n.p,{children:"From the database\u2019s perspective:"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    App[Application]\n    Pool[Connection Pool]\n    DB[(Database)]\n\n    App --\x3e Pool\n    Pool --\x3e|Limited| DB"})}),"\n",(0,t.jsx)(n.p,{children:"The pool:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Prevents connection floods"}),"\n",(0,t.jsx)(n.li,{children:"Keeps resource usage stable"}),"\n",(0,t.jsx)(n.li,{children:"Improves predictability under load"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"resource-efficiency",children:"Resource efficiency"}),"\n",(0,t.jsx)(n.p,{children:"Without pooling:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Constant connection creation/destruction"}),"\n",(0,t.jsx)(n.li,{children:"High CPU and memory churn"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"With pooling:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Long-lived connections"}),"\n",(0,t.jsx)(n.li,{children:"Better cache and worker reuse"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"fault-tolerance",children:"Fault tolerance"}),"\n",(0,t.jsx)(n.p,{children:"Pools can:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Detect broken connections"}),"\n",(0,t.jsx)(n.li,{children:"Replace them automatically"}),"\n",(0,t.jsx)(n.li,{children:"Retry safely"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This logic is centralized instead of duplicated across application code."}),"\n",(0,t.jsx)(n.h2,{id:"connection-pooling-vs-concurrency-important-distinction",children:"Connection pooling vs concurrency (important distinction)"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    Threads[100 Threads]\n    Pool[10 DB Connections]\n    DB[(Database)]\n\n    Threads --\x3e Pool --\x3e DB"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Many threads can exist"}),"\n",(0,t.jsx)(n.li,{children:"Only limited DB access is allowed"}),"\n",(0,t.jsx)(n.li,{children:"Excess work waits instead of crashing the database"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["This is ",(0,t.jsx)(n.strong,{children:"intentional system design"}),", not a bottleneck."]}),"\n",(0,t.jsx)(n.h2,{id:"common-production-failure-modes",children:"Common production failure modes"}),"\n",(0,t.jsx)(n.h3,{id:"connection-leaks",children:"Connection leaks"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    Pool[Connection Pool]\n    Leak[Borrowed and Not Returned]\n    Exhausted[Pool Exhausted]\n\n    Pool --\x3e Leak --\x3e Exhausted"})}),"\n",(0,t.jsx)(n.p,{children:"Result:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Requests hang"}),"\n",(0,t.jsx)(n.li,{children:"System degrades over time"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"oversized-pools",children:"Oversized pools"}),"\n",(0,t.jsx)("div",{style:{textAlign:"center"},children:(0,t.jsx)(n.mermaid,{value:"flowchart LR\n    Pool[Huge Pool]\n    DB[(Database)]\n    Slow[High Latency]\n\n    Pool --\x3e DB --\x3e Slow"})}),"\n",(0,t.jsx)(n.p,{children:"More connections increase contention and reduce performance."}),"\n",(0,t.jsx)(n.h3,{id:"long-running-transactions",children:"Long-running transactions"}),"\n",(0,t.jsx)(n.p,{children:"Connections held too long reduce pool availability and cause cascading delays."}),"\n",(0,t.jsx)(n.h2,{id:"real-world-implementations",children:"Real-world implementations"}),"\n",(0,t.jsx)(n.p,{children:"Connection pooling is built into most ecosystems:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Java \u2192 HikariCP"}),"\n",(0,t.jsx)(n.li,{children:"Python \u2192 SQLAlchemy / Django"}),"\n",(0,t.jsxs)(n.li,{children:["Go \u2192 ",(0,t.jsx)(n.code,{children:"database/sql"})]}),"\n",(0,t.jsx)(n.li,{children:"Node.js \u2192 driver-level pools"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Different APIs, same underlying model."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var o=i(96540);const t={},s=o.createContext(t);function a(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);