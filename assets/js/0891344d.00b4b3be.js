"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[2968],{52044:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"programming/programming-languages/go/goroutines/channels","title":"Channels","description":"A channel is a typed conduit through which we can send and receive values between goroutines. Channels are first-class objects in Go and are managed by the Go runtime.","source":"@site/docs/programming/programming-languages/go/goroutines/channels.md","sourceDirName":"programming/programming-languages/go/goroutines","slug":"/programming/programming-languages/go/goroutines/channels","permalink":"/docs/programming/programming-languages/go/goroutines/channels","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming/programming-languages/go/goroutines/channels.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1754997544000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/programming/programming-languages/go/goroutines/introduction"},"next":{"title":"Wait Groups","permalink":"/docs/programming/programming-languages/go/goroutines/wait-group"}}');var r=s(74848),l=s(28453);const a={sidebar_position:2},o="Channels",c={},t=[{value:"Why Use Channels?",id:"why-use-channels",level:2},{value:"Basic Channel Operations",id:"basic-channel-operations",level:2},{value:"Example: Basic Channel Usage",id:"example-basic-channel-usage",level:2},{value:"Buffered vs Unbuffered Channels",id:"buffered-vs-unbuffered-channels",level:2},{value:"Unbuffered Channels",id:"unbuffered-channels",level:3},{value:"Example: Unbuffered Channel for Synchronization",id:"example-unbuffered-channel-for-synchronization",level:4},{value:"Buffered Channels",id:"buffered-channels",level:3},{value:"Example: Buffered Channel for Producer-Consumer",id:"example-buffered-channel-for-producer-consumer",level:4},{value:"When to Use Each",id:"when-to-use-each",level:3},{value:"Real-World Use Cases",id:"real-world-use-cases",level:3},{value:"Use Cases for Channels",id:"use-cases-for-channels",level:2},{value:"Key Characteristics",id:"key-characteristics",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Worker Pool Example",id:"worker-pool-example",level:3},{value:"Advantages",id:"advantages",level:2},{value:"Limitations &amp; Pitfalls",id:"limitations--pitfalls",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"channels",children:"Channels"})}),"\n",(0,r.jsx)(n.p,{children:"A channel is a typed conduit through which we can send and receive values between goroutines. Channels are first-class objects in Go and are managed by the Go runtime."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Channels are created using the ",(0,r.jsx)(n.code,{children:"make"})," function."]}),"\n",(0,r.jsxs)(n.li,{children:["They are strongly typed (e.g., ",(0,r.jsx)(n.code,{children:"chan int"}),", ",(0,r.jsx)(n.code,{children:"chan string"}),")."]}),"\n",(0,r.jsx)(n.li,{children:"Channels can be buffered or unbuffered."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"why-use-channels",children:"Why Use Channels?"}),"\n",(0,r.jsx)(n.p,{children:"Channels help coordinate work between goroutines, allowing them to communicate safely without explicit locks or shared memory. This makes concurrent code easier to reason about and less prone to race conditions."}),"\n",(0,r.jsx)(n.h2,{id:"basic-channel-operations",children:"Basic Channel Operations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Send:"})," ",(0,r.jsx)(n.code,{children:"ch <- value"})," sends a value to the channel."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Receive:"})," ",(0,r.jsx)(n.code,{children:"value := <-ch"})," receives a value from the channel."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Close:"})," ",(0,r.jsx)(n.code,{children:"close(ch)"})," closes the channel, signaling no more values will be sent."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-basic-channel-usage",children:"Example: Basic Channel Usage"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport "fmt"\n\nfunc main() {\n    ch := make(chan int)\n    go func() {\n        ch <- 42 // send value\n    }()\n    val := <-ch // receive value\n    fmt.Println(val) // Output: 42\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"buffered-vs-unbuffered-channels",children:"Buffered vs Unbuffered Channels"}),"\n",(0,r.jsx)(n.p,{children:"Channels in Go can be either buffered or unbuffered, and understanding their behavior is crucial for designing correct concurrent programs."}),"\n",(0,r.jsx)(n.h3,{id:"unbuffered-channels",children:"Unbuffered Channels"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition:"})," An unbuffered channel has no capacity to store values. Every send (",(0,r.jsx)(n.code,{children:"ch <- value"}),") will block until another goroutine is ready to receive (",(0,r.jsx)(n.code,{children:"<-ch"}),"), and vice versa."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case:"})," Synchronization between goroutines. Ensures that both sender and receiver are ready at the same time."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-unbuffered-channel-for-synchronization",children:"Example: Unbuffered Channel for Synchronization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n)\n\nfunc worker(done chan bool) {\n    fmt.Println("Working...")\n    time.Sleep(time.Second)\n    fmt.Println("Done")\n    done <- true // signal completion\n}\n\nfunc main() {\n    done := make(chan bool) // unbuffered channel\n    go worker(done)\n    <-done // wait for worker to finish\n    fmt.Println("Main exits")\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The main goroutine waits for the worker to signal completion. The send and receive must happen at the same time, ensuring synchronization."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"buffered-channels",children:"Buffered Channels"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition:"})," A buffered channel has a fixed capacity. Sends to the channel only block when the buffer is full; receives only block when the buffer is empty."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Case:"})," Decoupling sender and receiver, rate limiting, producer-consumer patterns."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-buffered-channel-for-producer-consumer",children:"Example: Buffered Channel for Producer-Consumer"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n)\n\nfunc producer(ch chan int) {\n    for i := 1; i <= 5; i++ {\n        fmt.Printf("Producing %d\\n", i)\n        ch <- i // will block only if buffer is full\n        time.Sleep(200 * time.Millisecond)\n    }\n    close(ch)\n}\n\nfunc consumer(ch chan int) {\n    for v := range ch {\n        fmt.Printf("Consuming %d\\n", v)\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\nfunc main() {\n    ch := make(chan int, 2) // buffered channel with capacity 2\n    go producer(ch)\n    consumer(ch)\n    fmt.Println("All done!")\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The producer can send up to 2 values before blocking, even if the consumer is not ready. This allows for some decoupling between producer and consumer speeds."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-each",children:"When to Use Each"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unbuffered channels"})," are best for direct handoff and synchronization between goroutines."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffered channels"})," are useful when we want to decouple sender and receiver, smooth out bursts, or implement queues."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"real-world-use-cases",children:"Real-World Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unbuffered:"})," Signaling completion, handshakes, strict step-by-step coordination."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffered:"})," Logging systems, job queues, rate limiting, batching, producer-consumer pipelines."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"use-cases-for-channels",children:"Use Cases for Channels"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Worker pools:"})," Distribute tasks among multiple goroutines."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fan-out/fan-in:"})," Send data to multiple goroutines and collect results."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Synchronization:"})," Signal completion or coordinate steps between goroutines."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pipelines:"})," Chain stages of processing using channels."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Type safety:"})," Channels enforce the type of data sent/received."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blocking behavior:"})," Operations block until they can proceed, simplifying synchronization."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Directionality:"})," Channels can be directional (",(0,r.jsx)(n.code,{children:"chan<-"})," for send-only, ",(0,r.jsx)(n.code,{children:"<-chan"})," for receive-only)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Closing:"})," Closing a channel signals receivers that no more data will be sent."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"worker-pool-example",children:"Worker Pool Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "sync"\n)\n\nfunc worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n    defer wg.Done()\n    for job := range jobs {\n        results <- job * 2\n    }\n}\n\nfunc main() {\n    jobs := make(chan int, 5)\n    results := make(chan int, 5)\n    var wg sync.WaitGroup\n\n    for w := 1; w <= 3; w++ {\n        wg.Add(1)\n        go worker(w, jobs, results, &wg)\n    }\n\n    for j := 1; j <= 5; j++ {\n        jobs <- j\n    }\n    close(jobs)\n    wg.Wait()\n    close(results)\n\n    for r := range results {\n        fmt.Println(r)\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advantages",children:"Advantages"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simplifies concurrent programming"}),"\n",(0,r.jsx)(n.li,{children:"Reduces risk of race conditions"}),"\n",(0,r.jsx)(n.li,{children:"Makes code easier to read and maintain"}),"\n",(0,r.jsx)(n.li,{children:"Integrates naturally with Go\u2019s select statement for multiplexing"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"limitations--pitfalls",children:"Limitations & Pitfalls"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Can lead to deadlocks if not managed carefully"}),"\n",(0,r.jsx)(n.li,{children:"Buffered channels can fill up and block senders"}),"\n",(0,r.jsx)(n.li,{children:"Closing a channel twice causes a panic"}),"\n",(0,r.jsx)(n.li,{children:"Reading from a closed channel yields zero value"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Always close channels when no more values will be sent"}),"\n",(0,r.jsx)(n.li,{children:"Use directional channels to clarify intent"}),"\n",(0,r.jsx)(n.li,{children:"Avoid sharing channels between unrelated goroutines"}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"select"})," for handling multiple channels or timeouts"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(96540);const r={},l=i.createContext(r);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);