"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[2968],{52044:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>t});const i=JSON.parse('{"id":"programming/programming-languages/go/goroutines/channels","title":"Channels","description":"In Go, a channel is a typed conduit for sending and receiving values between goroutines. Channels are a core concurrency primitive managed by the Go runtime.","source":"@site/docs/programming/programming-languages/go/goroutines/channels.md","sourceDirName":"programming/programming-languages/go/goroutines","slug":"/programming/programming-languages/go/goroutines/channels","permalink":"/docs/programming/programming-languages/go/goroutines/channels","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming/programming-languages/go/goroutines/channels.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1755251208000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Mutex","permalink":"/docs/programming/programming-languages/go/goroutines/mutex"},"next":{"title":"Tips & Tricks","permalink":"/docs/programming/programming-languages/go/goroutines/tips-tricks"}}');var r=s(74848),l=s(28453);const c={sidebar_position:5},o="Channels",a={},t=[{value:"Creating Channels",id:"creating-channels",level:2},{value:"Why Use Channels?",id:"why-use-channels",level:2},{value:"Basic Operations",id:"basic-operations",level:2},{value:"Buffered vs Unbuffered Channels",id:"buffered-vs-unbuffered-channels",level:2},{value:"Unbuffered Channels",id:"unbuffered-channels",level:3},{value:"Buffered Channels",id:"buffered-channels",level:3},{value:"Directional Channels",id:"directional-channels",level:2},{value:"select Statement \u2014 Multiplexing Channels",id:"select-statement--multiplexing-channels",level:2},{value:"Closing Channels &amp; Cleanup",id:"closing-channels--cleanup",level:2},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Worker Pool",id:"worker-pool",level:3},{value:"Fan-out / Fan-in",id:"fan-out--fan-in",level:3},{value:"Pipelines",id:"pipelines",level:3},{value:"Pitfalls",id:"pitfalls",level:2},{value:"Best Practices",id:"best-practices",level:2}];function d(n){const e={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"channels",children:"Channels"})}),"\n",(0,r.jsx)(e.p,{children:"In Go, a channel is a typed conduit for sending and receiving values between goroutines. Channels are a core concurrency primitive managed by the Go runtime."}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Channels:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Remove the need for explicit locks in many cases"}),"\n",(0,r.jsx)(e.li,{children:"Ensure safe data sharing between goroutines without race conditions"}),"\n",(0,r.jsx)(e.li,{children:"Are type-safe"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"creating-channels",children:"Creating Channels"}),"\n",(0,r.jsxs)(e.p,{children:["We create channels with the ",(0,r.jsx)(e.code,{children:"make"})," function:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"ch := make(chan int)       // Unbuffered channel\nchBuf := make(chan string, 5) // Buffered channel (capacity = 5)\n"})}),"\n",(0,r.jsxs)(e.p,{children:["The type of a channel is defined as ",(0,r.jsx)(e.code,{children:"chan T"})," where ",(0,r.jsx)(e.code,{children:"T"})," is the type of data it carries."]}),"\n",(0,r.jsx)(e.h2,{id:"why-use-channels",children:"Why Use Channels?"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["To ",(0,r.jsx)(e.strong,{children:"coordinate"})," work between goroutines."]}),"\n",(0,r.jsxs)(e.li,{children:["To ",(0,r.jsx)(e.strong,{children:"pass data"})," without manual synchronization."]}),"\n",(0,r.jsxs)(e.li,{children:["To build ",(0,r.jsx)(e.strong,{children:"concurrent pipelines"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:["To implement ",(0,r.jsx)(e.strong,{children:"producer-consumer"})," or ",(0,r.jsx)(e.strong,{children:"fan-out/fan-in"})," patterns."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Go\u2019s philosophy: Don\u2019t communicate by sharing memory; share memory by communicating."}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Don\u2019t communicate by sharing memory; share memory by communicating."})}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,r.jsx)(e.p,{children:"Channels support three main operations:"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Send"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"ch <- value\n"})}),"\n",(0,r.jsxs)(e.p,{children:["Sends ",(0,r.jsx)(e.code,{children:"value"})," into ",(0,r.jsx)(e.code,{children:"ch"}),". Blocks until a receiver is ready (for unbuffered channels)."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Receive"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"val := <-ch\n"})}),"\n",(0,r.jsxs)(e.p,{children:["Receives a value from ",(0,r.jsx)(e.code,{children:"ch"}),". Blocks until there\u2019s a value to receive."]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Close"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"close(ch)\n"})}),"\n",(0,r.jsxs)(e.p,{children:["Signals that ",(0,r.jsx)(e.strong,{children:"no more values"})," will be sent on ",(0,r.jsx)(e.code,{children:"ch"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"buffered-vs-unbuffered-channels",children:"Buffered vs Unbuffered Channels"}),"\n",(0,r.jsx)(e.h3,{id:"unbuffered-channels",children:"Unbuffered Channels"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Capacity"})," = 0."]}),"\n",(0,r.jsx)(e.li,{children:"Every send must wait for a corresponding receive, and vice versa."}),"\n",(0,r.jsxs)(e.li,{children:["Used for ",(0,r.jsx)(e.strong,{children:"synchronization"})," and ",(0,r.jsx)(e.strong,{children:"direct handoff"})," between goroutines."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example: Synchronization:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'done := make(chan bool)\ngo func() {\n    fmt.Println("Task started")\n    time.Sleep(time.Second)\n    fmt.Println("Task finished")\n    done <- true\n}()\n<-done // Waits until goroutine sends\n'})}),"\n",(0,r.jsx)(e.h3,{id:"buffered-channels",children:"Buffered Channels"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Have a ",(0,r.jsx)(e.strong,{children:"fixed capacity"}),"."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Send"})," only blocks when the buffer is full."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Receive"})," only blocks when the buffer is empty."]}),"\n",(0,r.jsxs)(e.li,{children:["Useful for ",(0,r.jsx)(e.strong,{children:"decoupling"})," sender and receiver speeds."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"Why Buffered Channels are Important"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Decoupling"}),": The sender and receiver don\u2019t have to be in perfect sync \u2014 the buffer allows temporary storage."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Throughput"}),": In high-throughput systems, buffering can smooth out bursts of work."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Producer-Consumer"}),": Allows the producer to work ahead without blocking if the consumer is slower."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Rate Limiting"}),": Control how many items are processed at once."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example: Producer-Consumer with Buffer:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'func producer(ch chan int) {\n    for i := 1; i <= 5; i++ {\n        fmt.Printf("Producing %d\\n", i)\n        ch <- i // Blocks only if buffer is full\n        time.Sleep(200 * time.Millisecond)\n    }\n    close(ch)\n}\n\nfunc consumer(ch chan int) {\n    for v := range ch {\n        fmt.Printf("Consuming %d\\n", v)\n        time.Sleep(500 * time.Millisecond)\n    }\n}\n\nfunc main() {\n    ch := make(chan int, 2) // Capacity 2\n    go producer(ch)\n    consumer(ch)\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Behavior:"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Producer can produce up to 2 values before blocking."}),"\n",(0,r.jsx)(e.li,{children:"Consumer processes at its own pace."}),"\n",(0,r.jsx)(e.li,{children:"The buffer smooths the speed difference between them."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"directional-channels",children:"Directional Channels"}),"\n",(0,r.jsxs)(e.p,{children:["We can make channels ",(0,r.jsx)(e.strong,{children:"send-only"})," or ",(0,r.jsx)(e.strong,{children:"receive-only"})," in function parameters to enforce correct usage:"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func sendData(ch chan<- int) { ch <- 42 }   // Send-only\nfunc receiveData(ch <-chan int) { fmt.Println(<-ch) } // Receive-only\n"})}),"\n",(0,r.jsx)(e.p,{children:"This helps prevent accidental misuse of a channel in large systems."}),"\n",(0,r.jsx)(e.h2,{id:"select-statement--multiplexing-channels",children:"select Statement \u2014 Multiplexing Channels"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:"select"})," allows us to ",(0,r.jsx)(e.strong,{children:"wait on multiple channel operations"})," simultaneously:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Picks the first case where a channel is ready."}),"\n",(0,r.jsx)(e.li,{children:"If multiple are ready, chooses one randomly."}),"\n",(0,r.jsxs)(e.li,{children:["If none are ready, blocks unless a ",(0,r.jsx)(e.code,{children:"default"})," case exists."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example: Multiplexing:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'select {\ncase msg := <-ch1:\n    fmt.Println("From ch1:", msg)\ncase msg := <-ch2:\n    fmt.Println("From ch2:", msg)\ndefault:\n    fmt.Println("No data yet")\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:"Timeout with select"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'select {\ncase msg := <-ch:\n    fmt.Println("Received:", msg)\ncase <-time.After(2 * time.Second):\n    fmt.Println("Timeout!")\n}\n'})}),"\n",(0,r.jsx)(e.h2,{id:"closing-channels--cleanup",children:"Closing Channels & Cleanup"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Only the sender should close a channel."}),"\n",(0,r.jsxs)(e.li,{children:["Closing a channel signals ",(0,r.jsx)(e.strong,{children:"no more data will be sent"}),"."]}),"\n",(0,r.jsx)(e.li,{children:"Receivers can still read any buffered data before closure."}),"\n",(0,r.jsxs)(e.li,{children:["Reading from a closed channel returns the ",(0,r.jsx)(e.strong,{children:"zero value"})," and ",(0,r.jsx)(e.code,{children:"ok = false"}),"."]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Example:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:'val, ok := <-ch\nif !ok {\n    fmt.Println("Channel closed")\n}\n'})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Best Practice:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func producer(ch chan<- int) {\n    defer close(ch) // Always close when done\n    for i := 0; i < 5; i++ {\n        ch <- i\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,r.jsx)(e.h3,{id:"worker-pool",children:"Worker Pool"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func worker(id int, jobs <-chan int, results chan<- int, wg *sync.WaitGroup) {\n    defer wg.Done()\n    for job := range jobs {\n        results <- job * 2\n    }\n}\n\nfunc main() {\n    jobs := make(chan int, 5)\n    results := make(chan int, 5)\n    var wg sync.WaitGroup\n\n    for w := 1; w <= 3; w++ {\n        wg.Add(1)\n        go worker(w, jobs, results, &wg)\n    }\n\n    for j := 1; j <= 5; j++ {\n        jobs <- j\n    }\n    close(jobs)\n\n    wg.Wait()\n    close(results)\n\n    for r := range results {\n        fmt.Println(r)\n    }\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"fan-out--fan-in",children:"Fan-out / Fan-in"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fan-out: Multiple goroutines consume from the same channel"}),"\n",(0,r.jsx)(e.li,{children:"Fan-in: Multiple goroutines send into the same channel to aggregate results"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"pipelines",children:"Pipelines"}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"Chaining goroutines:"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-go",children:"func gen(nums ...int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for _, n := range nums {\n            out <- n\n        }\n        close(out)\n    }()\n    return out\n}\n\nfunc sq(in <-chan int) <-chan int {\n    out := make(chan int)\n    go func() {\n        for n := range in {\n            out <- n * n\n        }\n        close(out)\n    }()\n    return out\n}\n"})}),"\n",(0,r.jsx)(e.h2,{id:"pitfalls",children:"Pitfalls"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Deadlocks if sender/receiver counts don\u2019t match"}),"\n",(0,r.jsx)(e.li,{children:"Closing a channel twice causes panic"}),"\n",(0,r.jsx)(e.li,{children:"Buffered channels can fill up and block senders unexpectedly"}),"\n",(0,r.jsx)(e.li,{children:"Zero value reads from closed channels can mask logic errors"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Close channels only from the sending side"}),"\n",(0,r.jsx)(e.li,{children:"Use defer close() in producer goroutines"}),"\n",(0,r.jsx)(e.li,{children:"Use directional channels for clarity"}),"\n",(0,r.jsx)(e.li,{children:"Use select for multiple channels or timeouts"}),"\n",(0,r.jsx)(e.li,{children:"Avoid very large buffer sizes unless justified \u2014 large buffers can hide backpressure problems"}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},28453:(n,e,s)=>{s.d(e,{R:()=>c,x:()=>o});var i=s(96540);const r={},l=i.createContext(r);function c(n){const e=i.useContext(l);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:c(n.components),i.createElement(l.Provider,{value:e},n.children)}}}]);