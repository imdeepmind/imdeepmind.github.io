"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[4859],{42369:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>i,contentTitle:()=>c,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>s});const o=JSON.parse('{"id":"programming-languages/python/generational-garbage-collector","title":"Generational Garbage Collection","description":"The Object Graph","source":"@site/docs/programming-languages/python/generational-garbage-collector.md","sourceDirName":"programming-languages/python","slug":"/programming-languages/python/generational-garbage-collector","permalink":"/docs/programming-languages/python/generational-garbage-collector","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming-languages/python/generational-garbage-collector.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1745158213000,"sidebarPosition":23,"frontMatter":{"sidebar_position":23},"sidebar":"tutorialSidebar","previous":{"title":"Reference Counting","permalink":"/docs/programming-languages/python/reference-counting"},"next":{"title":"Introduction","permalink":"/docs/programming-languages/javascript/introduction"}}');var t=r(74848),l=r(28453);const a={sidebar_position:23},c="Generational Garbage Collection",i={},s=[{value:"The Object Graph",id:"the-object-graph",level:2},{value:"How the Garbage Collector Works",id:"how-the-garbage-collector-works",level:2},{value:"Generational Garbage Collection",id:"generational-garbage-collection-1",level:3},{value:"Collection Strategy for Each Generation",id:"collection-strategy-for-each-generation",level:3},{value:"How Generational Garbage Collection Solves Circular References",id:"how-generational-garbage-collection-solves-circular-references",level:2},{value:"Object Graph in Generational GC",id:"object-graph-in-generational-gc",level:3},{value:"Mark-and-Sweep Process",id:"mark-and-sweep-process",level:3},{value:"Example of Circular Reference Collection",id:"example-of-circular-reference-collection",level:3},{value:"The Garbage Collection Process in Detail",id:"the-garbage-collection-process-in-detail",level:2},{value:"Generation 0",id:"generation-0",level:3},{value:"Promotion to Generation 1",id:"promotion-to-generation-1",level:3},{value:"Generation 1",id:"generation-1",level:3},{value:"Generation 2",id:"generation-2",level:3},{value:"Visualization of the Garbage Collection Process",id:"visualization-of-the-garbage-collection-process",level:2},{value:"Generational Garbage Collection",id:"generational-garbage-collection-2",level:3},{value:"Circular Reference Detection in the Object Graph",id:"circular-reference-detection-in-the-object-graph",level:3}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"generational-garbage-collection",children:"Generational Garbage Collection"})}),"\n",(0,t.jsx)(n.h2,{id:"the-object-graph",children:"The Object Graph"}),"\n",(0,t.jsxs)(n.p,{children:["In Python, all objects are part of an ",(0,t.jsx)(n.strong,{children:"object graph"}),". An ",(0,t.jsx)(n.strong,{children:"object graph"})," is a structure that maps out the relationships between objects. Each node in this graph represents an object, and the edges between nodes represent references from one object to another."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, if object A references object B, and object B references object A, a ",(0,t.jsx)(n.strong,{children:"cyclic reference"})," exists. The object graph looks like this:"]}),"\n",(0,t.jsx)(n.mermaid,{value:'graph TD\n    A[Object A] --\x3e B[Object B]\n    B --\x3e |"Circular Reference"|A'}),"\n",(0,t.jsx)(n.p,{children:"In this scenario:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Object A"})," holds a reference to ",(0,t.jsx)(n.strong,{children:"Object B"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Object B"})," holds a reference to ",(0,t.jsx)(n.strong,{children:"Object A"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The garbage collector must identify and collect these objects when they are no longer reachable, even though their reference counts are not zero."}),"\n",(0,t.jsx)(n.h2,{id:"how-the-garbage-collector-works",children:"How the Garbage Collector Works"}),"\n",(0,t.jsxs)(n.p,{children:["Python\u2019s garbage collection system automatically reclaims memory from objects that are no longer referenced. The ",(0,t.jsx)(n.strong,{children:"garbage collector (GC)"})," is responsible for:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Detecting Unreachable Objects"}),": Objects that are no longer accessible from any root references (i.e., they cannot be reached via the object graph)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cleaning Up Circular References"}),": The GC handles cyclic references that reference counting cannot clean up by itself."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"generational-garbage-collection-1",children:"Generational Garbage Collection"}),"\n",(0,t.jsxs)(n.p,{children:["Python\u2019s garbage collection uses the ",(0,t.jsx)(n.strong,{children:"generational garbage collection"})," model. The idea behind generational GC is that most objects tend to be short-lived, and the longer an object survives, the less likely it is to become garbage."]}),"\n",(0,t.jsxs)(n.p,{children:["Python uses three ",(0,t.jsx)(n.strong,{children:"generations"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generation 0"}),": New objects that are most likely to become garbage soon."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generation 1"}),": Objects that survived at least one garbage collection cycle in Generation 0."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generation 2"}),": Objects that survived multiple garbage collection cycles and are likely to persist."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"collection-strategy-for-each-generation",children:"Collection Strategy for Each Generation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generation 0"}),": Collected frequently (young objects are more likely to be garbage)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generation 1"}),": Collected less frequently."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Generation 2"}),": Collected the least (older objects are more likely to stay alive)."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"how-generational-garbage-collection-solves-circular-references",children:"How Generational Garbage Collection Solves Circular References"}),"\n",(0,t.jsxs)(n.p,{children:["Reference counting alone cannot handle ",(0,t.jsx)(n.strong,{children:"cyclic references"}),". If objects reference each other in a cycle (e.g., object A references object B and vice versa), their reference count will never drop to zero, so they will not be collected by reference counting."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Generational garbage collection"})," solves this problem by periodically scanning for circular references, even if those objects\u2019 reference counts aren\u2019t zero."]}),"\n",(0,t.jsx)(n.h3,{id:"object-graph-in-generational-gc",children:"Object Graph in Generational GC"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Marking"}),": The garbage collector scans the object graph starting from the root references. It marks all objects that can be reached (i.e., reachable objects)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Identifying Cycles"}),": If an object is not reachable from the root but is still part of a cycle, the garbage collector detects this as a cycle and can safely collect the objects in that cycle."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"mark-and-sweep-process",children:"Mark-and-Sweep Process"}),"\n",(0,t.jsxs)(n.p,{children:["Python\u2019s garbage collection follows a ",(0,t.jsx)(n.strong,{children:"mark-and-sweep"})," approach, which works as follows:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mark Phase"}),": The GC marks all reachable objects, starting from the root of the object graph. The root can be global variables, function call stacks, or any object that can be directly accessed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Sweep Phase"}),": After marking, the GC sweeps through the objects. Any object that is not marked (i.e., unreachable) is considered garbage and is eligible for deallocation."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"In the context of circular references, the GC will detect cycles even if the objects involved in the cycle are not directly reachable."}),"\n",(0,t.jsx)(n.h3,{id:"example-of-circular-reference-collection",children:"Example of Circular Reference Collection"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class Node:\n    def __init__(self, value):\n        self.value = value\n        self.next = None\n\n# Creating a circular reference\na = Node(1)\nb = Node(2)\na.next = b\nb.next = a  # Circular reference (a -> b -> a)\n\n# When we delete the objects, they will not be collected by reference counting alone\ndel a\ndel b\n\n# Python's GC will detect the cycle and collect the objects\nimport gc\ngc.collect()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the object graph, after ",(0,t.jsx)(n.code,{children:"del a"})," and ",(0,t.jsx)(n.code,{children:"del b"}),", the objects ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are no longer reachable from any root, but their reference counts don\u2019t drop to zero due to the circular reference. The garbage collector identifies and cleans up these objects."]}),"\n",(0,t.jsx)(n.h2,{id:"the-garbage-collection-process-in-detail",children:"The Garbage Collection Process in Detail"}),"\n",(0,t.jsx)(n.p,{children:"Here\u2019s a step-by-step explanation of how garbage collection works with the generational model:"}),"\n",(0,t.jsx)(n.h3,{id:"generation-0",children:"Generation 0"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frequent Collection"}),": Objects in Generation 0 are the first to be collected. If any of them reference objects in Generation 1 or 2, those objects\u2019 reference counts are decremented."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Circular Reference Check"}),": The garbage collector checks for circular references in Generation 0. If objects are part of a cycle but not reachable from the root, they are marked as garbage and deallocated."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"promotion-to-generation-1",children:"Promotion to Generation 1"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If an object survives a garbage collection cycle in Generation 0, it is promoted to Generation 1."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"generation-1",children:"Generation 1"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Less Frequent Collection"}),": Objects in Generation 1 are collected less often. The GC checks Generation 1 for circular references and unreachable objects."]}),"\n",(0,t.jsx)(n.li,{children:"If objects in Generation 1 survive, they are promoted to Generation 2."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"generation-2",children:"Generation 2"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Rarely Collected"}),": Objects in Generation 2 are collected the least. However, when they are collected, the GC performs a thorough search for cycles."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Circular Reference Detection"}),": The GC will check for cycles between older objects (from Generation 1 and 2), cleaning them up as needed."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"visualization-of-the-garbage-collection-process",children:"Visualization of the Garbage Collection Process"}),"\n",(0,t.jsx)(n.h3,{id:"generational-garbage-collection-2",children:"Generational Garbage Collection"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[Generation 0] --\x3e|Collect frequently| B[Mark & Sweep]\n    B --\x3e|Promote to Gen 1| C[Generation 1]\n    C --\x3e|Collect occasionally| D[Mark & Sweep]\n    D --\x3e|Promote to Gen 2| E[Generation 2]\n    E --\x3e|Collect rarely| F[Mark & Sweep]"}),"\n",(0,t.jsx)(n.h3,{id:"circular-reference-detection-in-the-object-graph",children:"Circular Reference Detection in the Object Graph"}),"\n",(0,t.jsx)(n.mermaid,{value:"graph TD\n    A[Object A] --\x3e B[Object B]\n    B --\x3e C[Object C]\n    C --\x3e |Circular Reference|A\n    A --\x3e|Unreachable from root| D[Garbage Collector]\n    D --\x3e|Reclaims memory| E[Deallocated]"})]})}function d(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},28453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>c});var o=r(96540);const t={},l=o.createContext(t);function a(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);