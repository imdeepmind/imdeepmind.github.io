"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[6139],{89757:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"databases/database-engineering/transactions","title":"Transactions","description":"A transaction in a database is a sequence of operations that are executed as a single unit of work. Transactions ensure that the database maintains consistency, reliability, and integrity even in situations where errors, crashes, or concurrent updates occur. Transactions allow multiple database operations to be grouped together, so either all the operations succeed or none of them are applied, preserving the consistency of the database.","source":"@site/docs/databases/database-engineering/transactions.md","sourceDirName":"databases/database-engineering","slug":"/databases/database-engineering/transactions","permalink":"/docs/databases/database-engineering/transactions","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-engineering/transactions.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735227237000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Connection Pooling","permalink":"/docs/databases/database-engineering/pooling"},"next":{"title":"ACID","permalink":"/docs/databases/database-engineering/acid"}}');var s=a(74848),i=a(28453);const r={sidebar_position:3},o="Transactions",c={},l=[{value:"Transaction Lifecycle",id:"transaction-lifecycle",level:2},{value:"Begin Transaction",id:"begin-transaction",level:3},{value:"Perform Operations",id:"perform-operations",level:3},{value:"Commit Transaction",id:"commit-transaction",level:3},{value:"Rollback Transaction",id:"rollback-transaction",level:3},{value:"Advantages of Transactions",id:"advantages-of-transactions",level:2},{value:"Concurrency Control and Locking",id:"concurrency-control-and-locking",level:2},{value:"Transaction Isolation Levels",id:"transaction-isolation-levels",level:2},{value:"Read Committed (Default)",id:"read-committed-default",level:3},{value:"Repeatable Read",id:"repeatable-read",level:3},{value:"Serializable",id:"serializable",level:3},{value:"Transaction Deadlocks",id:"transaction-deadlocks",level:2},{value:"Savepoints",id:"savepoints",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"transactions",children:"Transactions"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"transaction"})," in a database is a sequence of operations that are executed as a single unit of work. Transactions ensure that the database maintains consistency, reliability, and integrity even in situations where errors, crashes, or concurrent updates occur. Transactions allow multiple database operations to be grouped together, so either all the operations succeed or none of them are applied, preserving the consistency of the database."]}),"\n",(0,s.jsx)(n.h2,{id:"transaction-lifecycle",children:"Transaction Lifecycle"}),"\n",(0,s.jsx)(n.p,{children:"A transaction follows a specific lifecycle, consisting of four main stages:"}),"\n",(0,s.jsx)(n.h3,{id:"begin-transaction",children:"Begin Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["A transaction starts when a command such as ",(0,s.jsx)(n.code,{children:"BEGIN"})," or ",(0,s.jsx)(n.code,{children:"START TRANSACTION"})," is issued. This marks the beginning of a new transaction."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"BEGIN;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"perform-operations",children:"Perform Operations"}),"\n",(0,s.jsxs)(n.p,{children:["During the transaction, several SQL operations (e.g., ",(0,s.jsx)(n.code,{children:"INSERT"}),", ",(0,s.jsx)(n.code,{children:"UPDATE"}),", ",(0,s.jsx)(n.code,{children:"DELETE"}),") are executed. These operations are treated as part of a single unit of work."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"UPDATE accounts SET balance = balance - 100 WHERE id = 1;\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"commit-transaction",children:"Commit Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["Once all the operations within the transaction are successfully executed, the transaction is committed using the ",(0,s.jsx)(n.code,{children:"COMMIT"})," command. This makes all changes permanent in the database."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"COMMIT;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"rollback-transaction",children:"Rollback Transaction"}),"\n",(0,s.jsxs)(n.p,{children:["If an error occurs during the transaction, or if the changes are no longer needed, the transaction can be rolled back. The ",(0,s.jsx)(n.code,{children:"ROLLBACK"})," command undoes all the operations performed in the transaction, restoring the database to its state before the transaction started."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"ROLLBACK;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"advantages-of-transactions",children:"Advantages of Transactions"}),"\n",(0,s.jsx)(n.p,{children:"Transactions offer several important benefits that help maintain the integrity and performance of the database:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Consistency:"})," Transactions ensure that the database remains in a consistent state. If a transaction involves multiple operations, the database is either updated with all the changes, or none of them are applied. This guarantees the integrity of the data."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Reliability:"})," Transactions make sure that database operations are applied reliably, even in the event of system crashes. Once a transaction is committed, the changes are permanent, ensuring that the database reflects the intended operations."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Atomicity:"})," The atomic nature of a transaction means that all operations within the transaction are treated as a single unit. If one operation fails, the entire transaction is rolled back, ensuring that partial updates do not corrupt the database."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Concurrency:"})," In multi-user environments, transactions help manage concurrent access to the database. They ensure that each transaction works as if it Oure the only transaction in the system, preventing conflicts and maintaining consistency."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Error Handling:"})," If an error occurs during a transaction, the changes can be rolled back, and the database can return to its previous consistent state. This helps to avoid partial updates or data corruption."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Simplified Development:"})," Using transactions simplifies the development of complex operations by allowing developers to group multiple SQL statements into a single unit of work. This eliminates the need for manually managing intermediate states."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"concurrency-control-and-locking",children:"Concurrency Control and Locking"}),"\n",(0,s.jsxs)(n.p,{children:["In multi-user environments, where multiple transactions can occur simultaneously, it's important to manage how transactions interact with each other to avoid conflicts. Databases use ",(0,s.jsx)(n.strong,{children:"locks"})," to ensure that one transaction does not interfere with another, maintaining data integrity."]}),"\n",(0,s.jsx)(n.p,{children:"There are several types of locks:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Row-level locks:"})," Prevent other transactions from modifying or reading a row that is being modified by another transaction."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Table-level locks:"})," Prevent any other transaction from accessing the entire table while a transaction is modifying it."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In PostgreSQL, We can use commands like ",(0,s.jsx)(n.code,{children:"FOR UPDATE"})," or ",(0,s.jsx)(n.code,{children:"FOR SHARE"})," to lock rows explicitly within a transaction."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"BEGIN;\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;  -- Lock row for update\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"transaction-isolation-levels",children:"Transaction Isolation Levels"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"isolation level"})," of a transaction controls how the operations of one transaction are visible to others. The goal of isolation is to prevent issues like ",(0,s.jsx)(n.strong,{children:"dirty reads"}),", ",(0,s.jsx)(n.strong,{children:"non-repeatable reads"}),", and ",(0,s.jsx)(n.strong,{children:"phantom reads"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"PostgreSQL supports several isolation levels:"}),"\n",(0,s.jsx)(n.h3,{id:"read-committed-default",children:"Read Committed (Default)"}),"\n",(0,s.jsx)(n.p,{children:"The default level where a transaction can only see data committed before it started. It prevents dirty reads but allows non-repeatable reads."}),"\n",(0,s.jsx)(n.h3,{id:"repeatable-read",children:"Repeatable Read"}),"\n",(0,s.jsx)(n.p,{children:"Ensures that if a transaction reads a value, it will always read the same value throughout the transaction. This prevents dirty reads and non-repeatable reads, but phantom reads can still occur."}),"\n",(0,s.jsx)(n.h3,{id:"serializable",children:"Serializable"}),"\n",(0,s.jsx)(n.p,{children:"The highest level of isolation, where transactions are executed as if they Oure processed serially (one after another), completely eliminating dirty reads, non-repeatable reads, and phantom reads."}),"\n",(0,s.jsx)(n.h2,{id:"transaction-deadlocks",children:"Transaction Deadlocks"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"deadlock"})," occurs when two or more transactions are waiting for each other to release locks, causing the transactions to get stuck in a cycle of dependencies. Deadlocks can cause transactions to be stuck indefinitely, and the database system must detect and resolve these deadlocks by rolling back one of the transactions involved."]}),"\n",(0,s.jsx)(n.p,{children:"For example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Transaction A locks resource 1 and waits for resource 2."}),"\n",(0,s.jsx)(n.li,{children:"Transaction B locks resource 2 and waits for resource 1."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The database detects this circular waiting and will typically roll back one of the transactions to break the deadlock."}),"\n",(0,s.jsx)(n.h2,{id:"savepoints",children:"Savepoints"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.strong,{children:"savepoint"})," allows We to set a point within a transaction to which We can later roll back, without affecting the entire transaction. This is useful for partial rollbacks, particularly in complex transactions where only a part of the transaction needs to be undone."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Example:"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",children:"BEGIN;\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nSAVEPOINT sp1;  -- Create a savepoint\nUPDATE accounts SET balance = balance + 100 WHERE id = 2;\n-- If the second update fails, roll back to the savepoint without affecting the first update\nROLLBACK TO SAVEPOINT sp1;\nCOMMIT;\n"})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var t=a(96540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);