"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[8543],{59081:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"containers/kubernetes/networking","title":"Networking","description":"Kubernetes networking is a broad topic that covers how Pods, Services, and external clients communicate within and outside a cluster. Kubernetes intentionally leaves many implementation details to network plugins (CNI) and cloud providers, while defining a small set of strong primitives and expectations that make the model consistent across environments.","source":"@site/docs/containers/kubernetes/networking.md","sourceDirName":"containers/kubernetes","slug":"/containers/kubernetes/networking","permalink":"/docs/containers/kubernetes/networking","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/containers/kubernetes/networking.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1757850753000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Deployments","permalink":"/docs/containers/kubernetes/deployments"},"next":{"title":"Services","permalink":"/docs/containers/kubernetes/services"}}');var i=s(74848),t=s(28453);const o={sidebar_position:7},l="Networking",a={},c=[{value:"Core network model",id:"core-network-model",level:2},{value:"Pod networking and CNI",id:"pod-networking-and-cni",level:2},{value:"Services and Service Types",id:"services-and-service-types",level:2},{value:"How Services are implemented (kube-proxy)",id:"how-services-are-implemented-kube-proxy",level:2},{value:"DNS and Service Discovery",id:"dns-and-service-discovery",level:2},{value:"Endpoints vs EndpointSlices",id:"endpoints-vs-endpointslices",level:2},{value:"Ingress and Ingress Controller",id:"ingress-and-ingress-controller",level:2},{value:"NetworkPolicy: controlling traffic",id:"networkpolicy-controlling-traffic",level:2},{value:"Services vs Ingress vs External access",id:"services-vs-ingress-vs-external-access",level:2},{value:"Service Meshes",id:"service-meshes",level:2},{value:"Multicluster and ExternalName",id:"multicluster-and-externalname",level:2},{value:"Troubleshooting and useful kubectl commands",id:"troubleshooting-and-useful-kubectl-commands",level:2},{value:"Edge cases and gotchas",id:"edge-cases-and-gotchas",level:2},{value:"Quick reference",id:"quick-reference",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"networking",children:"Networking"})}),"\n",(0,i.jsx)(n.p,{children:"Kubernetes networking is a broad topic that covers how Pods, Services, and external clients communicate within and outside a cluster. Kubernetes intentionally leaves many implementation details to network plugins (CNI) and cloud providers, while defining a small set of strong primitives and expectations that make the model consistent across environments."}),"\n",(0,i.jsx)(n.p,{children:"This note covers core concepts, common service types, the role of kube-proxy and CNI, DNS and service discovery, NetworkPolicies, Ingress, service meshes, and practical troubleshooting commands."}),"\n",(0,i.jsx)(n.h2,{id:"core-network-model",children:"Core network model"}),"\n",(0,i.jsx)(n.p,{children:"Kubernetes networking defines a few simple yet powerful expectations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Every Pod gets its own IP address. Containers inside the Pod share the network namespace and can communicate over localhost."}),"\n",(0,i.jsx)(n.li,{children:"Pods can communicate with other Pods using their IP addresses without NAT."}),"\n",(0,i.jsx)(n.li,{children:"Agents on a node (like kube-proxy) can implement Services without exposing nodes unnecessarily."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Because Pods are ephemeral, higher-level abstractions (Services, Endpoints) provide stable identities."}),"\n",(0,i.jsx)(n.h2,{id:"pod-networking-and-cni",children:"Pod networking and CNI"}),"\n",(0,i.jsx)(n.p,{children:"Container Network Interface (CNI) is the plugin model Kubernetes uses for networking. A CNI plugin is responsible for allocating IPs to Pods, programming routes, and handling connectivity between nodes."}),"\n",(0,i.jsx)(n.p,{children:"Popular CNI implementations:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Calico \u2014 Network policies + routing, BGP support"}),"\n",(0,i.jsx)(n.li,{children:"Flannel \u2014 Simple overlay network (VXLAN)"}),"\n",(0,i.jsx)(n.li,{children:"Weave Net \u2014 Mesh networking with encryption options"}),"\n",(0,i.jsx)(n.li,{children:"Cilium \u2014 eBPF-based networking and observability"}),"\n",(0,i.jsx)(n.li,{children:"Canal \u2014 Calico + Flannel combination"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"How a CNI integrates:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"When the kubelet creates a Pod, it calls the configured CNI to allocate an IP and set up interfaces."}),"\n",(0,i.jsx)(n.li,{children:"The CNI configures the node networking (veth pairs, routes, VXLAN tunnels, BPF programs, etc.)."}),"\n",(0,i.jsx)(n.li,{children:"The clusterwide routing allows Pod-to-Pod communication across nodes."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"services-and-service-types",children:"Services and Service Types"}),"\n",(0,i.jsx)(n.p,{children:"Services provide a stable DNS name and virtual IP (ClusterIP) to reach a set of Pods (Endpoints). The main service types are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"ClusterIP (default): Exposes the Service on a cluster-internal IP. Only reachable from within the cluster."}),"\n",(0,i.jsx)(n.li,{children:"NodePort: Exposes the Service on the same port on each Node\u2019s IP. Good for simple external access or testing."}),"\n",(0,i.jsx)(n.li,{children:"LoadBalancer: Requests a cloud provider load balancer and exposes the Service externally."}),"\n",(0,i.jsx)(n.li,{children:"ExternalName: Maps a Service to an external DNS name."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example Service (ClusterIP):"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\nspec:\n  selector:\n    app: web\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Explanation: This Service selects Pods with label ",(0,i.jsx)(n.code,{children:"app: web"})," and forwards traffic from port 80 on the ClusterIP to port 8080 on the Pods."]}),"\n",(0,i.jsx)(n.h2,{id:"how-services-are-implemented-kube-proxy",children:"How Services are implemented (kube-proxy)"}),"\n",(0,i.jsx)(n.p,{children:"kube-proxy implements Services on nodes. There are two main modes historically:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"iptables mode: kube-proxy programs iptables rules to DNAT traffic from the Service IP to backend Pod IPs."}),"\n",(0,i.jsx)(n.li,{children:"ipvs mode: kube-proxy programs the Linux IPVS kernel subsystem for higher performance and better load balancing."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Newer CNI and kernel-based solutions (like eBPF with Cilium) can bypass kube-proxy for more efficient datapaths."}),"\n",(0,i.jsx)(n.h2,{id:"dns-and-service-discovery",children:"DNS and Service Discovery"}),"\n",(0,i.jsx)(n.p,{children:"Kubernetes runs a DNS server (CoreDNS by default) that watches Services and creates DNS records for them. Service discovery patterns:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Service name resolution: ",(0,i.jsx)(n.code,{children:"http://my-service"})," (in the same namespace) or ",(0,i.jsx)(n.code,{children:"http://my-service.my-namespace"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Fully qualified domain name (FQDN): ",(0,i.jsx)(n.code,{children:"my-service.my-namespace.svc.cluster.local"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Example: a Pod can curl another service by name:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl exec -it pod-a -- curl -sS http://web-service\n"})}),"\n",(0,i.jsx)(n.h2,{id:"endpoints-vs-endpointslices",children:"Endpoints vs EndpointSlices"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Endpoints: older API that lists IPs/ports for a Service."}),"\n",(0,i.jsx)(n.li,{children:"EndpointSlices: scalable replacement that shards endpoint information across multiple objects."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Kubernetes controllers keep EndpointSlices up to date as Pods scale and move."}),"\n",(0,i.jsx)(n.h2,{id:"ingress-and-ingress-controller",children:"Ingress and Ingress Controller"}),"\n",(0,i.jsx)(n.p,{children:"Ingress defines HTTP(S) routing rules from outside the cluster to Services inside the cluster. Ingress is only a routing spec \u2014 a separate Ingress Controller implements it (NGINX Ingress Controller, Traefik, HAProxy, cloud-managed controllers)."}),"\n",(0,i.jsx)(n.p,{children:"Example Ingress:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: web-ingress\nspec:\n  rules:\n    - host: example.com\n      http:\n        paths:\n          - path: /\n            pathType: Prefix\n            backend:\n              service:\n                name: web-service\n                port:\n                  number: 80\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note: For TLS, add a ",(0,i.jsx)(n.code,{children:"tls"})," section and a Secret with TLS certs."]}),"\n",(0,i.jsx)(n.h2,{id:"networkpolicy-controlling-traffic",children:"NetworkPolicy: controlling traffic"}),"\n",(0,i.jsx)(n.p,{children:"NetworkPolicy is a Kubernetes resource for allowing or denying traffic to Pods. By default, most clusters allow all traffic (depending on CNI behavior). Once any NetworkPolicy selects a Pod, that Pod becomes isolated and only the allowed traffic is permitted."}),"\n",(0,i.jsx)(n.p,{children:"Example: allow only traffic from the same namespace and a specific port"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-same-namespace\n  namespace: default\nspec:\n  podSelector: {}\n  policyTypes:\n    - Ingress\n  ingress:\n    - from:\n        - podSelector: {}\n      ports:\n        - protocol: TCP\n          port: 80\n"})}),"\n",(0,i.jsx)(n.p,{children:"Important notes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"NetworkPolicies are implemented by the CNI plugin; not all CNIs support them equally."}),"\n",(0,i.jsx)(n.li,{children:"NetworkPolicies can be used to implement zero-trust or micro-segmentation inside the cluster."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"services-vs-ingress-vs-external-access",children:"Services vs Ingress vs External access"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use Services (ClusterIP/NodePort/LoadBalancer) to expose applications. ClusterIP for internal traffic, LoadBalancer/NodePort for external."}),"\n",(0,i.jsx)(n.li,{children:"Use Ingress for rich HTTP routing (virtual hosts, TLS termination, path-based routing). Ingress sits in front of Services."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"service-meshes",children:"Service Meshes"}),"\n",(0,i.jsx)(n.p,{children:"Service meshes (Istio, Linkerd, Consul Connect) provide finer-grained control over traffic (mTLS, retries, circuit breaking, observability). They typically inject sidecar proxies into Pods and introduce control planes to manage traffic policies."}),"\n",(0,i.jsx)(n.p,{children:"When to use a service mesh:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"You need mutual TLS between services."}),"\n",(0,i.jsx)(n.li,{children:"You want traffic observability (tracing, metrics) without changing application code."}),"\n",(0,i.jsx)(n.li,{children:"You need advanced routing (canary releases, traffic shifting)."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Trade-offs: increased complexity, resource overhead, and operational surface area."}),"\n",(0,i.jsx)(n.h2,{id:"multicluster-and-externalname",children:"Multicluster and ExternalName"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ExternalName"})," Services map a Service to an external DNS name and are useful to reference external services without handling IPs."]}),"\n",(0,i.jsx)(n.li,{children:"Multicluster networking is an advanced topic \u2014 solutions include service meshes with multi-cluster support, DNS federation, or VPN-based networking between clusters."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"troubleshooting-and-useful-kubectl-commands",children:"Troubleshooting and useful kubectl commands"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"List Services:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl get svc\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Describe a Service:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl describe svc web-service\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"List Endpoints / EndpointSlices:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl get endpoints\nkubectl get endpointslices\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check DNS resolution inside a Pod:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl run -it --rm dns-test --image=busybox --restart=Never -- nslookup web-service\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Test connectivity between Pods (exec into a debug pod):"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl run -it --rm -n default debug --image=nicolaka/netshoot --restart=Never -- bash\n# inside container: curl web-service:80\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"View kube-proxy mode and pods:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"kubectl -n kube-system get pods -l k8s-app=kube-proxy\nkubectl -n kube-system describe daemonset kube-proxy\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Check NetworkPolicy effects (deny/allow):"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Create a policy and test connectivity from allowed and denied Pods."}),"\n",(0,i.jsx)(n.h2,{id:"edge-cases-and-gotchas",children:"Edge cases and gotchas"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pod IP address ranges must not overlap with node network or cloud provider routes."}),"\n",(0,i.jsx)(n.li,{children:"Some CNIs use overlays which can affect MTU; tune MTU to avoid fragmented packets."}),"\n",(0,i.jsx)(n.li,{children:"HostPort and HostNetwork bypass the CNI and can cause port conflicts on nodes."}),"\n",(0,i.jsx)(n.li,{children:"IPv6 and dual-stack clusters require additional CNI and cloud-provider support."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"quick-reference",children:"Quick reference"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Pod networking: CNI plugins allocate Pod IPs and program node-level networking."}),"\n",(0,i.jsx)(n.li,{children:"Services: ClusterIP, NodePort, LoadBalancer, ExternalName."}),"\n",(0,i.jsx)(n.li,{children:"Ingress: HTTP routing; requires an Ingress Controller to function."}),"\n",(0,i.jsx)(n.li,{children:"NetworkPolicy: API to define allowed traffic to Pods; enforced by CNI."}),"\n",(0,i.jsx)(n.li,{children:"kube-proxy: implements Service routing using iptables/ipvs or newer datapaths."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var r=s(96540);const i={},t=r.createContext(i);function o(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);