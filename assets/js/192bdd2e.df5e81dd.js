"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[3842],{2444:(n,s,e)=>{e.r(s),e.d(s,{assets:()=>t,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"databases/database-engineering/sharding","title":"Database Sharding","description":"Sharding is a database architecture pattern where data is horizontally partitioned across multiple databases or nodes, often referred to as shards. Each shard contains a subset of the total data, making the overall system more scalable and resilient. It is particularly useful for handling very large datasets and high-throughput applications.","source":"@site/docs/databases/database-engineering/sharding.md","sourceDirName":"databases/database-engineering","slug":"/databases/database-engineering/sharding","permalink":"/docs/databases/database-engineering/sharding","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-engineering/sharding.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735294169000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Database Partitioning","permalink":"/docs/databases/database-engineering/partitioning"},"next":{"title":"Introduction","permalink":"/docs/databases/database-systems/introduction"}}');var r=e(4848),d=e(8453);const a={sidebar_position:9},l="Database Sharding",t={},h=[{value:"Why Sharding is Needed?",id:"why-sharding-is-needed",level:2},{value:"How Sharding Works",id:"how-sharding-works",level:2},{value:"Steps in Sharding",id:"steps-in-sharding",level:3},{value:"Sharding Strategies",id:"sharding-strategies",level:2},{value:"Range-Based Sharding",id:"range-based-sharding",level:3},{value:"Hash-Based Sharding",id:"hash-based-sharding",level:3},{value:"Directory-Based Sharding",id:"directory-based-sharding",level:3},{value:"Advantages of Sharding",id:"advantages-of-sharding",level:2},{value:"Disadvantages of Sharding",id:"disadvantages-of-sharding",level:2},{value:"Sharding vs Partitioning",id:"sharding-vs-partitioning",level:2},{value:"Sharding vs Replication",id:"sharding-vs-replication",level:2},{value:"Use Cases of Sharding",id:"use-cases-of-sharding",level:2},{value:"Sharding in Practice",id:"sharding-in-practice",level:2}];function c(n){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"database-sharding",children:"Database Sharding"})}),"\n",(0,r.jsxs)(s.p,{children:["Sharding is a database architecture pattern where data is horizontally partitioned across multiple databases or nodes, often referred to as ",(0,r.jsx)(s.strong,{children:"shards"}),". Each shard contains a subset of the total data, making the overall system more scalable and resilient. It is particularly useful for handling very large datasets and high-throughput applications."]}),"\n",(0,r.jsx)(s.h2,{id:"why-sharding-is-needed",children:"Why Sharding is Needed?"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Scalability"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Single database systems have limitations in terms of storage capacity and throughput. Sharding allows for horizontal scaling by distributing data across multiple nodes."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Performance"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Queries can be processed in parallel on multiple shards, reducing response times for large datasets."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"High Availability"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"In case of a failure on one shard, the others can continue to operate, improving overall system availability."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Data Isolation"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Data can be logically separated based on application needs, making it easier to manage and query specific subsets."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"how-sharding-works",children:"How Sharding Works"}),"\n",(0,r.jsxs)(s.p,{children:["In sharding, data is distributed across shards based on a ",(0,r.jsx)(s.strong,{children:"shard key"}),". The shard key determines how the data is split and placed into shards."]}),"\n",(0,r.jsx)(s.h3,{id:"steps-in-sharding",children:"Steps in Sharding"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Select Shard Key"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"A column or a combination of columns is chosen as the shard key. The key must provide even distribution of data across shards."}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Example: ",(0,r.jsx)(s.code,{children:"user_id"}),", ",(0,r.jsx)(s.code,{children:"region"}),", or ",(0,r.jsx)(s.code,{children:"order_id"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Distribute Data"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Data is distributed across shards based on a mapping function. Common methods include range-based, hash-based, or directory-based sharding."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Query Routing"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"A query router is used to route queries to the correct shard(s) based on the shard key."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"sharding-strategies",children:"Sharding Strategies"}),"\n",(0,r.jsx)(s.h3,{id:"range-based-sharding",children:"Range-Based Sharding"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Data is divided into shards based on value ranges of the shard key."}),"\n",(0,r.jsx)(s.li,{children:"Example: User data partitioned by age range or time range."}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Example:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Shard 1: Users with ",(0,r.jsx)(s.code,{children:"user_id"})," between 1 and 1,000,000."]}),"\n",(0,r.jsxs)(s.li,{children:["Shard 2: Users with ",(0,r.jsx)(s.code,{children:"user_id"})," between 1,000,001 and 2,000,000."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Easy to implement and understand."}),"\n",(0,r.jsx)(s.li,{children:"Good for queries targeting specific ranges."}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Risk of uneven data distribution if data growth is not uniform (hotspots)."}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"hash-based-sharding",children:"Hash-Based Sharding"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"A hash function is applied to the shard key to determine the shard for each row of data."}),"\n",(0,r.jsxs)(s.li,{children:["Example:","\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"shard_number = hash(user_id) % total_shards\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Ensures even distribution of data across shards."}),"\n",(0,r.jsx)(s.li,{children:"Avoids data hotspots."}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Difficult to perform range queries."}),"\n",(0,r.jsx)(s.li,{children:"Adding or removing shards requires rehashing (data migration)."}),"\n"]}),"\n",(0,r.jsx)(s.h3,{id:"directory-based-sharding",children:"Directory-Based Sharding"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"A lookup table is maintained to map shard keys to specific shards."}),"\n",(0,r.jsxs)(s.li,{children:["Example:","\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Shard 1: Data for ",(0,r.jsx)(s.code,{children:"region = 'US'"})]}),"\n",(0,r.jsxs)(s.li,{children:["Shard 2: Data for ",(0,r.jsx)(s.code,{children:"region = 'EU'"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Pros"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Flexible and customizable."}),"\n",(0,r.jsx)(s.li,{children:"Good for specific use cases with pre-defined keys."}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Cons"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"The lookup table can become a bottleneck."}),"\n",(0,r.jsx)(s.li,{children:"Maintenance overhead."}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"advantages-of-sharding",children:"Advantages of Sharding"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Horizontal Scalability"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Sharding allows for the addition of new nodes to handle increased data volumes or throughput."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Parallel Query Processing"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Queries are processed in parallel across shards, reducing query execution time."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Fault Tolerance"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"If one shard goes down, the other shards can continue to serve requests."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Data Locality"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Shards can be located geographically close to the users they serve, reducing latency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Cost Efficiency"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Instead of scaling vertically (e.g., adding expensive hardware), horizontal scaling with commodity servers reduces cost."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"disadvantages-of-sharding",children:"Disadvantages of Sharding"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Complexity"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Sharding increases system complexity. Query routing, data distribution, and maintenance require additional effort."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Data Rebalancing"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Adding or removing shards involves redistributing data, which can be costly and time-consuming."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Cross-Shard Queries"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Queries that span multiple shards can be slow and require additional logic for merging results."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Consistency"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Maintaining strong consistency across shards is difficult, especially in distributed systems."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Operational Overhead"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Monitoring, backup, and recovery of multiple shards is more complex than a single database."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"sharding-vs-partitioning",children:"Sharding vs Partitioning"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:(0,r.jsx)(s.strong,{children:"Aspect"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.strong,{children:"Sharding"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.strong,{children:"Partitioning"})})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Scope"})}),(0,r.jsx)(s.td,{children:"Data split across multiple databases/nodes."}),(0,r.jsx)(s.td,{children:"Data split within a single database."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Use Case"})}),(0,r.jsx)(s.td,{children:"Large-scale horizontal scaling."}),(0,r.jsx)(s.td,{children:"Optimizing queries and maintenance."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Query Routing"})}),(0,r.jsx)(s.td,{children:"Requires a query router."}),(0,r.jsx)(s.td,{children:"Queries are handled by the database."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Complexity"})}),(0,r.jsx)(s.td,{children:"Higher due to distributed nature."}),(0,r.jsx)(s.td,{children:"Lower as it resides in one database."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"sharding-vs-replication",children:"Sharding vs Replication"}),"\n",(0,r.jsxs)(s.table,{children:[(0,r.jsx)(s.thead,{children:(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.th,{children:(0,r.jsx)(s.strong,{children:"Aspect"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.strong,{children:"Sharding"})}),(0,r.jsx)(s.th,{children:(0,r.jsx)(s.strong,{children:"Replication"})})]})}),(0,r.jsxs)(s.tbody,{children:[(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Data Distribution"})}),(0,r.jsx)(s.td,{children:"Different data stored on each shard."}),(0,r.jsx)(s.td,{children:"Same data replicated across nodes."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Purpose"})}),(0,r.jsx)(s.td,{children:"Horizontal scaling for large datasets."}),(0,r.jsx)(s.td,{children:"High availability and redundancy."})]}),(0,r.jsxs)(s.tr,{children:[(0,r.jsx)(s.td,{children:(0,r.jsx)(s.strong,{children:"Query Routing"})}),(0,r.jsx)(s.td,{children:"Queries routed to specific shards."}),(0,r.jsx)(s.td,{children:"Queries served by any replica."})]})]})]}),"\n",(0,r.jsx)(s.h2,{id:"use-cases-of-sharding",children:"Use Cases of Sharding"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Large-Scale Applications"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Social media platforms with millions of users (e.g., Twitter, Facebook)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Time-Series Data"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"IoT or log data where new data grows indefinitely."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Geographic Distribution"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Applications with users spread across different regions."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"High-Write Workloads"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Applications with heavy insert/update operations (e.g., e-commerce platforms)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"sharding-in-practice",children:"Sharding in Practice"}),"\n",(0,r.jsxs)(s.ol,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"MongoDB"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Native support for sharding with automatic query routing."}),"\n",(0,r.jsx)(s.li,{children:"Sharding based on shard keys."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"MySQL"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Requires external tools (e.g., Vitess) or custom logic for sharding."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"PostgreSQL"}),":"]}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Uses partitioning or external tools like Citus for sharding."}),"\n"]}),"\n"]}),"\n"]})]})}function o(n={}){const{wrapper:s}={...(0,d.R)(),...n.components};return s?(0,r.jsx)(s,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},8453:(n,s,e)=>{e.d(s,{R:()=>a,x:()=>l});var i=e(6540);const r={},d=i.createContext(r);function a(n){const s=i.useContext(d);return i.useMemo((function(){return"function"==typeof n?n(s):{...s,...n}}),[s,n])}function l(n){let s;return s=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:a(n.components),i.createElement(d.Provider,{value:s},n.children)}}}]);