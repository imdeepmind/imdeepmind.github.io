"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[6030],{71559:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"data-structure-and-algorithms/algorithms/sliding-window","title":"Sliding Window","description":"The Sliding Window technique involves using a window (a subset of elements) that slides over an array or string to solve problems involving subarrays, substrings, or ranges. The window can expand, contract, or move to maintain specific properties like size or sum.","source":"@site/docs/data-structure-and-algorithms/algorithms/sliding-window.md","sourceDirName":"data-structure-and-algorithms/algorithms","slug":"/data-structure-and-algorithms/algorithms/sliding-window","permalink":"/docs/data-structure-and-algorithms/algorithms/sliding-window","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/data-structure-and-algorithms/algorithms/sliding-window.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1749215590000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Two Pointers","permalink":"/docs/data-structure-and-algorithms/algorithms/two-pointers"},"next":{"title":"Stack","permalink":"/docs/data-structure-and-algorithms/algorithms/stack"}}');var r=i(74848),t=i(28453);const l={sidebar_position:5},d="Sliding Window",o={},a=[{value:"Types of Sliding Windows",id:"types-of-sliding-windows",level:2},{value:"Time Complexity",id:"time-complexity",level:2},{value:"Common Problems Solved Using Sliding Window",id:"common-problems-solved-using-sliding-window",level:2},{value:"Example Algorithms and Problems",id:"example-algorithms-and-problems",level:2},{value:"Fixed-Size Window",id:"fixed-size-window",level:3},{value:"Maximum Sum of Subarray of Size <code>k</code>",id:"maximum-sum-of-subarray-of-size-k",level:4},{value:"Dynamic-Size Window",id:"dynamic-size-window",level:3},{value:"Smallest Subarray with Sum \u2265 <code>x</code>",id:"smallest-subarray-with-sum--x",level:4},{value:"Longest Substring Without Repeating Characters",id:"longest-substring-without-repeating-characters",level:3},{value:"Count Distinct Elements in Every Subarray of Size <code>k</code>",id:"count-distinct-elements-in-every-subarray-of-size-k",level:3},{value:"Advantages of Sliding Window",id:"advantages-of-sliding-window",level:2},{value:"When to Use Sliding Window",id:"when-to-use-sliding-window",level:2}];function c(n){const e={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"sliding-window",children:"Sliding Window"})}),"\n",(0,r.jsxs)(e.p,{children:["The ",(0,r.jsx)(e.strong,{children:"Sliding Window"})," technique involves using a window (a subset of elements) that slides over an array or string to solve problems involving subarrays, substrings, or ranges. The window can expand, contract, or move to maintain specific properties like size or sum."]}),"\n",(0,r.jsx)(e.p,{children:"This approach reduces the time complexity of problems that would otherwise require nested loops (O(n\xb2)) to linear time (O(n))."}),"\n",(0,r.jsx)(e.h2,{id:"types-of-sliding-windows",children:"Types of Sliding Windows"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Fixed-Sized Window"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"The window size remains constant while sliding."}),"\n",(0,r.jsxs)(e.li,{children:["Example: Maximum sum of subarray of size ",(0,r.jsx)(e.code,{children:"k"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Dynamic-Sized Window"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"The window size changes based on conditions (e.g., constraints on the sum, distinct elements)."}),"\n",(0,r.jsxs)(e.li,{children:["Example: Smallest subarray with a sum greater than ",(0,r.jsx)(e.code,{children:"x"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"time-complexity",children:"Time Complexity"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Efficient"}),": Sliding Window often processes each element once, resulting in O(n) time complexity."]}),"\n",(0,r.jsx)(e.li,{children:"The space complexity depends on the problem (e.g., using additional data structures like hash maps or sets)."}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"common-problems-solved-using-sliding-window",children:"Common Problems Solved Using Sliding Window"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Problem Type"}),(0,r.jsx)(e.th,{children:"Description"}),(0,r.jsx)(e.th,{children:"Example Problem"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Maximum or Minimum Subarray Sum"}),(0,r.jsx)(e.td,{children:"Find the subarray with the largest or smallest sum."}),(0,r.jsxs)(e.td,{children:["Maximum sum subarray of size ",(0,r.jsx)(e.code,{children:"k"})]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Longest Substring"}),(0,r.jsx)(e.td,{children:"Find the longest substring meeting specific constraints."}),(0,r.jsx)(e.td,{children:"Longest substring without repeating chars"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Smallest or Largest Subarray"}),(0,r.jsx)(e.td,{children:"Find the smallest or largest subarray meeting certain criteria."}),(0,r.jsxs)(e.td,{children:["Smallest subarray with sum \u2265 ",(0,r.jsx)(e.code,{children:"x"})]})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:"Frequency Analysis"}),(0,r.jsx)(e.td,{children:"Count or track elements in a fixed or dynamic window."}),(0,r.jsx)(e.td,{children:"Count distinct elements in every subarray"})]})]})]}),"\n",(0,r.jsx)(e.h2,{id:"example-algorithms-and-problems",children:"Example Algorithms and Problems"}),"\n",(0,r.jsx)(e.h3,{id:"fixed-size-window",children:"Fixed-Size Window"}),"\n",(0,r.jsxs)(e.h4,{id:"maximum-sum-of-subarray-of-size-k",children:["Maximum Sum of Subarray of Size ",(0,r.jsx)(e.code,{children:"k"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Given an array, find the maximum sum of any subarray of size ",(0,r.jsx)(e.code,{children:"k"}),"."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def max_sum_subarray(arr, k):\n    n = len(arr)\n    if n < k:\n        return -1\n\n    # Compute the sum of the first window\n    window_sum = sum(arr[:k])\n    max_sum = window_sum\n\n    # Slide the window\n    for i in range(k, n):\n        window_sum += arr[i] - arr[i - k]\n        max_sum = max(max_sum, window_sum)\n\n    return max_sum\n\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Time Complexity"}),": O(n)",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.strong,{children:"Space Complexity"}),": O(1)"]}),"\n",(0,r.jsx)(e.h3,{id:"dynamic-size-window",children:"Dynamic-Size Window"}),"\n",(0,r.jsxs)(e.h4,{id:"smallest-subarray-with-sum--x",children:["Smallest Subarray with Sum \u2265 ",(0,r.jsx)(e.code,{children:"x"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Find the length of the smallest subarray with a sum greater than or equal to ",(0,r.jsx)(e.code,{children:"x"}),"."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def min_subarray_len(arr, x):\n    n = len(arr)\n    min_len = float('inf')\n    current_sum = 0\n    left = 0\n\n    for right in range(n):\n        current_sum += arr[right]\n\n        # Shrink the window while the sum is \u2265 x\n        while current_sum >= x:\n            min_len = min(min_len, right - left + 1)\n            current_sum -= arr[left]\n            left += 1\n\n    return min_len if min_len != float('inf') else 0\n\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Time Complexity"}),": O(n)",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.strong,{children:"Space Complexity"}),": O(1)"]}),"\n",(0,r.jsx)(e.h3,{id:"longest-substring-without-repeating-characters",children:"Longest Substring Without Repeating Characters"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Find the longest substring without repeating characters."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"def longest_unique_substring(s):\n    char_set = set()\n    left = 0\n    max_length = 0\n\n    for right in range(len(s)):\n        while s[right] in char_set:\n            char_set.remove(s[left])\n            left += 1\n        char_set.add(s[right])\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Time Complexity"}),": O(n)",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.strong,{children:"Space Complexity"}),": O(n)"]}),"\n",(0,r.jsxs)(e.h3,{id:"count-distinct-elements-in-every-subarray-of-size-k",children:["Count Distinct Elements in Every Subarray of Size ",(0,r.jsx)(e.code,{children:"k"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Given an array and an integer ",(0,r.jsx)(e.code,{children:"k"}),", count the number of distinct elements in every subarray of size ",(0,r.jsx)(e.code,{children:"k"}),"."]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"from collections import defaultdict\n\ndef count_distinct_in_window(arr, k):\n    freq_map = defaultdict(int)\n    result = []\n\n    # Initialize the first window\n    for i in range(k):\n        freq_map[arr[i]] += 1\n    result.append(len(freq_map))\n\n    # Slide the window\n    for i in range(k, len(arr)):\n        # Remove the leftmost element\n        freq_map[arr[i - k]] -= 1\n        if freq_map[arr[i - k]] == 0:\n            del freq_map[arr[i - k]]\n\n        # Add the new element\n        freq_map[arr[i]] += 1\n\n        # Add the count of distinct elements to the result\n        result.append(len(freq_map))\n\n    return result\n\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Time Complexity"}),": O(n)",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.strong,{children:"Space Complexity"}),": O(k)"]}),"\n",(0,r.jsx)(e.h2,{id:"advantages-of-sliding-window",children:"Advantages of Sliding Window"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Efficiency"}),": Reduces nested loops (O(n\xb2)) to linear (O(n)) solutions."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Simplicity"}),": Often straightforward to implement for problems involving subarrays or substrings."]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Scalability"}),": Performs well for large input sizes."]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"when-to-use-sliding-window",children:"When to Use Sliding Window"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Subarray or Substring Problems"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Finding ranges or subsequences with specific constraints."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Optimizations"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Maximizing or minimizing a property within a range."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Frequency Tracking"}),":","\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Counting occurrences or distinct elements within a window."}),"\n"]}),"\n"]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(c,{...n})}):c(n)}},28453:(n,e,i)=>{i.d(e,{R:()=>l,x:()=>d});var s=i(96540);const r={},t=s.createContext(r);function l(n){const e=s.useContext(t);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:l(n.components),s.createElement(t.Provider,{value:e},n.children)}}}]);