"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[8189],{43150:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"databases/database-systems/trie","title":"Trie and Radix Tree","description":"In the context of databases, Tries and Radix Trees are efficient data structures used for tasks like string matching, prefix searching, and indexing. These data structures provide fast operations, such as searching, insertion, and deletion, particularly in applications involving large datasets with string keys.","source":"@site/docs/databases/database-systems/trie.md","sourceDirName":"databases/database-systems","slug":"/databases/database-systems/trie","permalink":"/docs/databases/database-systems/trie","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-systems/trie.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1734957461000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Skip List","permalink":"/docs/databases/database-systems/skip-list"},"next":{"title":"Inverted Indexes","permalink":"/docs/databases/database-systems/inverted-index"}}');var r=s(74848),t=s(28453);const d={sidebar_position:9},c="Trie and Radix Tree",l={},a=[{value:"Trie",id:"trie",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity",level:3},{value:"Insertion Process in Trie (Example)",id:"insertion-process-in-trie-example",level:3},{value:"Deletion Process in Trie",id:"deletion-process-in-trie",level:3},{value:"Search Process in Trie",id:"search-process-in-trie",level:3},{value:"Radix Tree (Compressed Trie)",id:"radix-tree-compressed-trie",level:2},{value:"Time and Space Complexity",id:"time-and-space-complexity-1",level:3},{value:"Insertion Process in Radix Tree (Example)",id:"insertion-process-in-radix-tree-example",level:3},{value:"Deletion Process in Radix Tree",id:"deletion-process-in-radix-tree",level:3},{value:"Search Process in Radix Tree",id:"search-process-in-radix-tree",level:3},{value:"Comparison Between Trie and Radix Tree in Database Context",id:"comparison-between-trie-and-radix-tree-in-database-context",level:2},{value:"Real-World Examples in Databases",id:"real-world-examples-in-databases",level:2},{value:"Full-Text Search Engines",id:"full-text-search-engines",level:3},{value:"Autocomplete and Spell Checking",id:"autocomplete-and-spell-checking",level:3},{value:"IP Routing",id:"ip-routing",level:3},{value:"Database Indexing",id:"database-indexing",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"trie-and-radix-tree",children:"Trie and Radix Tree"})}),"\n",(0,r.jsxs)(n.p,{children:["In the context of ",(0,r.jsx)(n.strong,{children:"databases"}),", ",(0,r.jsx)(n.strong,{children:"Tries"})," and ",(0,r.jsx)(n.strong,{children:"Radix Trees"})," are efficient data structures used for tasks like ",(0,r.jsx)(n.strong,{children:"string matching"}),", ",(0,r.jsx)(n.strong,{children:"prefix searching"}),", and ",(0,r.jsx)(n.strong,{children:"indexing"}),". These data structures provide fast operations, such as ",(0,r.jsx)(n.strong,{children:"searching"}),", ",(0,r.jsx)(n.strong,{children:"insertion"}),", and ",(0,r.jsx)(n.strong,{children:"deletion"}),", particularly in applications involving large datasets with string keys."]}),"\n",(0,r.jsx)("img",{src:"/img/trie.gif",alt:"LSM Tree",style:{width:"100%"}}),"\n",(0,r.jsx)(n.h2,{id:"trie",children:"Trie"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Trie"})," is a tree-like data structure where each node represents a character of a string, and each path from the root to a leaf node represents a string. It is primarily used for efficient retrieval of strings and prefix-based searches in applications like ",(0,r.jsx)(n.strong,{children:"autocomplete"}),", ",(0,r.jsx)(n.strong,{children:"dictionary lookups"}),", and ",(0,r.jsx)(n.strong,{children:"indexing"})," in databases."]}),"\n",(0,r.jsx)(n.h3,{id:"time-and-space-complexity",children:"Time and Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search"}),": O(m), where ",(0,r.jsx)(n.code,{children:"m"})," is the length of the string."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Insertion"}),": O(m), where ",(0,r.jsx)(n.code,{children:"m"})," is the length of the string."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deletion"}),": O(m), where ",(0,r.jsx)(n.code,{children:"m"})," is the length of the string."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N * m), where ",(0,r.jsx)(n.code,{children:"N"})," is the number of strings and ",(0,r.jsx)(n.code,{children:"m"})," is the average length of the strings. A Trie can be space-inefficient due to storing each character in a node."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"insertion-process-in-trie-example",children:"Insertion Process in Trie (Example)"}),"\n",(0,r.jsxs)(n.p,{children:["Let's insert the strings ",(0,r.jsx)(n.code,{children:'"cat"'}),", ",(0,r.jsx)(n.code,{children:'"car"'}),", and ",(0,r.jsx)(n.code,{children:'"dog"'})," into the Trie."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Insert ",(0,r.jsx)(n.code,{children:'"cat"'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Starting from the root, we insert the characters ",(0,r.jsx)(n.code,{children:"'c'"}),", ",(0,r.jsx)(n.code,{children:"'a'"}),", and ",(0,r.jsx)(n.code,{children:"'t'"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["The node for ",(0,r.jsx)(n.code,{children:"'t'"})," is marked as the end of the word."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                    /\n                   c\n                  /\n                 a\n                /\n               t [End]\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Insert ",(0,r.jsx)(n.code,{children:'"car"'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Starting from the root, ",(0,r.jsx)(n.code,{children:"'c'"})," and ",(0,r.jsx)(n.code,{children:"'a'"})," already exist."]}),"\n",(0,r.jsxs)(n.li,{children:["We insert ",(0,r.jsx)(n.code,{children:"'r'"})," and mark it as the end of the word."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                    /\n                   c\n                  /\n                 a\n                / \\\n               t   r [End]\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Insert ",(0,r.jsx)(n.code,{children:'"dog"'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The path for ",(0,r.jsx)(n.code,{children:'"dog"'})," does not exist, so we insert ",(0,r.jsx)(n.code,{children:"'d'"}),", ",(0,r.jsx)(n.code,{children:"'o'"}),", and ",(0,r.jsx)(n.code,{children:"'g'"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                       Root\n                   /          \\\n                  c            d\n                 /            /\n                a            o\n               / \\          /\n        [End] t   r [End]  g [End]\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"deletion-process-in-trie",children:"Deletion Process in Trie"}),"\n",(0,r.jsx)(n.p,{children:"To delete a string, we follow the path of characters and remove nodes when no other string shares that path."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Delete ",(0,r.jsx)(n.code,{children:'"car"'}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Start at the root and follow the path ",(0,r.jsx)(n.code,{children:"'c' -> 'a' -> 'r'"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Remove the node for ",(0,r.jsx)(n.code,{children:"'r'"})," since it is no longer needed."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                    /\n                   c\n                  /\n                 a\n                /\n               t [End]\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"search-process-in-trie",children:"Search Process in Trie"}),"\n",(0,r.jsx)(n.p,{children:"To search for a string, we traverse the Trie following the characters of the string."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Search for ",(0,r.jsx)(n.code,{children:'"cat"'}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Start at the root and follow the path ",(0,r.jsx)(n.code,{children:"'c' -> 'a' -> 't'"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Since ",(0,r.jsx)(n.code,{children:"'t'"})," is marked as the end of the word, the string is found."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"radix-tree-compressed-trie",children:"Radix Tree (Compressed Trie)"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Radix Tree"})," is a space-optimized version of a Trie. It compresses nodes that have a single child into a single node containing the combined string. This reduces the depth of the tree and the number of nodes, making Radix Trees more space-efficient while maintaining fast lookup times."]}),"\n",(0,r.jsx)(n.h3,{id:"time-and-space-complexity-1",children:"Time and Space Complexity"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Search"}),": O(m), where ",(0,r.jsx)(n.code,{children:"m"})," is the length of the string."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Insertion"}),": O(m), where ",(0,r.jsx)(n.code,{children:"m"})," is the length of the string."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deletion"}),": O(m), where ",(0,r.jsx)(n.code,{children:"m"})," is the length of the string."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N * k), where ",(0,r.jsx)(n.code,{children:"N"})," is the number of strings and ",(0,r.jsx)(n.code,{children:"k"})," is the average length of the string segments stored in nodes."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"insertion-process-in-radix-tree-example",children:"Insertion Process in Radix Tree (Example)"}),"\n",(0,r.jsxs)(n.p,{children:["Let's insert the strings ",(0,r.jsx)(n.code,{children:'"cat"'}),", ",(0,r.jsx)(n.code,{children:'"car"'}),", and ",(0,r.jsx)(n.code,{children:'"dog"'})," into the Radix Tree."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Insert ",(0,r.jsx)(n.code,{children:'"cat"'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Starting from the root, we insert the string ",(0,r.jsx)(n.code,{children:'"cat"'})," as a single node."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                     |\n                    cat [End]\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Insert ",(0,r.jsx)(n.code,{children:'"car"'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"cat"'})," and ",(0,r.jsx)(n.code,{children:'"car"'})," share the common prefix ",(0,r.jsx)(n.code,{children:'"ca"'}),", so we split the node for ",(0,r.jsx)(n.code,{children:'"ca"'})," into two branches: one for ",(0,r.jsx)(n.code,{children:"'t'"})," and one for ",(0,r.jsx)(n.code,{children:"'r'"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                     |\n                    ca\n                   /  \\\n                  t    r [End]\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:["Insert ",(0,r.jsx)(n.code,{children:'"dog"'}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:'"dog"'})," shares no common prefix with ",(0,r.jsx)(n.code,{children:'"cat"'})," or ",(0,r.jsx)(n.code,{children:'"car"'}),", so we insert it as a separate node."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                     |\n                    ca\n                   /  \\\n                  t    r [End]\n                       |\n                     dog [End]\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"deletion-process-in-radix-tree",children:"Deletion Process in Radix Tree"}),"\n",(0,r.jsx)(n.p,{children:"To delete a string in a Radix Tree, we follow the path and remove the node when necessary, merging nodes if they become redundant."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Delete ",(0,r.jsx)(n.code,{children:'"car"'}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Start at the root and follow the path ",(0,r.jsx)(n.code,{children:"'ca' -> 'r'"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Since ",(0,r.jsx)(n.code,{children:"'r'"})," is no longer needed, we remove it and merge the branches."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"                    Root\n                     |\n                    ca\n                     |\n                    t [End]\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"search-process-in-radix-tree",children:"Search Process in Radix Tree"}),"\n",(0,r.jsx)(n.p,{children:"To search for a string, we traverse the Radix Tree following the combined string nodes."}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["Search for ",(0,r.jsx)(n.code,{children:'"cat"'}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Start at the root and follow the node ",(0,r.jsx)(n.code,{children:'"cat"'}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Since ",(0,r.jsx)(n.code,{children:'"cat"'})," is marked as the end of the word, the string is found."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"comparison-between-trie-and-radix-tree-in-database-context",children:"Comparison Between Trie and Radix Tree in Database Context"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Feature"}),(0,r.jsx)(n.th,{children:"Trie"}),(0,r.jsx)(n.th,{children:"Radix Tree"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Compression"})}),(0,r.jsx)(n.td,{children:"No compression; each character in a separate node"}),(0,r.jsx)(n.td,{children:"Compression of single-child nodes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Time Complexity"})}),(0,r.jsx)(n.td,{children:"O(m) for search, insert, delete (m = length of string)"}),(0,r.jsx)(n.td,{children:"O(m) for search, insert, delete (m = length of string)"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Space Complexity"})}),(0,r.jsxs)(n.td,{children:["O(N * m), where ",(0,r.jsx)(n.code,{children:"N"})," is the number of strings and ",(0,r.jsx)(n.code,{children:"m"})," is the average string length"]}),(0,r.jsxs)(n.td,{children:["O(N * k), where ",(0,r.jsx)(n.code,{children:"k"})," is the average length of compressed string segments"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Search Speed"})}),(0,r.jsx)(n.td,{children:"Fast due to prefix-based structure"}),(0,r.jsx)(n.td,{children:"Fast due to prefix-based structure and compression"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Use Cases"})}),(0,r.jsx)(n.td,{children:"Ideal for autocomplete, dictionary search, indexing"}),(0,r.jsx)(n.td,{children:"Ideal for large datasets with common prefixes, efficient indexing"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples-in-databases",children:"Real-World Examples in Databases"}),"\n",(0,r.jsx)(n.h3,{id:"full-text-search-engines",children:"Full-Text Search Engines"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trie"}),": Tries are commonly used in full-text search engines such as ",(0,r.jsx)(n.strong,{children:"Elasticsearch"}),", where they help efficiently store and search text data based on prefixes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Radix Tree"}),": Radix Trees are often used in databases for ",(0,r.jsx)(n.strong,{children:"prefix-based indexing"}),", where they help store large amounts of text with common prefixes in a space-efficient manner."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"autocomplete-and-spell-checking",children:"Autocomplete and Spell Checking"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trie"}),": Applications like ",(0,r.jsx)(n.strong,{children:"Google Search"}),", ",(0,r.jsx)(n.strong,{children:"Wikipedia"}),", or ",(0,r.jsx)(n.strong,{children:"Spell Checkers"})," use Tries for real-time suggestions and fast prefix-based searches."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Radix Tree"}),": For larger datasets with many common prefixes, ",(0,r.jsx)(n.strong,{children:"Radix Trees"})," are used to reduce space consumption and optimize performance."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ip-routing",children:"IP Routing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trie"}),": In ",(0,r.jsx)(n.strong,{children:"IP routing"}),", Tries are used to store routing tables where the longest matching prefix determines the routing path for packets."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Radix Tree"}),": ",(0,r.jsx)(n.strong,{children:"Radix Trees"})," are commonly used in routers to store IP addresses with common prefixes efficiently, optimizing storage and lookup times."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"database-indexing",children:"Database Indexing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Trie"}),": Tries are used in ",(0,r.jsx)(n.strong,{children:"indexing systems"})," to enable fast lookups of string keys and prefix searches."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Radix Tree"}),": ",(0,r.jsx)(n.strong,{children:"Radix Trees"})," are often used in databases like ",(0,r.jsx)(n.strong,{children:"LevelDB"})," or ",(0,r.jsx)(n.strong,{children:"Berkeley DB"})," for indexing and optimizing lookup times in situations where strings share prefixes."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>d,x:()=>c});var i=s(96540);const r={},t=i.createContext(r);function d(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);