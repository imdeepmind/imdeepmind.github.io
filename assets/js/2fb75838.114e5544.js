"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[820],{39366:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"programming-languages/javascript/prototype-inheritance","title":"Prototypes and Inheritance","description":"Prototypes","source":"@site/docs/programming-languages/javascript/prototype-inheritance.md","sourceDirName":"programming-languages/javascript","slug":"/programming-languages/javascript/prototype-inheritance","permalink":"/docs/programming-languages/javascript/prototype-inheritance","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming-languages/javascript/prototype-inheritance.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735588931000,"sidebarPosition":15,"frontMatter":{"sidebar_position":15},"sidebar":"tutorialSidebar","previous":{"title":"Currying and IIFE","permalink":"/docs/programming-languages/javascript/currying-iife"},"next":{"title":"Object-Oriented Programming (OOPs)","permalink":"/docs/programming-languages/javascript/oop"}}');var r=t(74848),s=t(28453);const i={sidebar_position:15},a="Prototypes and Inheritance",c={},l=[{value:"Prototypes",id:"prototypes",level:2},{value:"Prototypal Inheritance",id:"prototypal-inheritance",level:2},{value:"Prototype Chain",id:"prototype-chain",level:2},{value:"Factory Functions",id:"factory-functions",level:2},{value:"<code>new</code> Keyword",id:"new-keyword",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"prototypes-and-inheritance",children:"Prototypes and Inheritance"})}),"\n",(0,r.jsx)(n.h2,{id:"prototypes",children:"Prototypes"}),"\n",(0,r.jsxs)(n.p,{children:["In JavaScript, ",(0,r.jsx)(n.strong,{children:"prototypes"})," are a fundamental mechanism for object inheritance. Every object has a prototype, which is another object that it inherits properties and methods from. When you try to access a property or method on an object, JavaScript first checks if the property exists on the object itself. If not, it looks up the prototype chain (more on this below)."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Prototype of an object:"})," Every object has an internal property ",(0,r.jsx)(n.code,{children:"[[Prototype]]"})," (accessed via ",(0,r.jsx)(n.code,{children:"__proto__"})," or ",(0,r.jsx)(n.code,{children:"Object.getPrototypeOf()"}),"), which points to another object."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Constructor functions and prototypes:"})," Functions in JavaScript automatically have a ",(0,r.jsx)(n.code,{children:"prototype"})," property, which is an object. This object contains properties and methods that are shared by all instances created by that constructor function."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.sayHello = function () {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst person1 = new Person("Alice", 30);\nperson1.sayHello(); // Outputs: Hello, my name is Alice\n'})}),"\n",(0,r.jsx)(n.h2,{id:"prototypal-inheritance",children:"Prototypal Inheritance"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Prototypal inheritance"})," refers to the way objects can inherit properties and methods from other objects through the prototype chain. When a property or method is accessed on an object, JavaScript first checks if it's defined on the object itself. If not, it checks the prototype of that object, and so on up the prototype chain."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const animal = {\n  eat: function () {\n    console.log("Eating...");\n  },\n};\n\nconst dog = Object.create(animal);\ndog.bark = function () {\n  console.log("Woof!");\n};\n\ndog.eat(); // Inherited from animal, Outputs: Eating...\ndog.bark(); // Outputs: Woof!\n'})}),"\n",(0,r.jsx)(n.h2,{id:"prototype-chain",children:"Prototype Chain"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"prototype chain"})," is a series of links between an object and its prototype. Every object in JavaScript is linked to another object via its prototype, and this chain can continue indefinitely, although in most cases it ends with ",(0,r.jsx)(n.code,{children:"Object.prototype"}),"."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"Object.prototype"})," is the root of all JavaScript objects, and it does not have a prototype."]}),"\n",(0,r.jsxs)(n.li,{children:["If a property or method is not found in an object's prototype, the search continues up the chain until ",(0,r.jsx)(n.code,{children:"Object.prototype"})," is reached."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'const obj = { name: "John" };\nconsole.log(obj.toString()); // toString is inherited from Object.prototype\n'})}),"\n",(0,r.jsx)(n.h2,{id:"factory-functions",children:"Factory Functions"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"factory function"})," is a function that creates and returns an object. This pattern allows you to create multiple objects with the same properties and methods without using the ",(0,r.jsx)(n.code,{children:"new"})," keyword or constructor functions."]}),"\n",(0,r.jsx)(n.p,{children:"Factory functions can be used to simulate classical inheritance by setting up prototype chains manually."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function createPerson(name, age) {\n  return {\n    name,\n    age,\n    sayHello() {\n      console.log(`Hello, my name is ${this.name}`);\n    },\n  };\n}\n\nconst person1 = createPerson("Alice", 30);\nperson1.sayHello(); // Outputs: Hello, my name is Alice\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"new-keyword",children:[(0,r.jsx)(n.code,{children:"new"})," Keyword"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"new"})," keyword"]})," is used to create instances of a constructor function. When you use ",(0,r.jsx)(n.code,{children:"new"}),", it does the following:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Creates a new empty object."}),"\n",(0,r.jsxs)(n.li,{children:["Sets the prototype of the new object to the constructor function\u2019s ",(0,r.jsx)(n.code,{children:"prototype"})," property."]}),"\n",(0,r.jsxs)(n.li,{children:["Binds ",(0,r.jsx)(n.code,{children:"this"})," inside the constructor function to the new object."]}),"\n",(0,r.jsx)(n.li,{children:"Returns the new object (unless the constructor explicitly returns something else)."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:'function Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nconst person1 = new Person("Alice", 30);\nconsole.log(person1.name); // Alice\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(96540);const r={},s=o.createContext(r);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);