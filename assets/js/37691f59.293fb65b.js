"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[5749],{19549:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"programming-languages/javascript/event-loop","title":"Event Loop","description":"The Event Loop is one of the most critical components of JavaScript\'s concurrency model, enabling the language to handle asynchronous tasks while maintaining its single-threaded nature. It is a mechanism that orchestrates the execution of tasks, ensuring that code runs in a non-blocking and seamless manner.","source":"@site/docs/programming-languages/javascript/event-loop.md","sourceDirName":"programming-languages/javascript","slug":"/programming-languages/javascript/event-loop","permalink":"/docs/programming-languages/javascript/event-loop","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming-languages/javascript/event-loop.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735588931000,"sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Microtask Queue, Macrotask Queue, and Rendering Queue","permalink":"/docs/programming-languages/javascript/queues"},"next":{"title":"Closures and Lexical Scoping","permalink":"/docs/programming-languages/javascript/closures"}}');var t=s(74848),r=s(28453);const o={sidebar_position:11},l="Event Loop",c={},a=[{value:"What is the Event Loop?",id:"what-is-the-event-loop",level:2},{value:"Key Features of the Event Loop",id:"key-features-of-the-event-loop",level:2},{value:"Single-Threaded Nature",id:"single-threaded-nature",level:3},{value:"Asynchronous Handling",id:"asynchronous-handling",level:3},{value:"Non-blocking Behavior",id:"non-blocking-behavior",level:3},{value:"Phases of the Event Loop",id:"phases-of-the-event-loop",level:2},{value:"Timers Phase",id:"timers-phase",level:3},{value:"Pending I/O Phase",id:"pending-io-phase",level:3},{value:"Idle, Prepare Phase",id:"idle-prepare-phase",level:3},{value:"Poll Phase",id:"poll-phase",level:3},{value:"Check Phase",id:"check-phase",level:3},{value:"Close Callbacks Phase",id:"close-callbacks-phase",level:3},{value:"Event Loop&#39;s Interaction with JavaScript Tasks",id:"event-loops-interaction-with-javascript-tasks",level:2},{value:"Steps in the Event Loop",id:"steps-in-the-event-loop",level:2},{value:"Example of Event Loop in Action",id:"example-of-event-loop-in-action",level:2},{value:"Execution Flow Explained",id:"execution-flow-explained",level:3},{value:"Synchronous Code",id:"synchronous-code",level:4},{value:"Promises (Microtasks)",id:"promises-microtasks",level:4},{value:"Timers (<code>setTimeout</code>)",id:"timers-settimeout",level:4},{value:"<code>setImmediate</code>",id:"setimmediate",level:4},{value:"File Operations (<code>fs.readFile</code>)",id:"file-operations-fsreadfile",level:4},{value:"Fetch API",id:"fetch-api",level:4},{value:"Execution Flow Breakdown",id:"execution-flow-breakdown",level:3},{value:"Final Output",id:"final-output",level:3},{value:"Common Pitfalls and Considerations",id:"common-pitfalls-and-considerations",level:2},{value:"Optimizing the Event Loop",id:"optimizing-the-event-loop",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"event-loop",children:"Event Loop"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"Event Loop"})," is one of the most critical components of JavaScript's concurrency model, enabling the language to handle asynchronous tasks while maintaining its single-threaded nature. It is a mechanism that orchestrates the execution of tasks, ensuring that code runs in a non-blocking and seamless manner."]}),"\n",(0,t.jsx)(n.h2,{id:"what-is-the-event-loop",children:"What is the Event Loop?"}),"\n",(0,t.jsxs)(n.p,{children:["The Event Loop is a continuous process that monitors and manages the execution of tasks in JavaScript. It works by constantly checking if the ",(0,t.jsx)(n.strong,{children:"Call Stack"})," is empty and whether there are tasks in the ",(0,t.jsx)(n.strong,{children:"queues"})," (Microtask Queue, Macrotask Queue, or Rendering Queue) that need to be executed. By iterating through these steps, the Event Loop ensures that JavaScript applications remain responsive and perform efficiently."]}),"\n",(0,t.jsx)(n.p,{children:"In simple terms, the Event Loop:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Executes the code in the main thread."}),"\n",(0,t.jsx)(n.li,{children:"Handles asynchronous tasks by offloading them to queues."}),"\n",(0,t.jsx)(n.li,{children:"Ensures the right order of execution for scheduled tasks and rendering updates."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-features-of-the-event-loop",children:"Key Features of the Event Loop"}),"\n",(0,t.jsx)(n.h3,{id:"single-threaded-nature",children:"Single-Threaded Nature"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"JavaScript operates in a single-threaded environment, meaning there is only one thread available to execute code."}),"\n",(0,t.jsx)(n.li,{children:"The Event Loop is crucial for managing multiple asynchronous operations, such as timers, network requests, and UI rendering, in this single-threaded context."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"asynchronous-handling",children:"Asynchronous Handling"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Event Loop allows JavaScript to handle asynchronous tasks efficiently without blocking the main thread."}),"\n",(0,t.jsx)(n.li,{children:"Tasks like fetching data from a server or processing large files can be offloaded, and their results are handled later when the main thread is free."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"non-blocking-behavior",children:"Non-blocking Behavior"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"JavaScript achieves non-blocking behavior using the Event Loop, allowing long-running operations to proceed without freezing the browser or halting other tasks."}),"\n",(0,t.jsx)(n.li,{children:"This is particularly important for web applications, where responsiveness is key."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"phases-of-the-event-loop",children:"Phases of the Event Loop"}),"\n",(0,t.jsx)(n.p,{children:"The Event Loop operates in phases, with each phase responsible for specific types of tasks. These phases are processed in a continuous cycle, enabling JavaScript to execute tasks in an organized manner."}),"\n",(0,t.jsx)(n.h3,{id:"timers-phase",children:"Timers Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Executes callbacks from ",(0,t.jsx)(n.code,{children:"setTimeout()"})," and ",(0,t.jsx)(n.code,{children:"setInterval()"})," whose delay has elapsed."]}),"\n",(0,t.jsx)(n.li,{children:"Timers are processed in the order they were scheduled, but their actual execution depends on when the Event Loop reaches this phase and the state of the Call Stack."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"pending-io-phase",children:"Pending I/O Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Handles I/O callbacks, such as those triggered by file system or network operations, that were not handled in the previous iteration of the loop."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"idle-prepare-phase",children:"Idle, Prepare Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Used internally by the system and typically not relevant for application-level code."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"poll-phase",children:"Poll Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Retrieves and processes events from the Event Queue. Examples include incoming network data or user interactions like clicks."}),"\n",(0,t.jsx)(n.li,{children:"If there are no events to process, the Event Loop may block here to wait for new events or move to the Check Phase if timers are ready."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"check-phase",children:"Check Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Executes callbacks from ",(0,t.jsx)(n.code,{children:"setImmediate()"})," (Node.js-specific)."]}),"\n",(0,t.jsxs)(n.li,{children:["This phase is similar to the Timers Phase but specifically prioritizes ",(0,t.jsx)(n.code,{children:"setImmediate()"})," callbacks."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"close-callbacks-phase",children:"Close Callbacks Phase"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Executes cleanup callbacks for closed resources, such as ",(0,t.jsx)(n.code,{children:"close"})," events from network sockets."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"event-loops-interaction-with-javascript-tasks",children:"Event Loop's Interaction with JavaScript Tasks"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Synchronous Code:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Runs to completion before the Event Loop moves to any other tasks."}),"\n",(0,t.jsx)(n.li,{children:"Executed directly on the Call Stack."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Asynchronous Code:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Scheduled tasks are placed in their respective queues (e.g., Microtask Queue or Macrotask Queue) and executed later."}),"\n",(0,t.jsx)(n.li,{children:"The Event Loop ensures these tasks are executed in the right order and at the right time."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Rendering Updates:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Event Loop coordinates with the browser's rendering engine to update the UI after completing tasks."}),"\n",(0,t.jsx)(n.li,{children:"Tasks like layout recalculation and paint are handled during the rendering phase of the Event Loop."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"steps-in-the-event-loop",children:"Steps in the Event Loop"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Check Call Stack:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Event Loop first checks if the Call Stack is empty. If not, it continues executing the tasks on the stack."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Process Microtasks:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the Call Stack is empty, the Event Loop processes all tasks in the Microtask Queue."}),"\n",(0,t.jsx)(n.li,{children:"This ensures that high-priority tasks like promises are resolved before moving to other tasks."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Handle Macrotasks:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"After processing microtasks, the Event Loop executes one macrotask from the Macrotask Queue."}),"\n",(0,t.jsxs)(n.li,{children:["Tasks like timers (",(0,t.jsx)(n.code,{children:"setTimeout"}),"), I/O events, and user interactions fall under this category."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Update Rendering (if applicable):"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If there are pending DOM or CSS changes, the browser's rendering engine recalculates layouts, repaints the UI, and composites layers before the next iteration of the Event Loop."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Repeat the Cycle:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The Event Loop continuously repeats these steps to handle tasks and keep the application running smoothly."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-of-event-loop-in-action",children:"Example of Event Loop in Action"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const fs = require("fs");\n\nconsole.log("Start"); // Synchronous: Executes immediately\n\nsetTimeout(() => {\n  console.log("Macrotask: setTimeout");\n}, 0); // Macrotask: Scheduled in the Macrotask Queue\n\nsetImmediate(() => {\n  console.log("Macrotask: setImmediate");\n}); // Macrotask: Scheduled in the Macrotask Queue\n\nPromise.resolve()\n  .then(() => {\n    console.log("Microtask: Promise 1");\n  })\n  .then(() => {\n    console.log("Microtask: Promise 2");\n  }); // Microtasks: Chained promises, added to Microtask Queue\n\nfs.readFile(__filename, "utf8", (err, data) => {\n  if (err) {\n    console.error(err);\n    return;\n  }\n  console.log("Macrotask: File Read Complete");\n}); // Macrotask: Scheduled in the Macrotask Queue\n\nfetch("https://jsonplaceholder.typicode.com/posts/1") // Asynchronous fetch\n  .then((response) => response.json())\n  .then((data) => {\n    console.log("Microtask: Fetch Response Processed");\n  })\n  .catch((err) => {\n    console.error("Microtask: Fetch Error", err);\n  });\n\nconsole.log("End"); // Synchronous: Executes immediately\n'})}),"\n",(0,t.jsx)(n.h3,{id:"execution-flow-explained",children:"Execution Flow Explained"}),"\n",(0,t.jsxs)(n.p,{children:["The code involves synchronous tasks, promises, timers (",(0,t.jsx)(n.code,{children:"setTimeout"}),"), ",(0,t.jsx)(n.code,{children:"setImmediate"}),", file operations (",(0,t.jsx)(n.code,{children:"fs.readFile"}),"), and a network request (",(0,t.jsx)(n.code,{children:"fetch"}),"). The execution flow of this program will be as follows:"]}),"\n",(0,t.jsx)(n.h4,{id:"synchronous-code",children:"Synchronous Code"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The synchronous code is executed first, as it is added directly to the ",(0,t.jsx)(n.strong,{children:"Call Stack"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Output:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Start\nEnd\n"})}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"promises-microtasks",children:"Promises (Microtasks)"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Promises are resolved and their ",(0,t.jsx)(n.code,{children:".then()"})," callbacks are placed in the ",(0,t.jsx)(n.strong,{children:"Microtask Queue"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Microtasks are executed immediately after the current Call Stack is cleared but before any macrotasks."}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"timers-settimeout",children:["Timers (",(0,t.jsx)(n.code,{children:"setTimeout"}),")"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"setTimeout"})," schedules its callback to the ",(0,t.jsx)(n.strong,{children:"Macrotask Queue"}),". It will be executed in the next iteration of the Event Loop, after all pending microtasks are completed."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"setimmediate",children:(0,t.jsx)(n.code,{children:"setImmediate"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"setImmediate"})," callback is added to the ",(0,t.jsx)(n.strong,{children:"Macrotask Queue"})," but behaves differently from ",(0,t.jsx)(n.code,{children:"setTimeout"}),". In Node.js, ",(0,t.jsx)(n.code,{children:"setImmediate"})," is prioritized after I/O events and runs before ",(0,t.jsx)(n.code,{children:"setTimeout"})," in most cases."]}),"\n"]}),"\n",(0,t.jsxs)(n.h4,{id:"file-operations-fsreadfile",children:["File Operations (",(0,t.jsx)(n.code,{children:"fs.readFile"}),")"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"fs.readFile"})," callback is also added to the ",(0,t.jsx)(n.strong,{children:"Macrotask Queue"})," after the file read operation completes."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"fetch-api",children:"Fetch API"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"fetch"})," request executes asynchronously and its ",(0,t.jsx)(n.code,{children:".then()"})," callbacks are placed in the ",(0,t.jsx)(n.strong,{children:"Microtask Queue"})," once the response is received."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"execution-flow-breakdown",children:"Execution Flow Breakdown"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Step"}),(0,t.jsx)(n.th,{children:"Code Executed"}),(0,t.jsx)(n.th,{children:"Queue"}),(0,t.jsx)(n.th,{children:"Output"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"1"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"console.log('Start')"})}),(0,t.jsx)(n.td,{children:"Call Stack"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Start"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"2"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"setTimeout"})," callback scheduled"]}),(0,t.jsx)(n.td,{children:"Macrotask Queue"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"3"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"setImmediate"})," callback scheduled"]}),(0,t.jsx)(n.td,{children:"Macrotask Queue"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"4"}),(0,t.jsxs)(n.td,{children:["Promise resolved, ",(0,t.jsx)(n.code,{children:".then()"})," added"]}),(0,t.jsx)(n.td,{children:"Microtask Queue"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"5"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"fs.readFile"})," callback scheduled"]}),(0,t.jsx)(n.td,{children:"Macrotask Queue"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"6"}),(0,t.jsx)(n.td,{children:"Fetch request sent"}),(0,t.jsx)(n.td,{children:"Microtask Queue"}),(0,t.jsx)(n.td,{})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"7"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"console.log('End')"})}),(0,t.jsx)(n.td,{children:"Call Stack"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"End"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"8"}),(0,t.jsx)(n.td,{children:"Microtask: Promise 1"}),(0,t.jsx)(n.td,{children:"Microtask Queue"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Microtask: Promise 1"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"9"}),(0,t.jsx)(n.td,{children:"Microtask: Promise 2"}),(0,t.jsx)(n.td,{children:"Microtask Queue"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Microtask: Promise 2"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"10"}),(0,t.jsx)(n.td,{children:"Fetch response processed"}),(0,t.jsx)(n.td,{children:"Microtask Queue"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Microtask: Fetch Response"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"11"}),(0,t.jsxs)(n.td,{children:["Macrotask: ",(0,t.jsx)(n.code,{children:"setImmediate"})," callback"]}),(0,t.jsx)(n.td,{children:"Macrotask Queue"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Macrotask: setImmediate"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"12"}),(0,t.jsxs)(n.td,{children:["Macrotask: ",(0,t.jsx)(n.code,{children:"setTimeout"})," callback"]}),(0,t.jsx)(n.td,{children:"Macrotask Queue"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Macrotask: setTimeout"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"13"}),(0,t.jsxs)(n.td,{children:["Macrotask: ",(0,t.jsx)(n.code,{children:"fs.readFile"})," callback"]}),(0,t.jsx)(n.td,{children:"Macrotask Queue"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"Macrotask: File Read Complete"})})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"final-output",children:"Final Output"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Start\nEnd\nMicrotask: Promise 1\nMicrotask: Promise 2\nMicrotask: Fetch Response Processed\nMacrotask: setImmediate\nMacrotask: setTimeout\nMacrotask: File Read Complete\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls-and-considerations",children:"Common Pitfalls and Considerations"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Starvation of Macrotasks:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"If the Microtask Queue keeps growing (e.g., through recursive promises), macrotasks and rendering tasks may be delayed, causing the application to appear unresponsive."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Blocking the Event Loop:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Long-running synchronous code can block the Event Loop, preventing it from processing other tasks and rendering updates. This can lead to UI jank."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"UI Responsiveness:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["To ensure smooth user experiences, avoid excessive computations in the main thread. Use techniques like ",(0,t.jsx)(n.strong,{children:"web workers"})," for offloading heavy computations."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Task Prioritization:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Microtasks are always executed before macrotasks. Developers must understand this priority to avoid unexpected execution orders, especially when dealing with promises and timers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"optimizing-the-event-loop",children:"Optimizing the Event Loop"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Batch DOM Updates:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Combine multiple DOM changes into a single update to minimize rendering overhead and prevent the Event Loop from being overwhelmed with rendering tasks."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.strong,{children:["Use ",(0,t.jsx)(n.code,{children:"requestAnimationFrame"}),":"]})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For animations, use ",(0,t.jsx)(n.code,{children:"requestAnimationFrame()"})," to align updates with the browser's rendering cycle, ensuring smooth animations."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Avoid Long-Running Synchronous Code:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Break large tasks into smaller chunks using techniques like ",(0,t.jsx)(n.strong,{children:"setTimeout"})," or ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"setImmediate()"})})," to prevent blocking the Event Loop."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Efficient Asynchronous Design:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use promises and async/await effectively to avoid nesting callbacks and creating unmanageable microtasks."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);