"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[1337],{72328:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"frameworks-libraries/frontend/react/hooks","title":"React Hooks","description":"React introduced hooks in version 16.8 to allow developers to use state and other React features in functional components, which were previously only available in class components. Hooks make it possible to write components that are concise, easy to read, and maintain while providing more powerful capabilities.","source":"@site/docs/frameworks-libraries/frontend/react/hooks.md","sourceDirName":"frameworks-libraries/frontend/react","slug":"/frameworks-libraries/frontend/react/hooks","permalink":"/docs/frameworks-libraries/frontend/react/hooks","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/frameworks-libraries/frontend/react/hooks.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1749212834000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"State Management","permalink":"/docs/frameworks-libraries/frontend/react/state-management"},"next":{"title":"Refs","permalink":"/docs/frameworks-libraries/frontend/react/refs"}}');var o=t(74848),a=t(28453);const i={sidebar_position:7},c="React Hooks",r={},l=[{value:"<code>useState</code> \u2013 Managing State in Functional Components",id:"usestate--managing-state-in-functional-components",level:2},{value:"Syntax:",id:"syntax",level:3},{value:"Example:",id:"example",level:3},{value:"Important Notes:",id:"important-notes",level:3},{value:"<code>useEffect</code> \u2013 Managing Side Effects",id:"useeffect--managing-side-effects",level:2},{value:"Syntax:",id:"syntax-1",level:3},{value:"Example:",id:"example-1",level:3},{value:"Important Notes:",id:"important-notes-1",level:3},{value:"<code>useContext</code> \u2013 Managing Global State Across Components",id:"usecontext--managing-global-state-across-components",level:2},{value:"Syntax:",id:"syntax-2",level:3},{value:"Example:",id:"example-2",level:3},{value:"Important Notes:",id:"important-notes-2",level:3},{value:"<code>useReducer</code> \u2013 Complex State Management",id:"usereducer--complex-state-management",level:2},{value:"Syntax:",id:"syntax-3",level:3},{value:"Example:",id:"example-3",level:3},{value:"Important Notes:",id:"important-notes-3",level:3},{value:"<code>useMemo</code> and <code>useCallback</code> \u2013 Performance Optimization",id:"usememo-and-usecallback--performance-optimization",level:2},{value:"<code>useMemo</code>: Memoize Values",id:"usememo-memoize-values",level:3},{value:"Syntax:",id:"syntax-4",level:3},{value:"Example:",id:"example-4",level:3},{value:"<code>useCallback</code>: Memoize Functions",id:"usecallback-memoize-functions",level:3},{value:"Syntax:",id:"syntax-5",level:3},{value:"Example:",id:"example-5",level:3},{value:"Custom Hooks \u2013 Reusable Logic",id:"custom-hooks--reusable-logic",level:2},{value:"Example:",id:"example-6",level:3},{value:"Important Notes:",id:"important-notes-4",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"react-hooks",children:"React Hooks"})}),"\n",(0,o.jsx)(n.p,{children:"React introduced hooks in version 16.8 to allow developers to use state and other React features in functional components, which were previously only available in class components. Hooks make it possible to write components that are concise, easy to read, and maintain while providing more powerful capabilities."}),"\n",(0,o.jsxs)(n.h2,{id:"usestate--managing-state-in-functional-components",children:[(0,o.jsx)(n.code,{children:"useState"})," \u2013 Managing State in Functional Components"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useState"})," hook allows you to add state to functional components. Before hooks, managing state was only possible in class components. ",(0,o.jsx)(n.code,{children:"useState"})," makes it easy to manage component state in functional components."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax",children:"Syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const [state, setState] = useState(initialState);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"state"}),": The current state value."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"setState"}),": A function that updates the state value. It triggers a re-render of the component when the state is updated."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"initialState"}),": The initial value for the state."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React, { useState } from "react";\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(count + 1);\n  };\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"In the above example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useState(0)"})," initializes the state with ",(0,o.jsx)(n.code,{children:"0"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"setCount"})," is used to update the state when the button is clicked."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"important-notes",children:"Important Notes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The state is preserved between re-renders."}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"setState"})," function is asynchronous and may batch updates for performance optimization."]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"useeffect--managing-side-effects",children:[(0,o.jsx)(n.code,{children:"useEffect"})," \u2013 Managing Side Effects"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useEffect"})," hook is used to perform side effects in functional components, such as fetching data, subscribing to external events, or manually modifying the DOM. It can be thought of as a combination of ",(0,o.jsx)(n.code,{children:"componentDidMount"}),", ",(0,o.jsx)(n.code,{children:"componentDidUpdate"}),", and ",(0,o.jsx)(n.code,{children:"componentWillUnmount"})," lifecycle methods in class components."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax-1",children:"Syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"useEffect(() => {\n  // Code to run when component mounts or state/props change\n}, [dependencies]);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.strong,{children:"callback function"})," inside ",(0,o.jsx)(n.code,{children:"useEffect"})," is run after the component renders."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dependencies"}),": The second argument is an array of dependencies. The effect runs only if the values in the dependency array change. If the array is empty, the effect runs only once (after the initial render)."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-1",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useEffect } from "react";\n\nfunction Timer() {\n  const [seconds, setSeconds] = useState(0);\n\n  useEffect(() => {\n    const intervalId = setInterval(() => {\n      setSeconds((prev) => prev + 1);\n    }, 1000);\n\n    // Cleanup function to clear interval when component unmounts or dependencies change\n    return () => clearInterval(intervalId);\n  }, []); // Empty dependency array ensures this effect runs only once (on mount)\n\n  return <div>Timer: {seconds}s</div>;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"In this example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useEffect"})," starts an interval that increments the ",(0,o.jsx)(n.code,{children:"seconds"})," state every second."]}),"\n",(0,o.jsx)(n.li,{children:"The cleanup function clears the interval when the component is unmounted or before running the effect again."}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"important-notes-1",children:"Important Notes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Cleanup"}),": If your effect subscribes to external services, uses timers, or sets up side effects, you should return a cleanup function to remove them before the component unmounts or before running the effect again."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Dependencies"}),": The effect is rerun when any value in the dependency array changes."]}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"usecontext--managing-global-state-across-components",children:[(0,o.jsx)(n.code,{children:"useContext"})," \u2013 Managing Global State Across Components"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useContext"})," hook allows you to access the value of a React context directly in a functional component. It is used to share values like themes, authentication status, or settings across many components without having to pass props down manually at each level."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax-2",children:"Syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const value = useContext(MyContext);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"MyContext"}),": A context object created using ",(0,o.jsx)(n.code,{children:"React.createContext()"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"value"}),": The current context value."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-2",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React, { createContext, useContext, useState } from "react";\n\nconst ThemeContext = createContext();\n\nfunction ThemeProvider({ children }) {\n  const [theme, setTheme] = useState("light");\n  const toggleTheme = () =>\n    setTheme((prevTheme) => (prevTheme === "light" ? "dark" : "light"));\n\n  return (\n    <ThemeContext.Provider value={{ theme, toggleTheme }}>\n      {children}\n    </ThemeContext.Provider>\n  );\n}\n\nfunction ThemedComponent() {\n  const { theme, toggleTheme } = useContext(ThemeContext);\n\n  return (\n    <div>\n      <p>Current theme: {theme}</p>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n    </div>\n  );\n}\n\nfunction App() {\n  return (\n    <ThemeProvider>\n      <ThemedComponent />\n    </ThemeProvider>\n  );\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"In the above example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"ThemeContext.Provider"})," provides the ",(0,o.jsx)(n.code,{children:"theme"})," and ",(0,o.jsx)(n.code,{children:"toggleTheme"})," values to the component tree."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useContext(ThemeContext)"})," is used in ",(0,o.jsx)(n.code,{children:"ThemedComponent"})," to access the ",(0,o.jsx)(n.code,{children:"theme"})," and ",(0,o.jsx)(n.code,{children:"toggleTheme"})," functions."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"important-notes-2",children:"Important Notes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useContext"})," will re-render the component whenever the context value changes."]}),"\n",(0,o.jsx)(n.li,{children:"Context is often used for global state like user authentication, themes, etc."}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"usereducer--complex-state-management",children:[(0,o.jsx)(n.code,{children:"useReducer"})," \u2013 Complex State Management"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"useReducer"})," hook is used to manage more complex state logic in functional components. It\u2019s particularly useful when dealing with complex state transitions, such as handling multiple actions or when the state depends on the previous state."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useReducer"})," is similar to ",(0,o.jsx)(n.code,{children:"useState"}),", but instead of just setting state directly, you dispatch actions to a reducer function, which returns a new state."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax-3",children:"Syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const [state, dispatch] = useReducer(reducer, initialState);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"reducer"}),": A function that determines how the state changes based on an action."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"initialState"}),": The initial state value."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"dispatch"}),": A function used to send actions to the reducer to update the state."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-3",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React, { useReducer } from "react";\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "increment":\n      return { count: state.count + 1 };\n    case "decrement":\n      return { count: state.count - 1 };\n    default:\n      return state;\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  return (\n    <div>\n      <p>Count: {state.count}</p>\n      <button onClick={() => dispatch({ type: "increment" })}>Increment</button>\n      <button onClick={() => dispatch({ type: "decrement" })}>Decrement</button>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"In this example:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"The reducer function handles state transitions based on the action type."}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.code,{children:"dispatch"})," function is used to send actions (",(0,o.jsx)(n.code,{children:"{ type: 'increment' }"})," or ",(0,o.jsx)(n.code,{children:"{ type: 'decrement' }"}),") to the reducer."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"important-notes-3",children:"Important Notes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"useReducer"})," is useful when state logic is complex or when there are multiple state updates that depend on each other."]}),"\n",(0,o.jsx)(n.li,{children:"It provides a more predictable and organized way to handle state, especially in larger applications."}),"\n"]}),"\n",(0,o.jsxs)(n.h2,{id:"usememo-and-usecallback--performance-optimization",children:[(0,o.jsx)(n.code,{children:"useMemo"})," and ",(0,o.jsx)(n.code,{children:"useCallback"})," \u2013 Performance Optimization"]}),"\n",(0,o.jsxs)(n.p,{children:["React provides ",(0,o.jsx)(n.code,{children:"useMemo"})," and ",(0,o.jsx)(n.code,{children:"useCallback"})," hooks to optimize performance by memoizing values and functions, ensuring that expensive calculations or functions are not re-executed unnecessarily."]}),"\n",(0,o.jsxs)(n.h3,{id:"usememo-memoize-values",children:[(0,o.jsx)(n.code,{children:"useMemo"}),": Memoize Values"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useMemo"})," returns a memoized value. It recomputes the value only when one of the dependencies has changed. This is useful for optimizing expensive calculations that should not run on every render."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax-4",children:"Syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n"})}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.strong,{children:"callback function"})," runs the expensive calculation."]}),"\n",(0,o.jsxs)(n.li,{children:["The ",(0,o.jsx)(n.strong,{children:"dependency array"})," determines when the memoized value should be recomputed."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"example-4",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React, { useMemo, useState } from "react";\n\nfunction ExpensiveComputation({ a, b }) {\n  const computedValue = useMemo(() => {\n    console.log("Computing...");\n    return a + b;\n  }, [a, b]);\n\n  return <p>Computed Value: {computedValue}</p>;\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, ",(0,o.jsx)(n.code,{children:"useMemo"})," ensures that the computation (",(0,o.jsx)(n.code,{children:"a + b"}),") is only re-run if either ",(0,o.jsx)(n.code,{children:"a"})," or ",(0,o.jsx)(n.code,{children:"b"})," changes."]}),"\n",(0,o.jsxs)(n.h3,{id:"usecallback-memoize-functions",children:[(0,o.jsx)(n.code,{children:"useCallback"}),": Memoize Functions"]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"useCallback"})," is similar to ",(0,o.jsx)(n.code,{children:"useMemo"}),", but instead of memoizing a value, it memoizes a function. It\u2019s particularly useful when passing functions as props to child components to prevent unnecessary re-renders."]}),"\n",(0,o.jsx)(n.h3,{id:"syntax-5",children:"Syntax:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:"const memoizedFunction = useCallback(() => {\n  /* function code */\n}, [dependencies]);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"example-5",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:'import React, { useCallback, useState } from "react";\n\nfunction Button({ onClick }) {\n  console.log("Button re-rendered");\n  return <button onClick={onClick}>Click me</button>;\n}\n\nfunction App() {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    setCount(count + 1);\n  }, [count]);\n\n  return (\n    <div>\n      <Button onClick={handleClick} />\n      <p>Count: {count}</p>\n    </div>\n  );\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, ",(0,o.jsx)(n.code,{children:"useCallback"})," ensures that the ",(0,o.jsx)(n.code,{children:"handleClick"})," function is not recreated on every render unless the ",(0,o.jsx)(n.code,{children:"count"})," value changes."]}),"\n",(0,o.jsx)(n.h2,{id:"custom-hooks--reusable-logic",children:"Custom Hooks \u2013 Reusable Logic"}),"\n",(0,o.jsx)(n.p,{children:"Custom hooks allow you to extract and reuse logic in different components. Custom hooks"}),"\n",(0,o.jsx)(n.p,{children:"are just JavaScript functions that call React hooks and can be shared across multiple components."}),"\n",(0,o.jsx)(n.h3,{id:"example-6",children:"Example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-javascript",children:'import { useState, useEffect } from "react";\n\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  const setValue = (value) => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error("Error setting local storage", error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["In this example, ",(0,o.jsx)(n.code,{children:"useLocalStorage"})," is a custom hook that manages state and synchronizes it with ",(0,o.jsx)(n.code,{children:"localStorage"}),". It can be used in any component that needs to store data in ",(0,o.jsx)(n.code,{children:"localStorage"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"important-notes-4",children:"Important Notes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["Custom hooks follow the same rules as React hooks (e.g., they must start with ",(0,o.jsx)(n.code,{children:"use"}),")."]}),"\n",(0,o.jsx)(n.li,{children:"They are great for sharing reusable logic without the need for higher-order components (HOCs) or render props."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var s=t(96540);const o={},a=s.createContext(o);function i(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);