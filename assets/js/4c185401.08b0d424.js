"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[6465],{86761:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"data-structure-and-algorithms/algorithms/tree/strict-vs-complete-binary-tree","title":"Strict vs Complete Binary Tree","description":"Strict Binary Tree","source":"@site/docs/data-structure-and-algorithms/algorithms/tree/strict-vs-complete-binary-tree.md","sourceDirName":"data-structure-and-algorithms/algorithms/tree","slug":"/data-structure-and-algorithms/algorithms/tree/strict-vs-complete-binary-tree","permalink":"/docs/data-structure-and-algorithms/algorithms/tree/strict-vs-complete-binary-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/data-structure-and-algorithms/algorithms/tree/strict-vs-complete-binary-tree.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1755185671000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Full vs Complete Binary Tree","permalink":"/docs/data-structure-and-algorithms/algorithms/tree/full-vs-complete-binary-tree"},"next":{"title":"Binary Tree Traversals","permalink":"/docs/data-structure-and-algorithms/algorithms/tree/tree-traversal"}}');var i=t(74848),l=t(28453);const s={sidebar_position:7},a="Strict vs Complete Binary Tree",d={},c=[{value:"Strict Binary Tree",id:"strict-binary-tree",level:2},{value:"Key Points",id:"key-points",level:3},{value:"Example (Strict Binary Tree)",id:"example-strict-binary-tree",level:3},{value:"Complete Binary Tree",id:"complete-binary-tree",level:2},{value:"Key Points",id:"key-points-1",level:3},{value:"Example (Complete Binary Tree)",id:"example-complete-binary-tree",level:3},{value:"Differences Between Strict and Complete Trees",id:"differences-between-strict-and-complete-trees",level:2},{value:"Python Representation Examples",id:"python-representation-examples",level:2},{value:"Strict Binary Tree Check",id:"strict-binary-tree-check",level:3},{value:"Complete Binary Tree Check",id:"complete-binary-tree-check",level:3}];function o(e){const r={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"strict-vs-complete-binary-tree",children:"Strict vs Complete Binary Tree"})}),"\n",(0,i.jsx)(r.h2,{id:"strict-binary-tree",children:"Strict Binary Tree"}),"\n",(0,i.jsxs)(r.p,{children:["A ",(0,i.jsx)(r.strong,{children:"Strict Tree"})," (also called a ",(0,i.jsx)(r.em,{children:"Proper Binary Tree"})," in the binary case) is a tree in which ",(0,i.jsx)(r.strong,{children:"every non-leaf node has exactly the same number of children"}),"."]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["For a ",(0,i.jsx)(r.strong,{children:"strict binary tree"}),", every non-leaf node has exactly ",(0,i.jsx)(r.strong,{children:"two children"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:["For a ",(0,i.jsx)(r.strong,{children:"strict k-ary tree"}),", every non-leaf node has exactly ",(0,i.jsx)(r.strong,{children:"k children"}),"."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"No node can have only 1 child."}),"\n",(0,i.jsxs)(r.li,{children:["Leaf nodes have ",(0,i.jsx)(r.strong,{children:"0 children"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:["Internal nodes have ",(0,i.jsx)(r.strong,{children:"exactly k children"})," (for k-ary trees; in binary case, exactly 2 children)."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"example-strict-binary-tree",children:"Example (Strict Binary Tree)"}),"\n",(0,i.jsx)("div",{style:{textAlign:"center"},children:(0,i.jsx)(r.mermaid,{value:"graph TD\n    A --\x3e B\n    A --\x3e C\n    B --\x3e D\n    B --\x3e E\n    C --\x3e F\n    C --\x3e G"})}),"\n",(0,i.jsx)(r.p,{children:"Here,"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"A, B, C are internal nodes \u2192 exactly 2 children each."}),"\n",(0,i.jsx)(r.li,{children:"D, E, F, G are leaves \u2192 0 children."}),"\n",(0,i.jsx)(r.li,{children:"This is a strict binary tree."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"complete-binary-tree",children:"Complete Binary Tree"}),"\n",(0,i.jsxs)(r.p,{children:["A ",(0,i.jsx)(r.strong,{children:"Complete Tree"})," is a tree in which ",(0,i.jsx)(r.strong,{children:"all levels are completely filled except possibly the last"}),", and the ",(0,i.jsx)(r.strong,{children:"last level has nodes as far left as possible"}),"."]}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Commonly discussed for binary trees (",(0,i.jsx)(r.strong,{children:"Complete Binary Tree"}),")."]}),"\n",(0,i.jsx)(r.li,{children:"Ensures compactness, which is useful for array storage."}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"key-points-1",children:"Key Points"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:["Every level except possibly the last is ",(0,i.jsx)(r.strong,{children:"fully filled"}),"."]}),"\n",(0,i.jsxs)(r.li,{children:["In the last level, nodes are placed ",(0,i.jsx)(r.strong,{children:"left to right"})," without gaps."]}),"\n",(0,i.jsxs)(r.li,{children:["Used in ",(0,i.jsx)(r.strong,{children:"heaps"})," (min-heap, max-heap)."]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"example-complete-binary-tree",children:"Example (Complete Binary Tree)"}),"\n",(0,i.jsx)("div",{style:{textAlign:"center"},children:(0,i.jsx)(r.mermaid,{value:"graph TD\n    A --\x3e B\n    A --\x3e C\n    B --\x3e D\n    B --\x3e E\n    C --\x3e F"})}),"\n",(0,i.jsx)(r.p,{children:"Here,"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"All levels except the last are completely filled."}),"\n",(0,i.jsx)(r.li,{children:"Last level nodes are left-aligned (D, E, F)."}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"differences-between-strict-and-complete-trees",children:"Differences Between Strict and Complete Trees"}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Feature"}),(0,i.jsx)(r.th,{children:"Strict Tree"}),(0,i.jsx)(r.th,{children:"Complete Tree"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Definition"})}),(0,i.jsxs)(r.td,{children:["Every non-leaf node has exactly ",(0,i.jsx)(r.em,{children:"k"})," children (binary: 2 children)."]}),(0,i.jsx)(r.td,{children:"All levels filled except possibly last, last filled left to right."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Children Count"})}),(0,i.jsx)(r.td,{children:"Internal nodes have fixed children count."}),(0,i.jsx)(r.td,{children:"Internal nodes can have variable children count, but placement follows completeness rule."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Shape"})}),(0,i.jsx)(r.td,{children:"More rigid structure."}),(0,i.jsx)(r.td,{children:"More flexible, only needs to fill nodes from top-left."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Example Use Case"})}),(0,i.jsx)(r.td,{children:"Perfectly balanced hierarchical structures."}),(0,i.jsx)(r.td,{children:"Heap data structure, BFS-based algorithms."})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Possible to be both?"})}),(0,i.jsx)(r.td,{children:"Yes, if the tree is also perfectly filled."}),(0,i.jsx)(r.td,{children:"Yes, if all internal nodes have exactly k children and levels are filled."})]})]})]}),"\n",(0,i.jsx)(r.h2,{id:"python-representation-examples",children:"Python Representation Examples"}),"\n",(0,i.jsx)(r.h3,{id:"strict-binary-tree-check",children:"Strict Binary Tree Check"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"class Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef is_strict_binary_tree(root):\n    if not root:\n        return True\n    if (root.left is None) != (root.right is None):\n        return False\n    return is_strict_binary_tree(root.left) and is_strict_binary_tree(root.right)\n\n# Example\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\n\nprint(is_strict_binary_tree(root))  # True\n"})}),"\n",(0,i.jsx)(r.h3,{id:"complete-binary-tree-check",children:"Complete Binary Tree Check"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"from collections import deque\n\ndef is_complete_binary_tree(root):\n    if not root:\n        return True\n    q = deque([root])\n    end = False\n    while q:\n        node = q.popleft()\n        if not node:\n            end = True\n        else:\n            if end:\n                return False\n            q.append(node.left)\n            q.append(node.right)\n    return True\n\nprint(is_complete_binary_tree(root))  # True\n"})})]})}function h(e={}){const{wrapper:r}={...(0,l.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>s,x:()=>a});var n=t(96540);const i={},l=n.createContext(i);function s(e){const r=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(l.Provider,{value:r},e.children)}}}]);