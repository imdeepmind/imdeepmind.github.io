"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[1369],{62719:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"databases/database-systems/relational-algebra","title":"Relational Algebra","description":"Relational Algebra is a formal system of query operations used on relational databases. It provides a mathematical foundation for understanding how database queries work and serves as the theoretical basis for SQL. Relational algebra operations allow us to manipulate relations (tables) and extract meaningful information from data.","source":"@site/docs/databases/database-systems/relational-algebra.md","sourceDirName":"databases/database-systems","slug":"/databases/database-systems/relational-algebra","permalink":"/docs/databases/database-systems/relational-algebra","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-systems/relational-algebra.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1763205258000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/databases/database-systems/introduction"},"next":{"title":"Database Storage","permalink":"/docs/databases/database-systems/database-storage"}}');var r=s(74848),l=s(28453);const t={sidebar_position:2},a="Relational Algebra",o={},d=[{value:"Basic Operations",id:"basic-operations",level:2},{value:"Selection (\u03c3)",id:"selection-\u03c3",level:3},{value:"Syntax",id:"syntax",level:4},{value:"Example",id:"example",level:4},{value:"Properties",id:"properties",level:4},{value:"Projection (\u03c0)",id:"projection-\u03c0",level:3},{value:"Syntax",id:"syntax-1",level:4},{value:"Example",id:"example-1",level:4},{value:"Properties",id:"properties-1",level:4},{value:"Cartesian Product (\xd7)",id:"cartesian-product-",level:3},{value:"Syntax",id:"syntax-2",level:4},{value:"Example",id:"example-2",level:4},{value:"Properties",id:"properties-2",level:4},{value:"Union (\u222a)",id:"union-",level:3},{value:"Syntax",id:"syntax-3",level:4},{value:"Example",id:"example-3",level:4},{value:"Properties",id:"properties-3",level:4},{value:"Set Difference (\u2212)",id:"set-difference-",level:3},{value:"Syntax",id:"syntax-4",level:4},{value:"Example",id:"example-4",level:4},{value:"Properties",id:"properties-4",level:4},{value:"Intersection (\u2229)",id:"intersection-",level:3},{value:"Syntax",id:"syntax-5",level:4},{value:"Example",id:"example-5",level:4},{value:"Properties",id:"properties-5",level:4},{value:"Derived Operations",id:"derived-operations",level:2},{value:"Join (\u22c8)",id:"join-",level:3},{value:"Natural Join",id:"natural-join",level:4},{value:"Syntax",id:"syntax-6",level:4},{value:"Example",id:"example-6",level:4},{value:"Theta Join",id:"theta-join",level:4},{value:"Syntax",id:"syntax-7",level:4},{value:"Example",id:"example-7",level:4},{value:"Equi-Join",id:"equi-join",level:4},{value:"Example",id:"example-8",level:4},{value:"Properties",id:"properties-6",level:4},{value:"Outer Joins",id:"outer-joins",level:3},{value:"Left Outer Join (\u27d5)",id:"left-outer-join-",level:4},{value:"Example",id:"example-9",level:4},{value:"Right Outer Join (\u27d6)",id:"right-outer-join-",level:4},{value:"Full Outer Join (\u27db)",id:"full-outer-join-",level:4},{value:"Division (\xf7)",id:"division-",level:3},{value:"Syntax",id:"syntax-8",level:4},{value:"Example",id:"example-10",level:4},{value:"Properties",id:"properties-7",level:4},{value:"Aggregate Functions",id:"aggregate-functions",level:2},{value:"Aggregation (\u03b3)",id:"aggregation-\u03b3",level:3},{value:"Syntax",id:"syntax-9",level:4},{value:"Example",id:"example-11",level:4},{value:"Grouping",id:"grouping",level:3},{value:"Syntax",id:"syntax-10",level:4},{value:"Example",id:"example-12",level:4},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Find customers who live in &quot;City A&quot;",id:"example-1-find-customers-who-live-in-city-a",level:3},{value:"Example 2: Find names of customers and their orders",id:"example-2-find-names-of-customers-and-their-orders",level:3},{value:"Example 3: Find names of customers who have placed orders for product &quot;P1&quot;",id:"example-3-find-names-of-customers-who-have-placed-orders-for-product-p1",level:3},{value:"Example 4: Find customers who have ordered both Product A and Product B",id:"example-4-find-customers-who-have-ordered-both-product-a-and-product-b",level:3},{value:"Example 5: Find total sales per month",id:"example-5-find-total-sales-per-month",level:3},{value:"Example 6: Find customers who have placed orders for all products",id:"example-6-find-customers-who-have-placed-orders-for-all-products",level:3},{value:"Important Properties and Laws",id:"important-properties-and-laws",level:2},{value:"Commutative Operations",id:"commutative-operations",level:3},{value:"Associative Operations",id:"associative-operations",level:3},{value:"Distributive Laws",id:"distributive-laws",level:3},{value:"Connection to SQL",id:"connection-to-sql",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"relational-algebra",children:"Relational Algebra"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Relational Algebra"})," is a formal system of query operations used on relational databases. It provides a mathematical foundation for understanding how database queries work and serves as the theoretical basis for SQL. Relational algebra operations allow us to manipulate relations (tables) and extract meaningful information from data."]}),"\n",(0,r.jsx)(n.h2,{id:"basic-operations",children:"Basic Operations"}),"\n",(0,r.jsx)(n.p,{children:"Relational algebra defines six fundamental operations that form the foundation for all query processing:"}),"\n",(0,r.jsx)(n.h3,{id:"selection-\u03c3",children:"Selection (\u03c3)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Selection"})," filters tuples (rows) based on a condition. It returns a subset of rows that satisfy the specified predicate."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03c3_condition(relation)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03c3_salary > 50000(Employees)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This returns all employees with a salary greater than 50,000."}),"\n",(0,r.jsx)(n.h4,{id:"properties",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unary operation (operates on a single relation)"}),"\n",(0,r.jsxs)(n.li,{children:["Commutative: ",(0,r.jsx)(n.code,{children:"\u03c3_c1(\u03c3_c2(R)) = \u03c3_c2(\u03c3_c1(R))"})]}),"\n",(0,r.jsxs)(n.li,{children:["Condition can use comparison operators ",(0,r.jsx)(n.code,{children:"(=, <, >, <=, >=, !=)"})," and logical operators (AND, OR, NOT)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"projection-\u03c0",children:"Projection (\u03c0)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Projection"})," selects specific columns (attributes) from a relation. It removes unwanted columns and returns a vertical subset of the relation."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-1",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03c0_attributes(relation)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03c0_name, salary(Employees)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This returns only the name and salary columns from the Employees table."}),"\n",(0,r.jsx)(n.h4,{id:"properties-1",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Unary operation"}),"\n",(0,r.jsx)(n.li,{children:"Removes duplicate tuples from the result"}),"\n",(0,r.jsx)(n.li,{children:"Useful for eliminating irrelevant attributes"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cartesian-product-",children:"Cartesian Product (\xd7)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cartesian Product"})," combines all tuples from two relations, creating a new relation with all possible combinations of rows."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-2",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \xd7 relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees \xd7 Departments\n"})}),"\n",(0,r.jsx)(n.p,{children:"If Employees has 10 rows and Departments has 5 rows, the result has 50 rows."}),"\n",(0,r.jsx)(n.h4,{id:"properties-2",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Binary operation"}),"\n",(0,r.jsx)(n.li,{children:"Commutative: R1 \xd7 R2 = R2 \xd7 R1"}),"\n",(0,r.jsx)(n.li,{children:"Associative: (R1 \xd7 R2) \xd7 R3 = R1 \xd7 (R2 \xd7 R3)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"union-",children:"Union (\u222a)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Union"})," combines tuples from two relations, returning all tuples that appear in either relation."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-3",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \u222a relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-3",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Managers \u222a Directors\n"})}),"\n",(0,r.jsx)(n.p,{children:"This returns all people who are either managers or directors."}),"\n",(0,r.jsx)(n.h4,{id:"properties-3",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Binary operation"}),"\n",(0,r.jsx)(n.li,{children:"Both relations must have the same schema (union-compatible)"}),"\n",(0,r.jsx)(n.li,{children:"Commutative: R1 \u222a R2 = R2 \u222a R1"}),"\n",(0,r.jsx)(n.li,{children:"Associative: (R1 \u222a R2) \u222a R3 = R1 \u222a (R2 \u222a R3)"}),"\n",(0,r.jsx)(n.li,{children:"Removes duplicate tuples"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"set-difference-",children:"Set Difference (\u2212)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Set Difference"})," returns tuples that appear in the first relation but not in the second."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-4",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \u2212 relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees \u2212 Managers\n"})}),"\n",(0,r.jsx)(n.p,{children:"This returns all employees who are not managers."}),"\n",(0,r.jsx)(n.h4,{id:"properties-4",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Binary operation"}),"\n",(0,r.jsx)(n.li,{children:"Both relations must have the same schema"}),"\n",(0,r.jsx)(n.li,{children:"Not commutative: R1 \u2212 R2 \u2260 R2 \u2212 R1"}),"\n",(0,r.jsx)(n.li,{children:"Not associative"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"intersection-",children:"Intersection (\u2229)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Intersection"})," returns tuples that appear in both relations."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-5",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \u2229 relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-5",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"FullTimeEmployees \u2229 DepartmentA\n"})}),"\n",(0,r.jsx)(n.p,{children:"This returns employees who are both full-time and in Department A."}),"\n",(0,r.jsx)(n.h4,{id:"properties-5",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Binary operation"}),"\n",(0,r.jsx)(n.li,{children:"Both relations must have the same schema"}),"\n",(0,r.jsx)(n.li,{children:"Commutative: R1 \u2229 R2 = R2 \u2229 R1"}),"\n",(0,r.jsx)(n.li,{children:"Associative: (R1 \u2229 R2) \u2229 R3 = R1 \u2229 (R2 \u2229 R3)"}),"\n",(0,r.jsx)(n.li,{children:"Can be expressed using other operations: R1 \u2229 R2 = R1 \u2212 (R1 \u2212 R2)"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"derived-operations",children:"Derived Operations"}),"\n",(0,r.jsx)(n.p,{children:"Derived operations are built from combinations of basic operations and are essential for practical queries:"}),"\n",(0,r.jsx)(n.h3,{id:"join-",children:"Join (\u22c8)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Join"})," combines tuples from two relations based on a join condition. It is one of the most important operations in relational algebra."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Types of Joins:"})}),"\n",(0,r.jsx)(n.h4,{id:"natural-join",children:"Natural Join"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Natural Join"})," combines relations on their common attributes, automatically eliminating duplicate columns."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-6",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \u22c8 relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-6",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees \u22c8 Departments\n"})}),"\n",(0,r.jsx)(n.p,{children:"This joins employees with departments based on matching department IDs."}),"\n",(0,r.jsx)(n.h4,{id:"theta-join",children:"Theta Join"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Theta Join"})," combines tuples from two relations based on a specified condition using any comparison operator."]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-7",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \u22c8_condition relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-7",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees \u22c8_(Employees.dept_id = Departments.id) Departments\n"})}),"\n",(0,r.jsx)(n.h4,{id:"equi-join",children:"Equi-Join"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.strong,{children:"Equi-Join"})," is a theta join where the condition uses only equality."]}),"\n",(0,r.jsx)(n.h4,{id:"example-8",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees \u22c8_(Employees.dept_id = Departments.id) Departments\n"})}),"\n",(0,r.jsx)(n.h4,{id:"properties-6",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Binary operation"}),"\n",(0,r.jsx)(n.li,{children:"Produces a Cartesian product filtered by the join condition"}),"\n",(0,r.jsxs)(n.li,{children:["Can be expressed as: ",(0,r.jsx)(n.code,{children:"R1 \u22c8_c R2 = \u03c3_c(R1 \xd7 R2)"})]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"outer-joins",children:"Outer Joins"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Outer Joins"})," preserve unmatched tuples from one or both relations:"]}),"\n",(0,r.jsx)(n.h4,{id:"left-outer-join-",children:"Left Outer Join (\u27d5)"}),"\n",(0,r.jsx)(n.p,{children:"Retains all tuples from the left relation, padding with NULL values when no match exists in the right relation."}),"\n",(0,r.jsx)(n.h4,{id:"example-9",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees \u27d5 Departments\n"})}),"\n",(0,r.jsx)(n.p,{children:"All employees are included, even those without assigned departments."}),"\n",(0,r.jsx)(n.h4,{id:"right-outer-join-",children:"Right Outer Join (\u27d6)"}),"\n",(0,r.jsx)(n.p,{children:"Retains all tuples from the right relation, padding with NULL values when no match exists in the left relation."}),"\n",(0,r.jsx)(n.h4,{id:"full-outer-join-",children:"Full Outer Join (\u27db)"}),"\n",(0,r.jsx)(n.p,{children:"Retains all tuples from both relations, padding with NULL values where matches don't exist."}),"\n",(0,r.jsx)(n.h3,{id:"division-",children:"Division (\xf7)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Division"}),' finds tuples in the first relation that are associated with all tuples in the second relation. It\'s useful for queries like "find all customers who have ordered every product."']}),"\n",(0,r.jsx)(n.h4,{id:"syntax-8",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation1 \xf7 relation2\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-10",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Orders \xf7 Products\n"})}),"\n",(0,r.jsx)(n.p,{children:"This returns customers who have ordered every product."}),"\n",(0,r.jsx)(n.h4,{id:"properties-7",children:"Properties"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Binary operation"}),"\n",(0,r.jsx)(n.li,{children:"Not commutative"}),"\n",(0,r.jsx)(n.li,{children:"Complex operation, often decomposed into simpler operations"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"aggregate-functions",children:"Aggregate Functions"}),"\n",(0,r.jsx)(n.p,{children:"Relational algebra extends with aggregate functions for summarization:"}),"\n",(0,r.jsx)(n.h3,{id:"aggregation-\u03b3",children:"Aggregation (\u03b3)"}),"\n",(0,r.jsx)(n.p,{children:"Computes a single value from a set of values."}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Common Aggregate Functions:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"COUNT"}),": Counts the number of tuples or non-null values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SUM"}),": Sums all values in a column"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AVG"}),": Calculates the average of values"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MIN"}),": Finds the minimum value"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MAX"}),": Finds the maximum value"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"syntax-9",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03b3_aggregation_function(relation)\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-11",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03b3_COUNT(*), SUM(salary)(Employees)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"grouping",children:"Grouping"}),"\n",(0,r.jsx)(n.p,{children:"Groups tuples based on specific attributes and applies aggregate functions to each group."}),"\n",(0,r.jsx)(n.h4,{id:"syntax-10",children:"Syntax"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"relation GROUP BY attributes AGGREGATION_FUNCTION\n"})}),"\n",(0,r.jsx)(n.h4,{id:"example-12",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Employees GROUP BY department SUM(salary)\n"})}),"\n",(0,r.jsx)(n.p,{children:"This calculates the total salary by department."}),"\n",(0,r.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,r.jsx)(n.h3,{id:"example-1-find-customers-who-live-in-city-a",children:'Example 1: Find customers who live in "City A"'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\u03c3_city="City A"(Customers)\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This selection filters the ",(0,r.jsx)(n.code,{children:"Customers"})," relation to only include rows where the ",(0,r.jsx)(n.code,{children:"city"}),' attribute equals "City A". It returns the full customer tuples (all columns) for those matching rows; equivalent SQL: ',(0,r.jsx)(n.code,{children:"SELECT * FROM Customers WHERE city = 'City A'"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example-2-find-names-of-customers-and-their-orders",children:"Example 2: Find names of customers and their orders"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Customers \u22c8 Orders\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This is an (inner) join between ",(0,r.jsx)(n.code,{children:"Customers"})," and ",(0,r.jsx)(n.code,{children:"Orders"}),". It pairs customer rows with their matching order rows (typically on ",(0,r.jsx)(n.code,{children:"customer_id"}),"), producing combined tuples that include fields from both relations. Equivalent SQL: ",(0,r.jsx)(n.code,{children:"SELECT * FROM Customers JOIN Orders ON Customers.id = Orders.customer_id"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example-3-find-names-of-customers-who-have-placed-orders-for-product-p1",children:'Example 3: Find names of customers who have placed orders for product "P1"'}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\u03c0_name(Customers \u22c8 (\u03c3_product="P1"(Orders)))\n'})}),"\n",(0,r.jsxs)(n.p,{children:["Steps: 1) ",(0,r.jsx)(n.code,{children:'\u03c3_product="P1"(Orders)'})," filters orders for product P1. 2) Join with ",(0,r.jsx)(n.code,{children:"Customers"})," to find matching customers. 3) ",(0,r.jsx)(n.code,{children:"\u03c0_name(...)"})," projects only the customer ",(0,r.jsx)(n.code,{children:"name"}),". Equivalent SQL: ",(0,r.jsx)(n.code,{children:"SELECT DISTINCT c.name FROM Customers c JOIN Orders o ON c.id = o.customer_id WHERE o.product = 'P1'"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example-4-find-customers-who-have-ordered-both-product-a-and-product-b",children:"Example 4: Find customers who have ordered both Product A and Product B"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:'\u03c0_customer_id(\u03c3_product="A"(Orders)) \u2229 \u03c0_customer_id(\u03c3_product="B"(Orders))\n'})}),"\n",(0,r.jsxs)(n.p,{children:["This computes two sets \u2014 customers who ordered product A and customers who ordered product B \u2014 and intersects them to produce customer IDs present in both sets: customers who ordered both A and B. Equivalent SQL: use ",(0,r.jsx)(n.code,{children:"GROUP BY"}),"+",(0,r.jsx)(n.code,{children:"HAVING"})," or two subqueries with ",(0,r.jsx)(n.code,{children:"INTERSECT"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example-5-find-total-sales-per-month",children:"Example 5: Find total sales per month"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Sales GROUP BY month SUM(amount)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This groups the ",(0,r.jsx)(n.code,{children:"Sales"})," relation by the ",(0,r.jsx)(n.code,{children:"month"})," attribute and computes the sum of ",(0,r.jsx)(n.code,{children:"amount"})," for each group. The result is one aggregated row per month with the total sales amount. Equivalent SQL: ",(0,r.jsx)(n.code,{children:"SELECT month, SUM(amount) FROM Sales GROUP BY month"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"example-6-find-customers-who-have-placed-orders-for-all-products",children:"Example 6: Find customers who have placed orders for all products"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"\u03c0_customer_id, product_id(Orders) \xf7 \u03c0_id(Products)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Division returns the set of customers who are associated with every value in the divisor relation (here, all product IDs). In other words, customers who have ordered every product. Equivalent SQL: ",(0,r.jsx)(n.code,{children:"SELECT customer_id FROM Orders GROUP BY customer_id HAVING COUNT(DISTINCT product_id) = (SELECT COUNT(*) FROM Products)"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"important-properties-and-laws",children:"Important Properties and Laws"}),"\n",(0,r.jsx)(n.h3,{id:"commutative-operations",children:"Commutative Operations"}),"\n",(0,r.jsx)(n.p,{children:"These operations produce the same result regardless of operand order:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Union: R1 \u222a R2 = R2 \u222a R1"}),"\n",(0,r.jsx)(n.li,{children:"Intersection: R1 \u2229 R2 = R2 \u2229 R2"}),"\n",(0,r.jsx)(n.li,{children:"Cartesian Product: R1 \xd7 R2 = R2 \xd7 R1"}),"\n",(0,r.jsx)(n.li,{children:"Join: R1 \u22c8 R2 = R2 \u22c8 R1"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"associative-operations",children:"Associative Operations"}),"\n",(0,r.jsx)(n.p,{children:"These operations can be grouped in any order:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Union: (R1 \u222a R2) \u222a R3 = R1 \u222a (R2 \u222a R3)"}),"\n",(0,r.jsx)(n.li,{children:"Intersection: (R1 \u2229 R2) \u2229 R3 = R1 \u2229 (R2 \u2229 R3)"}),"\n",(0,r.jsx)(n.li,{children:"Cartesian Product: (R1 \xd7 R2) \xd7 R3 = R1 \xd7 (R2 \xd7 R3)"}),"\n",(0,r.jsx)(n.li,{children:"Join: (R1 \u22c8 R2) \u22c8 R3 = R1 \u22c8 (R2 \u22c8 R3)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"distributive-laws",children:"Distributive Laws"}),"\n",(0,r.jsx)(n.p,{children:"Selection and projection distribute over some operations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Selection over Union: ",(0,r.jsx)(n.code,{children:"\u03c3_c(R1 \u222a R2) = \u03c3_c(R1) \u222a \u03c3_c(R2)"})]}),"\n",(0,r.jsxs)(n.li,{children:["Selection over Intersection: ",(0,r.jsx)(n.code,{children:"\u03c3_c(R1 \u2229 R2) = \u03c3_c(R1) \u2229 \u03c3_c(R2)"})]}),"\n",(0,r.jsxs)(n.li,{children:["Projection over Union: ",(0,r.jsx)(n.code,{children:"\u03c0_a(R1 \u222a R2) = \u03c0_a(R1) \u222a \u03c0_a(R2)"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"connection-to-sql",children:"Connection to SQL"}),"\n",(0,r.jsx)(n.p,{children:"Relational algebra is the theoretical foundation for SQL:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SELECT"})," clause corresponds to ",(0,r.jsx)(n.strong,{children:"Projection (\u03c0)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"WHERE"})," clause corresponds to ",(0,r.jsx)(n.strong,{children:"Selection (\u03c3)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"FROM"})," clause with multiple tables corresponds to ",(0,r.jsx)(n.strong,{children:"Cartesian Product (\xd7)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"JOIN"})," clause corresponds to ",(0,r.jsx)(n.strong,{children:"Join (\u22c8)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"UNION"})," clause corresponds to ",(0,r.jsx)(n.strong,{children:"Union (\u222a)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GROUP BY"})," and aggregate functions correspond to ",(0,r.jsx)(n.strong,{children:"Aggregation and Grouping"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Understanding relational algebra helps in:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Writing more efficient SQL queries"}),"\n",(0,r.jsx)(n.li,{children:"Understanding how database optimizers work"}),"\n",(0,r.jsx)(n.li,{children:"Designing better database schemas"}),"\n",(0,r.jsx)(n.li,{children:"Analyzing query complexity and performance"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(96540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);