"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[815],{74916:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"programming/programming-languages/go/goroutines/mutex","title":"Mutex","description":"Mutexes are synchronization primitives from the sync package that prevent race conditions when multiple goroutines access shared data. Only one goroutine can hold the lock at a time, ensuring safe access.","source":"@site/docs/programming/programming-languages/go/goroutines/mutex.md","sourceDirName":"programming/programming-languages/go/goroutines","slug":"/programming/programming-languages/go/goroutines/mutex","permalink":"/docs/programming/programming-languages/go/goroutines/mutex","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming/programming-languages/go/goroutines/mutex.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1755251208000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Wait Groups","permalink":"/docs/programming/programming-languages/go/goroutines/wait-group"},"next":{"title":"Channels","permalink":"/docs/programming/programming-languages/go/goroutines/channels"}}');var o=t(74848),r=t(28453);const a={sidebar_position:4},s="Mutex",c={},l=[{value:"Basic Usage",id:"basic-usage",level:2},{value:"Example: Protecting Shared Data",id:"example-protecting-shared-data",level:2},{value:"Without Mutex (race condition)",id:"without-mutex-race-condition",level:3},{value:"With Mutex (no race condition)",id:"with-mutex-no-race-condition",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Example: Using <code>defer</code> to Unlock",id:"example-using-defer-to-unlock",level:3},{value:"Multiple Mutexes &amp; Deadlocks",id:"multiple-mutexes--deadlocks",level:2},{value:"Mutex vs RWMutex",id:"mutex-vs-rwmutex",level:2},{value:"Example",id:"example",level:3},{value:"When to Use Mutex",id:"when-to-use-mutex",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"mutex",children:"Mutex"})}),"\n",(0,o.jsxs)(n.p,{children:["Mutexes are synchronization primitives from the ",(0,o.jsx)(n.code,{children:"sync"})," package that prevent race conditions when multiple goroutines access shared data. Only one goroutine can hold the lock at a time, ensuring safe access."]}),"\n",(0,o.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,o.jsx)(n.p,{children:"Wrap shared data access in a critical section:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"mu.Lock()\n// critical section\nmu.Unlock()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"example-protecting-shared-data",children:"Example: Protecting Shared Data"}),"\n",(0,o.jsx)(n.h3,{id:"without-mutex-race-condition",children:"Without Mutex (race condition)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "time"\n)\n\nvar counter int\n\nfunc increment() {\n    counter++\n}\n\nfunc main() {\n    for i := 0; i < 1000; i++ {\n        go increment()\n    }\n    time.Sleep(time.Second)\n    fmt.Println("Final Counter:", counter)\n}\n\n// Final counter will likely be less than 1000 due to race conditions.\n'})}),"\n",(0,o.jsx)(n.h3,{id:"with-mutex-no-race-condition",children:"With Mutex (no race condition)"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "fmt"\n    "sync"\n    "time"\n)\n\nvar counter int\nvar mu sync.Mutex\n\nfunc increment() {\n    mu.Lock()\n    counter++\n    mu.Unlock()\n}\n\nfunc main() {\n    for i := 0; i < 1000; i++ {\n        go increment()\n    }\n    time.Sleep(time.Second)\n    fmt.Println("Final Counter:", counter)\n}\n\n// Output will always be Final Counter: 1000\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsxs)(n.h3,{id:"example-using-defer-to-unlock",children:["Example: Using ",(0,o.jsx)(n.code,{children:"defer"})," to Unlock"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:"func increment() {\n    mu.Lock()\n    defer mu.Unlock()\n    counter++\n}\n\n// Ensures mutex is always unlocked, even on panic\n"})}),"\n",(0,o.jsx)(n.h2,{id:"multiple-mutexes--deadlocks",children:"Multiple Mutexes & Deadlocks"}),"\n",(0,o.jsx)(n.p,{children:"Always lock multiple mutexes in the same order to avoid deadlocks."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'var mu1 sync.Mutex\nvar mu2 sync.Mutex\n\nfunc routine1() {\n    mu1.Lock()\n    time.Sleep(100 * time.Millisecond)\n    mu2.Lock()\n    fmt.Println("Routine 1 finished")\n    mu2.Unlock()\n    mu1.Unlock()\n}\n\nfunc routine2() {\n    mu2.Lock()\n    time.Sleep(100 * time.Millisecond)\n    mu1.Lock()\n    fmt.Println("Routine 2 finished")\n    mu1.Unlock()\n    mu2.Unlock()\n}\n\nfunc main() {\n    go routine1()\n    go routine2()\n    time.Sleep(time.Second)\n}\n\n// routine1 locks mu1 then mu2, routine2 locks mu2 then mu1: causes deadlock\n'})}),"\n",(0,o.jsx)(n.h2,{id:"mutex-vs-rwmutex",children:"Mutex vs RWMutex"}),"\n",(0,o.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-go",children:'var rw sync.RWMutex\n\nfunc readData() {\n    rw.RLock()\n    fmt.Println("Reading data...")\n    time.Sleep(100 * time.Millisecond)\n    rw.RUnlock()\n}\n\nfunc writeData() {\n    rw.Lock()\n    fmt.Println("Writing data...")\n    time.Sleep(100 * time.Millisecond)\n    rw.Unlock()\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-mutex",children:"When to Use Mutex"}),"\n",(0,o.jsx)(n.p,{children:"We should use a Mutex when:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["We have ",(0,o.jsx)(n.strong,{children:"shared memory"})," accessed by multiple goroutines."]}),"\n",(0,o.jsxs)(n.li,{children:["We need to ",(0,o.jsx)(n.strong,{children:"protect data integrity"}),"."]}),"\n",(0,o.jsx)(n.li,{children:"Performance is more important than waiting for safe access (mutexes introduce some blocking)."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["We should ",(0,o.jsx)(n.strong,{children:"not"})," use a Mutex when:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Each goroutine works on independent data."}),"\n",(0,o.jsx)(n.li,{children:"Channels or message passing fits better into the design (channels often simplify concurrency)."}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(96540);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);