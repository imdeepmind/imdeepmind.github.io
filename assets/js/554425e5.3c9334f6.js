"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[7852],{14123:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"frameworks-libraries/frontend/react/imperative-react","title":"Imperative React","description":"In React, imperative programming refers to directly controlling the behavior or operations of a component, rather than relying solely on the declarative state-based updates that React encourages. While React is largely declarative (focusing on what the UI should look like based on state), there are situations where you need to directly interact with a component\u2019s behavior or DOM elements in an imperative manner.","source":"@site/docs/frameworks-libraries/frontend/react/imperative-react.md","sourceDirName":"frameworks-libraries/frontend/react","slug":"/frameworks-libraries/frontend/react/imperative-react","permalink":"/docs/frameworks-libraries/frontend/react/imperative-react","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/frameworks-libraries/frontend/react/imperative-react.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1749212834000,"sidebarPosition":9,"frontMatter":{"sidebar_position":9},"sidebar":"tutorialSidebar","previous":{"title":"Refs","permalink":"/docs/frameworks-libraries/frontend/react/refs"},"next":{"title":"Performance Optimization","permalink":"/docs/frameworks-libraries/frontend/react/performance-optimization"}}');var r=t(74848),o=t(28453);const i={sidebar_position:9},a="Imperative React",d={},c=[{value:"What is <code>useImperativeHandle</code>?",id:"what-is-useimperativehandle",level:2},{value:"How <code>useImperativeHandle</code> Works",id:"how-useimperativehandle-works",level:2},{value:"Example of <code>useImperativeHandle</code>",id:"example-of-useimperativehandle",level:2},{value:"When to Use <code>useImperativeHandle</code>",id:"when-to-use-useimperativehandle",level:2},{value:"Use Case Examples for <code>useImperativeHandle</code>",id:"use-case-examples-for-useimperativehandle",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"<code>forwardRef</code> and <code>useImperativeHandle</code>",id:"forwardref-and-useimperativehandle",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"imperative-react",children:"Imperative React"})}),"\n",(0,r.jsxs)(n.p,{children:["In React, ",(0,r.jsx)(n.strong,{children:"imperative programming"})," refers to directly controlling the behavior or operations of a component, rather than relying solely on the declarative state-based updates that React encourages. While React is largely declarative (focusing on what the UI should look like based on state), there are situations where you need to directly interact with a component\u2019s behavior or DOM elements in an imperative manner."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"useImperativeHandle"})})," hook provides a way to customize the instance value that is exposed when using ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ref"})})," on a component. This is especially useful when you want to expose a limited set of methods or properties to a parent component, and not the entire instance of a component."]}),"\n",(0,r.jsxs)(n.h2,{id:"what-is-useimperativehandle",children:["What is ",(0,r.jsx)(n.code,{children:"useImperativeHandle"}),"?"]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"useImperativeHandle"})})," hook allows functional components to ",(0,r.jsx)(n.strong,{children:"modify the values that are exposed to parent components through refs"}),". This helps in situations where you want to expose only a subset of the component\u2019s internal methods or properties to the outside world, rather than exposing the entire component instance or DOM node."]}),"\n",(0,r.jsxs)(n.p,{children:["By default, when you use a ",(0,r.jsx)(n.code,{children:"ref"})," on a component, you gain access to the component instance (in class components) or the DOM element (in functional components using ",(0,r.jsx)(n.code,{children:"useRef"}),"). With ",(0,r.jsx)(n.code,{children:"useImperativeHandle"}),", you can customize what is exposed through the ",(0,r.jsx)(n.code,{children:"ref"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"how-useimperativehandle-works",children:["How ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," Works"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"useRef"})})," is used to create a reference that is passed to the child component."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"useImperativeHandle"})})," customizes what properties or methods are exposed to the parent via that ref."]}),"\n",(0,r.jsxs)(n.li,{children:["You pass a ",(0,r.jsx)(n.code,{children:"ref"})," from the parent to the child component, and then inside the child, you use ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," to define the exposed properties or methods."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The hook signature is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"useImperativeHandle(\n  ref,\n  () => ({\n    someMethod: () => {\n      /* method implementation */\n    },\n  }),\n  [dependencies]\n);\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"ref"})}),": The ref that is passed from the parent component."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Callback Function"}),": A function that returns the object of properties or methods to be exposed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"dependencies"})}),": The array of dependencies to re-trigger the hook if any of them changes (similar to how ",(0,r.jsx)(n.code,{children:"useEffect"})," works)."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"example-of-useimperativehandle",children:["Example of ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})]}),"\n",(0,r.jsxs)(n.p,{children:["Here\u2019s an example where a parent component uses a ",(0,r.jsx)(n.code,{children:"ref"})," to call a method inside the child component, which is controlled via ",(0,r.jsx)(n.code,{children:"useImperativeHandle"}),"."]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsxs)(n.strong,{children:["Example: Customizing Exposed Methods with ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})]})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:'import React, { useState, useImperativeHandle, forwardRef } from "react";\n\n// Child Component\nconst Child = forwardRef((props, ref) => {\n  const [count, setCount] = useState(0);\n\n  // Expose a limited set of methods to the parent using useImperativeHandle\n  useImperativeHandle(ref, () => ({\n    increment: () => setCount(count + 1), // method to increment count\n    reset: () => setCount(0), // method to reset count\n  }));\n\n  return <div>Count: {count}</div>;\n});\n\n// Parent Component\nconst Parent = () => {\n  const childRef = React.useRef();\n\n  const handleIncrement = () => {\n    childRef.current.increment(); // Call increment method from Child component\n  };\n\n  const handleReset = () => {\n    childRef.current.reset(); // Call reset method from Child component\n  };\n\n  return (\n    <div>\n      <Child ref={childRef} />\n      <button onClick={handleIncrement}>Increment</button>\n      <button onClick={handleReset}>Reset</button>\n    </div>\n  );\n};\n\nexport default Parent;\n'})}),"\n",(0,r.jsx)(n.p,{children:"In this example:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Child"})})," component exposes two methods: ",(0,r.jsx)(n.code,{children:"increment"})," and ",(0,r.jsx)(n.code,{children:"reset"}),", which modify the internal state (",(0,r.jsx)(n.code,{children:"count"}),") of the ",(0,r.jsx)(n.code,{children:"Child"})," component."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"Parent"})})," component creates a ",(0,r.jsx)(n.code,{children:"ref"})," (",(0,r.jsx)(n.code,{children:"childRef"}),") and passes it to the ",(0,r.jsx)(n.code,{children:"Child"})," component."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"Parent"})," component calls the ",(0,r.jsx)(n.code,{children:"increment"})," and ",(0,r.jsx)(n.code,{children:"reset"})," methods using ",(0,r.jsx)(n.code,{children:"childRef.current"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"when-to-use-useimperativehandle",children:["When to Use ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"useImperativeHandle"})," should be used when you want to:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Limit what is exposed to the parent"}),": Instead of giving the parent direct access to all methods and state, ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," allows you to carefully expose only certain methods or properties."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Create more controlled components"}),": Sometimes a component\u2019s internal state or methods should not be directly accessible to the parent. ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," allows you to expose only specific behavior (like focusing an input or triggering an animation)."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Encapsulate behavior"}),": It\u2019s useful for encapsulating logic within a component and exposing a clean API for parent components to interact with, while keeping the internal implementation details hidden."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"use-case-examples-for-useimperativehandle",children:["Use Case Examples for ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Form Components"}),": A custom form component can expose methods like ",(0,r.jsx)(n.code,{children:"focus"})," or ",(0,r.jsx)(n.code,{children:"reset"}),", but the parent doesn\u2019t need to directly manage the form state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom UI Controls"}),": Components like modals, accordions, or sliders can expose imperative methods (like ",(0,r.jsx)(n.code,{children:"open"}),", ",(0,r.jsx)(n.code,{children:"close"}),", ",(0,r.jsx)(n.code,{children:"toggle"}),") that the parent can trigger without worrying about the internal details."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Third-Party Libraries"}),": Sometimes, when integrating third-party libraries that require imperative access to the DOM (e.g., to trigger an animation or set focus), ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," can help bridge the gap."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Use sparingly"}),": Refs should be used sparingly in React. They should not replace state management or props-driven behavior but should be used for scenarios where declarative control is not practical or possible."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Expose only necessary methods"}),": When using ",(0,r.jsx)(n.code,{children:"useImperativeHandle"}),", only expose the methods that are necessary for the parent to control. Avoid exposing the entire component instance or unnecessary internal logic."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Avoid side-effects"}),": Since ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," is for imperative logic, make sure that the methods you expose do not trigger unnecessary side effects that can lead to unpredictable behavior."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"forwardref-and-useimperativehandle",children:[(0,r.jsx)(n.code,{children:"forwardRef"})," and ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})]}),"\n",(0,r.jsxs)(n.p,{children:["For ",(0,r.jsx)(n.code,{children:"useImperativeHandle"})," to work, it is necessary to pass the ",(0,r.jsx)(n.code,{children:"ref"})," from the parent to the child component. This is where ",(0,r.jsx)(n.code,{children:"forwardRef"})," comes in. ",(0,r.jsx)(n.code,{children:"forwardRef"})," allows a functional component to accept a ",(0,r.jsx)(n.code,{children:"ref"})," passed from a parent and then forward it to a child element."]}),"\n",(0,r.jsxs)(n.p,{children:["In the earlier example, ",(0,r.jsx)(n.code,{children:"forwardRef"})," is used to pass the ",(0,r.jsx)(n.code,{children:"ref"})," from the parent to the ",(0,r.jsx)(n.code,{children:"Child"})," component so that the parent can access methods like ",(0,r.jsx)(n.code,{children:"increment"})," and ",(0,r.jsx)(n.code,{children:"reset"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var s=t(96540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);