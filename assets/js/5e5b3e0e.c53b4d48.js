"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[2989],{83042:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"system-design/kubernetes/components","title":"Components of Kubernetes","description":"Kubernetes has a rich architecture that includes a variety of components working together to enable the deployment, scaling, and management of containerized applications. These components can be divided into two main categories: Master Node components and Worker Node components.","source":"@site/docs/system-design/kubernetes/components.md","sourceDirName":"system-design/kubernetes","slug":"/system-design/kubernetes/components","permalink":"/docs/system-design/kubernetes/components","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/system-design/kubernetes/components.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1744107344000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/system-design/kubernetes/introduction"},"next":{"title":"Introduction","permalink":"/docs/version-control/introduction"}}');var r=s(74848),i=s(28453);const o={sidebar_position:2},l="Components of Kubernetes",a={},c=[{value:"Master Node Components",id:"master-node-components",level:2},{value:"Worker Node Components",id:"worker-node-components",level:2},{value:"Other Important Concepts in Kubernetes",id:"other-important-concepts-in-kubernetes",level:2},{value:"Summary Diagram",id:"summary-diagram",level:2}];function d(e){const n={h1:"h1",h2:"h2",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"components-of-kubernetes",children:"Components of Kubernetes"})}),"\n",(0,r.jsxs)(n.p,{children:["Kubernetes has a rich architecture that includes a variety of components working together to enable the deployment, scaling, and management of containerized applications. These components can be divided into two main categories: ",(0,r.jsx)(n.strong,{children:"Master Node"})," components and ",(0,r.jsx)(n.strong,{children:"Worker Node"})," components."]}),"\n",(0,r.jsx)(n.h2,{id:"master-node-components",children:"Master Node Components"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Master Node"})," is the control plane of Kubernetes, responsible for managing the overall state of the cluster and ensuring that the desired state of the applications is achieved. It contains several components:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kube API Server"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": The API server is the front-end for the Kubernetes control plane. All communication with the Kubernetes cluster (from external clients, nodes, or other components) happens through the API server."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Details"}),": It exposes the Kubernetes REST API, through which users, management tools, and other components can query and manipulate the state of the cluster."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Acts as the central hub where all components interact and is responsible for validating and processing REST requests, including those for scheduling and managing containers."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kube Controller Manager"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": The controller manager runs a set of controllers that handle routine tasks in the cluster, ensuring that the current state of the cluster matches the desired state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controllers"})," include:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Replication Controller"}),": Ensures the correct number of replicas of a pod are running."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deployment Controller"}),": Manages updates to application deployments."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"StatefulSet Controller"}),": Manages stateful applications."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Job Controller"}),": Manages batch jobs and ensures they complete successfully."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Handles the lifecycle of resources and reacts to changes in the cluster state."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kube Scheduler"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": The scheduler watches for newly created pods that have no assigned node, and then it selects an appropriate node for them to run on."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Details"}),": It makes decisions based on resource requirements, policies, and constraints (like affinity rules, resource availability, etc.)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Ensures that Pods are scheduled to run on nodes with the necessary resources (CPU, memory, etc.) and within the defined constraints."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Etcd"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": Etcd is a distributed key-value store used by Kubernetes to store all cluster data, including configurations, secrets, and state information."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Details"}),": It holds the entire cluster's state and configuration, ensuring consistency and availability in the event of a failure."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Serves as the backing store for all Kubernetes data. Changes to the cluster state are recorded in etcd, which allows other components to track the cluster\u2019s current state."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"worker-node-components",children:"Worker Node Components"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"Worker Nodes"})," are responsible for running the actual applications (containers). Each node in the cluster contains the necessary components to execute containers, manage the networking, and report back to the master node."]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kubelet"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": The kubelet is an agent that runs on every worker node in the cluster. It ensures that the containers running on the node are healthy and are running as specified by the pod specifications."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": It manages container lifecycles and ensures containers are running in the desired state (e.g., starting, stopping, and killing containers)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Kube Proxy"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": Kube proxy is responsible for maintaining network rules on each node. It ensures that network traffic is correctly routed to the appropriate pods."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Details"}),": It handles load balancing, service discovery, and traffic routing. It creates the necessary iptables (or IPVS) rules to route traffic to pods."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Acts as a network proxy and load balancer for services."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Container Runtime"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": The container runtime is responsible for pulling container images from a registry and running the containers on the node. Kubernetes supports multiple runtimes, with Docker being the most widely used."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Examples"}),": Docker, containerd, CRI-O."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Responsible for the actual execution of containers inside pods."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Pods"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": A pod is the smallest and simplest Kubernetes object. A pod can host one or more containers that share the same network, storage, and namespace."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Pods are the basic unit of deployment in Kubernetes. Each pod runs on a worker node and encapsulates the application containers, storage volumes, and networking."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"other-important-concepts-in-kubernetes",children:"Other Important Concepts in Kubernetes"}),"\n",(0,r.jsx)(n.p,{children:"While the above components are core to the Kubernetes architecture, there are additional concepts and tools that work in tandem with Kubernetes components to manage and enhance the system's operation:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Namespace"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": Provides a mechanism for isolating resources within a cluster."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Allows multiple teams or projects to coexist within a single cluster without interfering with each other\u2019s resources."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Service"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": A service in Kubernetes is an abstraction that defines a logical set of pods and provides a way to expose them to the network (internally or externally)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Acts as a load balancer, allowing access to Pods in a consistent way, even when the underlying Pods are dynamic or constantly changing."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Deployment"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": A deployment ensures that a specific number of replicas of a pod are running at any given time. It also manages rolling updates and rollbacks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Provides declarative updates to applications, enabling scaling and version control."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"ReplicaSet"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": Ensures that a specified number of pod replicas are running at any given time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": It\u2019s automatically created by a deployment, and it ensures the right number of pod replicas are running to maintain application availability."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"StatefulSet"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Function"}),": Similar to a Deployment but designed for stateful applications, where the identity and storage persist across pod restarts."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Role"}),": Manages stateful applications that require stable, unique network identifiers and stable persistent storage."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary-diagram",children:"Summary Diagram"}),"\n",(0,r.jsx)(n.p,{children:"Here\u2019s a simple visual diagram that summarizes the Kubernetes architecture:"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD\n    A[Kubernetes Cluster] --\x3e B[Master Node]\n    B --\x3e C[Kube API Server]\n    B --\x3e D[Kube Controller Manager]\n    B --\x3e E[Kube Scheduler]\n    B --\x3e F[Etcd]\n    A --\x3e G[Worker Node 1]\n    A --\x3e H[Worker Node 2]\n    G --\x3e I[Kubelet]\n    G --\x3e J[Kube Proxy]\n    G --\x3e K[Container Runtime]\n    H --\x3e I\n    H --\x3e J\n    H --\x3e K\n    G --\x3e L[Pod 1]\n    H --\x3e M[Pod 2]\n    L --\x3e N[Service]\n    L --\x3e O[Deployment]"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Master Node Components"}),": API Server, Controller Manager, Scheduler, and Etcd."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Worker Node Components"}),": Kubelet, Kube Proxy, Container Runtime, and Pods."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This gives an overall view of how the components work together in Kubernetes to manage containerized applications and ensure the cluster runs smoothly."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(96540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);