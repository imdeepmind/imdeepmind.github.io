"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[5405],{33835:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"programming/programming-languages/python/async","title":"Asynchronous Programming","description":"Python\'s asyncio is a library introduced in Python 3.4 to enable asynchronous programming, allowing developers to write concurrent code that can handle I/O-bound operations efficiently. It\u2019s particularly useful for tasks like network programming, web scraping, or any scenario where operations spend significant time waiting (e.g., for network responses or file I/O). Below is a detailed exploration of asyncio and its core components: Event Loop, Coroutines, Tasks, Futures, and Synchronization.","source":"@site/docs/programming/programming-languages/python/async.md","sourceDirName":"programming/programming-languages/python","slug":"/programming/programming-languages/python/async","permalink":"/docs/programming/programming-languages/python/async","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming/programming-languages/python/async.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1755253604000,"sidebarPosition":15,"frontMatter":{"sidebar_position":15},"sidebar":"tutorialSidebar","previous":{"title":"Multiprocessing","permalink":"/docs/programming/programming-languages/python/multiprocessing"},"next":{"title":"Metaprogramming","permalink":"/docs/programming/programming-languages/python/metaprogramming"}}');var r=s(74848),o=s(28453);const t={sidebar_position:15},a="Asynchronous Programming",c={},l=[{value:"What is <code>asyncio</code>?",id:"what-is-asyncio",level:2},{value:"When to Use",id:"when-to-use",level:3},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3},{value:"Example",id:"example",level:3},{value:"Event Loop",id:"event-loop",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"When to Use",id:"when-to-use-1",level:3},{value:"Pros",id:"pros-1",level:3},{value:"Cons",id:"cons-1",level:3},{value:"Example",id:"example-1",level:3},{value:"Notes",id:"notes",level:3},{value:"Coroutines",id:"coroutines",level:2},{value:"When to Use",id:"when-to-use-2",level:3},{value:"Pros",id:"pros-2",level:3},{value:"Cons",id:"cons-2",level:3},{value:"Example",id:"example-2",level:3},{value:"Notes",id:"notes-1",level:3},{value:"Tasks",id:"tasks",level:2},{value:"Use Cases for Tasks",id:"use-cases-for-tasks",level:3},{value:"Pros of Tasks",id:"pros-of-tasks",level:3},{value:"Cons of Tasks",id:"cons-of-tasks",level:3},{value:"Key Task-Related Tools",id:"key-task-related-tools",level:3},{value:"Examples of Tasks",id:"examples-of-tasks",level:3},{value:"Example 1: Using <code>asyncio.create_task</code> for Concurrent Execution",id:"example-1-using-asynciocreate_task-for-concurrent-execution",level:4},{value:"Example 2: Using <code>asyncio.gather</code> for Error Handling",id:"example-2-using-asynciogather-for-error-handling",level:4},{value:"Example 3: Using <code>asyncio.TaskGroup</code> for Structured Concurrency",id:"example-3-using-asynciotaskgroup-for-structured-concurrency",level:4},{value:"Example 4: Background Task with Cancellation",id:"example-4-background-task-with-cancellation",level:4},{value:"Example 5: Timeout with <code>TaskGroup</code>",id:"example-5-timeout-with-taskgroup",level:4},{value:"Best Practices for Tasks",id:"best-practices-for-tasks",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:3},{value:"Futures",id:"futures",level:2},{value:"When to Use",id:"when-to-use-3",level:3},{value:"Pros",id:"pros-3",level:3},{value:"Cons",id:"cons-3",level:3},{value:"Example",id:"example-3",level:3},{value:"Notes",id:"notes-2",level:3},{value:"Synchronization in Python <code>asyncio</code>",id:"synchronization-in-python-asyncio",level:2},{value:"Lock",id:"lock",level:3},{value:"Use Cases",id:"use-cases",level:4},{value:"When to Use",id:"when-to-use-4",level:4},{value:"Pros",id:"pros-4",level:4},{value:"Cons",id:"cons-4",level:4},{value:"Example",id:"example-4",level:4},{value:"Notes",id:"notes-3",level:4},{value:"Event",id:"event",level:3},{value:"Use Cases",id:"use-cases-1",level:4},{value:"When to Use",id:"when-to-use-5",level:4},{value:"Pros",id:"pros-5",level:4},{value:"Cons",id:"cons-5",level:4},{value:"Example",id:"example-5",level:4},{value:"Notes",id:"notes-4",level:4},{value:"Condition",id:"condition",level:3},{value:"Use Cases",id:"use-cases-2",level:4},{value:"When to Use",id:"when-to-use-6",level:4},{value:"Pros",id:"pros-6",level:4},{value:"Cons",id:"cons-6",level:4},{value:"Example",id:"example-6",level:4},{value:"Notes",id:"notes-5",level:4},{value:"Semaphore",id:"semaphore",level:3},{value:"Use Cases",id:"use-cases-3",level:4},{value:"When to Use",id:"when-to-use-7",level:4},{value:"Pros",id:"pros-7",level:4},{value:"Cons",id:"cons-7",level:4},{value:"Example",id:"example-7",level:4},{value:"Notes",id:"notes-6",level:4},{value:"BoundedSemaphore",id:"boundedsemaphore",level:3},{value:"Use Cases",id:"use-cases-4",level:4},{value:"When to Use",id:"when-to-use-8",level:4},{value:"Pros",id:"pros-8",level:4},{value:"Cons",id:"cons-8",level:4},{value:"Example",id:"example-8",level:4},{value:"Notes",id:"notes-7",level:4},{value:"General Notes on Synchronization",id:"general-notes-on-synchronization",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"asynchronous-programming",children:"Asynchronous Programming"})}),"\n",(0,r.jsxs)(n.p,{children:["Python's ",(0,r.jsx)(n.code,{children:"asyncio"})," is a library introduced in Python 3.4 to enable asynchronous programming, allowing developers to write concurrent code that can handle I/O-bound operations efficiently. It\u2019s particularly useful for tasks like network programming, web scraping, or any scenario where operations spend significant time waiting (e.g., for network responses or file I/O). Below is a detailed exploration of ",(0,r.jsx)(n.code,{children:"asyncio"})," and its core components: ",(0,r.jsx)(n.strong,{children:"Event Loop"}),", ",(0,r.jsx)(n.strong,{children:"Coroutines"}),", ",(0,r.jsx)(n.strong,{children:"Tasks"}),", ",(0,r.jsx)(n.strong,{children:"Futures"}),", and ",(0,r.jsx)(n.strong,{children:"Synchronization"}),"."]}),"\n",(0,r.jsxs)(n.h2,{id:"what-is-asyncio",children:["What is ",(0,r.jsx)(n.code,{children:"asyncio"}),"?"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"asyncio"})," is a Python standard library module that provides a framework for writing single-threaded concurrent code using coroutines, multiplexing I/O operations over sockets and other resources, and managing an event loop. It\u2019s designed for asynchronous I/O (async I/O), where operations can pause and resume without blocking the execution of other code."]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I/O-bound tasks"}),": Ideal for network requests, file operations, or database queries where the program waits for external resources."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High-concurrency applications"}),": Useful in web servers, chat applications, or APIs handling many simultaneous connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not for CPU-bound tasks"}),": Tasks requiring heavy computation (e.g., image processing) are better suited for multiprocessing or threading, as ",(0,r.jsx)(n.code,{children:"asyncio"})," runs in a single thread and relies on cooperative multitasking."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pros",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient resource usage"}),": Runs in a single thread, reducing memory and context-switching overhead compared to threads."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": Handles thousands of concurrent connections (e.g., in web servers like ",(0,r.jsx)(n.code,{children:"aiohttp"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Clear syntax"}),": With Python 3.5+ (",(0,r.jsx)(n.code,{children:"async/await"}),"), code is readable and resembles synchronous code."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cons",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning curve"}),": Requires understanding asynchronous concepts like coroutines and event loops."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited ecosystem"}),": Not all libraries support async I/O (e.g., some database drivers are synchronous)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging complexity"}),": Stack traces in async code can be harder to interpret."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-threaded"}),": No parallelism for CPU-bound tasks without additional tools like ",(0,r.jsx)(n.code,{children:"ProcessPoolExecutor"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def say_hello():\n    print("Hello")\n    await asyncio.sleep(1)  # Simulate I/O wait\n    print("World")\n\nasync def main():\n    await asyncio.gather(say_hello(), say_hello())  # Run concurrently\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),' (prints with a 1-second delay between "Hello" and "World" for each coroutine):']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Hello\nHello\nWorld\nWorld\n"})}),"\n",(0,r.jsx)(n.h2,{id:"event-loop",children:"Event Loop"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"event loop"})," is the core of ",(0,r.jsx)(n.code,{children:"asyncio"}),", responsible for scheduling and running asynchronous tasks, handling I/O events, and managing coroutines. It\u2019s like a coordinator that keeps track of all pending tasks and decides what to run next when resources (e.g., network data) become available."]}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The event loop maintains a queue of tasks (coroutines, callbacks, or I/O operations)."}),"\n",(0,r.jsx)(n.li,{children:"It continuously checks for completed I/O operations or tasks ready to resume."}),"\n",(0,r.jsxs)(n.li,{children:["When a coroutine ",(0,r.jsx)(n.code,{children:"await"}),"s an operation (e.g., ",(0,r.jsx)(n.code,{children:"await asyncio.sleep(1)"}),"), it yields control back to the event loop, which can then run another task."]}),"\n",(0,r.jsxs)(n.li,{children:["The loop uses OS-level mechanisms (e.g., ",(0,r.jsx)(n.code,{children:"select"})," or ",(0,r.jsx)(n.code,{children:"epoll"}),") to monitor I/O events efficiently."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-1",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Always required"}),": Any ",(0,r.jsx)(n.code,{children:"asyncio"})," program needs an event loop to execute coroutines."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Custom scheduling"}),": Use when you need fine-grained control over task execution or need to integrate with external event loops (e.g., ",(0,r.jsx)(n.code,{children:"uvloop"})," for performance)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I/O multiplexing"}),": Essential for handling multiple network connections concurrently."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pros-1",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient"}),": Single-threaded, non-blocking I/O handling scales well for many connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Customizable"}),": Supports replacing the default loop with high-performance alternatives like ",(0,r.jsx)(n.code,{children:"uvloop"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Centralized control"}),": Simplifies managing many tasks in one place."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cons-1",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-threaded"}),": No parallelism for CPU-bound tasks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling"}),": Errors in one task can affect the loop if not properly managed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manual management"}),": Requires explicit handling (e.g., closing the loop in some cases)."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def task1():\n    print("Task 1 started")\n    await asyncio.sleep(2)\n    print("Task 1 finished")\n\nasync def task2():\n    print("Task 2 started")\n    await asyncio.sleep(1)\n    print("Task 2 finished")\n\nloop = asyncio.get_event_loop()  # Get the default event loop\ntry:\n    loop.run_until_complete(asyncio.gather(task1(), task2()))  # Run tasks\nfinally:\n    loop.close()  # Clean up\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Task 1 started\nTask 2 started\nTask 2 finished\nTask 1 finished\n"})}),"\n",(0,r.jsx)(n.h3,{id:"notes",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"asyncio.run()"})," in Python 3.7+ for simpler loop management (it handles creation and cleanup)."]}),"\n",(0,r.jsxs)(n.li,{children:["Avoid blocking calls (e.g., ",(0,r.jsx)(n.code,{children:"time.sleep"}),") in the event loop, as they halt all tasks."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"coroutines",children:"Coroutines"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"coroutine"})," is a special function defined with ",(0,r.jsx)(n.code,{children:"async def"})," that can pause its execution (via ",(0,r.jsx)(n.code,{children:"await"}),") and yield control back to the event loop, allowing other tasks to run. Coroutines are the building blocks of ",(0,r.jsx)(n.code,{children:"asyncio"})," programs."]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-2",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Async operations"}),": Use for any function involving I/O operations (e.g., HTTP requests, reading files asynchronously)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Composing tasks"}),": Combine multiple coroutines to build complex workflows."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-blocking code"}),": When you want to avoid blocking the event loop during long-running operations."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pros-2",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Readable"}),": With ",(0,r.jsx)(n.code,{children:"async/await"}),", coroutines resemble synchronous code but run concurrently."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible"}),": Can be awaited, scheduled as tasks, or grouped with ",(0,r.jsx)(n.code,{children:"asyncio.gather"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lightweight"}),": Low memory overhead compared to threads."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cons-2",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Must be awaited"}),": Forgetting to ",(0,r.jsx)(n.code,{children:"await"})," a coroutine results in no execution (returns a coroutine object)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Library compatibility"}),": Only works with async-compatible libraries (e.g., ",(0,r.jsx)(n.code,{children:"aiohttp"}),", not ",(0,r.jsx)(n.code,{children:"requests"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling"}),": Requires careful use of ",(0,r.jsx)(n.code,{children:"try/except"})," to avoid unhandled exceptions breaking the loop."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def fetch_data():\n    print("Fetching data...")\n    await asyncio.sleep(1)  # Simulate network delay\n    return {"data": 42}\n\nasync def process_data():\n    print("Processing data...")\n    await asyncio.sleep(0.5)\n    return "Processed"\n\nasync def main():\n    result1 = await fetch_data()  # Wait for coroutine to complete\n    result2 = await process_data()\n    print(f"Results: {result1}, {result2}")\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Fetching data...\nProcessing data...\nResults: {'data': 42}, Processed\n"})}),"\n",(0,r.jsx)(n.h3,{id:"notes-1",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Coroutines are not executed until awaited or scheduled (e.g., as tasks)."}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"asyncio.gather(*coroutines)"})," to run multiple coroutines concurrently."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Below is a revised, detailed note focusing exclusively on ",(0,r.jsx)(n.strong,{children:"Tasks"})," in Python\u2019s ",(0,r.jsx)(n.code,{children:"asyncio"}),", incorporating ",(0,r.jsx)(n.code,{children:"asyncio.gather"})," and ",(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," as requested, while covering what tasks are, their use cases, pros, cons, and examples. The introduction to ",(0,r.jsx)(n.code,{children:"asyncio"})," has been removed, and the focus is narrowed to tasks only."]}),"\n",(0,r.jsx)(n.h2,{id:"tasks",children:"Tasks"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Task"})," in Python\u2019s ",(0,r.jsx)(n.code,{children:"asyncio"})," is an object that schedules and manages the execution of a coroutine in the event loop. It acts as a wrapper, allowing a coroutine to run concurrently without needing to be awaited immediately. Tasks are created primarily using ",(0,r.jsx)(n.code,{children:"asyncio.create_task()"}),", and they enable non-blocking, parallel execution of asynchronous operations."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Key characteristics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A Task is tied to a single coroutine and runs it in the event loop."}),"\n",(0,r.jsxs)(n.li,{children:["It has a lifecycle: ",(0,r.jsx)(n.strong,{children:"pending"})," (scheduled), ",(0,r.jsx)(n.strong,{children:"running"}),", ",(0,r.jsx)(n.strong,{children:"done"})," (completed or failed), or ",(0,r.jsx)(n.strong,{children:"cancelled"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Tasks provide methods to monitor status (",(0,r.jsx)(n.code,{children:"task.done()"}),"), retrieve results (",(0,r.jsx)(n.code,{children:"task.result()"}),"), or cancel execution (",(0,r.jsx)(n.code,{children:"task.cancel()"}),")."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tasks are distinct from raw coroutines"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A coroutine (defined with ",(0,r.jsx)(n.code,{children:"async def"}),") is a suspendable function."]}),"\n",(0,r.jsx)(n.li,{children:"A Task schedules that coroutine to run concurrently, managing its execution."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In addition to ",(0,r.jsx)(n.code,{children:"asyncio.create_task()"}),", tasks can be grouped and managed using ",(0,r.jsx)(n.code,{children:"asyncio.gather()"})," for collecting results or ",(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," (introduced in Python 3.11) for structured concurrency."]}),"\n",(0,r.jsx)(n.h3,{id:"use-cases-for-tasks",children:"Use Cases for Tasks"}),"\n",(0,r.jsx)(n.p,{children:"Tasks are ideal for scenarios requiring concurrent or background execution, such as:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrent operations"}),": Running multiple I/O-bound coroutines simultaneously, like fetching data from multiple APIs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Background processing"}),": Executing periodic tasks (e.g., logging, monitoring) while the main program continues."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Long-running jobs"}),": Scheduling tasks like file downloads or data processing without blocking other operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Workflow coordination"}),": Managing interdependent asynchronous tasks, such as fetching, processing, and saving data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Asynchronous servers"}),": Handling multiple client connections concurrently in applications like chat systems or WebSocket servers."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Real-world examples:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Web scraping"}),": Fetching multiple web pages in parallel."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"API clients"}),": Sending requests to multiple endpoints concurrently."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Real-time systems"}),": Managing streaming data or client connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Task queues"}),": Processing background jobs, like sending emails or generating reports."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pros-of-tasks",children:"Pros of Tasks"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Concurrency"}),": Enables multiple coroutines to run in parallel within a single thread, maximizing efficiency for I/O-bound operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Control"}),": Offers methods to check status, cancel tasks, or retrieve results, providing flexibility in managing execution."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Non-blocking"}),": Allows other tasks to proceed while waiting for I/O, improving responsiveness."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),": Supports thousands of concurrent tasks (e.g., client connections) with low memory overhead compared to threads."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Structured management"}),": Tools like ",(0,r.jsx)(n.code,{children:"asyncio.gather"})," and ",(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," simplify coordinating multiple tasks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling"}),": Tasks can propagate exceptions, which can be caught and managed explicitly."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cons-of-tasks",children:"Cons of Tasks"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complexity"}),": Managing task lifecycles, cancellations, or dependencies adds code complexity compared to sequential programming."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error handling"}),": Unhandled exceptions in tasks can fail silently unless explicitly checked, risking subtle bugs."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Not for CPU-bound work"}),": Tasks are suited for I/O-bound operations, not heavy computations (use ",(0,r.jsx)(n.code,{children:"multiprocessing"})," for those)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cancellation issues"}),": Cancelling tasks requires careful cleanup to avoid resource leaks (e.g., open connections)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Learning curve"}),": Understanding task scheduling, results, and tools like ",(0,r.jsx)(n.code,{children:"TaskGroup"})," requires familiarity with async concepts."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource risks"}),": Unawaited or forgotten tasks can lead to dangling resources, consuming memory or connections."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-task-related-tools",children:"Key Task-Related Tools"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"asyncio.create_task(coroutine)"})}),": Schedules a coroutine to run concurrently, returning a Task object."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"asyncio.gather(*aws, return_exceptions=False)"})}),": Runs multiple tasks (or coroutines) concurrently and collects their results in order. If ",(0,r.jsx)(n.code,{children:"return_exceptions=True"}),", exceptions are returned as results instead of raising them."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:[(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," (Python 3.11+)"]}),": A context manager for creating and managing a group of tasks with structured concurrency. Ensures all tasks complete (or are cancelled) when the group exits, simplifying error handling and cleanup."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"examples-of-tasks",children:"Examples of Tasks"}),"\n",(0,r.jsxs)(n.h4,{id:"example-1-using-asynciocreate_task-for-concurrent-execution",children:["Example 1: Using ",(0,r.jsx)(n.code,{children:"asyncio.create_task"})," for Concurrent Execution"]}),"\n",(0,r.jsx)(n.p,{children:"This example runs multiple tasks concurrently to simulate fetching data from servers with different delays."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\nimport time\n\nasync def fetch_data(server_id: int) -> str:\n    print(f"Fetching data from server {server_id}")\n    await asyncio.sleep(server_id)  # Simulate network delay\n    return f"Data from server {server_id}"\n\nasync def main():\n    # Create tasks\n    task1 = asyncio.create_task(fetch_data(1))\n    task2 = asyncio.create_task(fetch_data(2))\n    task3 = asyncio.create_task(fetch_data(3))\n\n    # Wait for tasks to complete\n    results = await asyncio.wait_for(asyncio.gather(task1, task2, task3), timeout=4)\n    print("Results:", results)\n\nstart_time = time.time()\nasyncio.run(main())\nprint(f"Total time: {time.time() - start_time:.2f} seconds")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Fetching data from server 1\nFetching data from server 2\nFetching data from server 3\nResults: ['Data from server 1', 'Data from server 2', 'Data from server 3']\nTotal time: 3.01 seconds\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Three tasks are created with ",(0,r.jsx)(n.code,{children:"asyncio.create_task"})," to fetch data with delays of 1, 2, and 3 seconds."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"asyncio.gather"})," waits for all tasks to complete and returns their results in order."]}),"\n",(0,r.jsx)(n.li,{children:"The total time is ~3 seconds (not 6), as tasks run concurrently."}),"\n",(0,r.jsx)(n.li,{children:"A 4-second timeout ensures the program doesn\u2019t hang indefinitely."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"example-2-using-asynciogather-for-error-handling",children:["Example 2: Using ",(0,r.jsx)(n.code,{children:"asyncio.gather"})," for Error Handling"]}),"\n",(0,r.jsxs)(n.p,{children:["This example uses ",(0,r.jsx)(n.code,{children:"asyncio.gather"})," to run tasks and handle exceptions gracefully."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def risky_operation(id: int):\n    print(f"Starting operation {id}")\n    await asyncio.sleep(1)\n    if id == 2:\n        raise ValueError(f"Error in operation {id}")\n    return f"Result {id}"\n\nasync def main():\n    # Create tasks\n    tasks = [asyncio.create_task(risky_operation(i)) for i in range(3)]\n\n    # Use gather to collect results, handling exceptions\n    results = await asyncio.gather(*tasks, return_exceptions=True)\n    for result in results:\n        print(f"Result: {result}")\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Starting operation 0\nStarting operation 1\nStarting operation 2\nResult: Result 0\nResult: Result 1\nResult: ValueError('Error in operation 2')\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Three tasks run ",(0,r.jsx)(n.code,{children:"risky_operation"}),", with ",(0,r.jsx)(n.code,{children:"id == 2"})," raising an exception."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"asyncio.gather"})," with ",(0,r.jsx)(n.code,{children:"return_exceptions=True"})," collects all results, including exceptions, preventing the program from crashing."]}),"\n",(0,r.jsx)(n.li,{children:"This ensures all tasks complete, and errors are reported as results."}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"example-3-using-asynciotaskgroup-for-structured-concurrency",children:["Example 3: Using ",(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," for Structured Concurrency"]}),"\n",(0,r.jsxs)(n.p,{children:["This example uses ",(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," to manage tasks with automatic cleanup and error propagation."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def process_item(item: int):\n    print(f"Processing item {item}")\n    await asyncio.sleep(item)\n    if item == 3:\n        raise ValueError(f"Failed to process item {item}")\n    return f"Processed {item}"\n\nasync def main():\n    async with asyncio.TaskGroup() as tg:\n        # Create tasks within the task group\n        tasks = [tg.create_task(process_item(i)) for i in range(1, 5)]\n\n    # Results are available after the group exits\n    for task in tasks:\n        if task.done() and not task.cancelled():\n            try:\n                print(f"Result: {task.result()}")\n            except Exception as e:\n                print(f"Error: {e}")\n\ntry:\n    asyncio.run(main())\nexcept Exception as e:\n    print(f"TaskGroup caught: {e}")\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Processing item 1\nProcessing item 2\nProcessing item 3\nProcessing item 4\nTaskGroup caught: Failed to process item 3\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"asyncio.TaskGroup"})," creates a context where tasks are grouped."]}),"\n",(0,r.jsxs)(n.li,{children:["Each task processes an item, with ",(0,r.jsx)(n.code,{children:"item == 3"})," raising an exception."]}),"\n",(0,r.jsxs)(n.li,{children:["If any task fails, ",(0,r.jsx)(n.code,{children:"TaskGroup"})," propagates the exception, cancelling other tasks automatically."]}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"async with"})," block ensures all tasks complete or are cleaned up, simplifying error handling."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-4-background-task-with-cancellation",children:"Example 4: Background Task with Cancellation"}),"\n",(0,r.jsx)(n.p,{children:"This example runs a background task and cancels it after the main work completes."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def background_monitor():\n    while True:\n        print("Monitoring...")\n        await asyncio.sleep(2)\n\nasync def main():\n    # Start background task\n    task = asyncio.create_task(background_monitor())\n\n    # Main work\n    for i in range(3):\n        print(f"Main step {i}")\n        await asyncio.sleep(1)\n\n    # Cancel background task\n    task.cancel()\n    try:\n        await task\n    except asyncio.CancelledError:\n        print("Background task cancelled")\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Main step 0\nMonitoring...\nMain step 1\nMain step 2\nMonitoring...\nBackground task cancelled\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A background task (",(0,r.jsx)(n.code,{children:"background_monitor"}),") runs every 2 seconds."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"asyncio.create_task"})," schedules it concurrently with the main coroutine."]}),"\n",(0,r.jsxs)(n.li,{children:["After 3 seconds of main work, the task is cancelled with ",(0,r.jsx)(n.code,{children:"task.cancel()"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"CancelledError"})," is caught to confirm graceful cancellation."]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"example-5-timeout-with-taskgroup",children:["Example 5: Timeout with ",(0,r.jsx)(n.code,{children:"TaskGroup"})]}),"\n",(0,r.jsxs)(n.p,{children:["This example enforces a timeout on a group of tasks using ",(0,r.jsx)(n.code,{children:"asyncio.wait_for"})," and ",(0,r.jsx)(n.code,{children:"TaskGroup"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def long_task(id: int):\n    print(f"Task {id} started")\n    await asyncio.sleep(id * 2)\n    print(f"Task {id} completed")\n    return f"Result {id}"\n\nasync def main():\n    try:\n        async with asyncio.TaskGroup() as tg:\n            tasks = [tg.create_task(long_task(i)) for i in range(1, 4)]\n            # Wrap TaskGroup in a timeout\n            results = await asyncio.wait_for(\n                asyncio.gather(*tasks, return_exceptions=True),\n                timeout=3\n            )\n            print("Results:", results)\n    except asyncio.TimeoutError:\n        print("Timeout! Tasks were cancelled by TaskGroup")\n    except Exception as e:\n        print(f"Error: {e}")\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Task 1 started\nTask 2 started\nTask 3 started\nTask 1 completed\nTimeout! Tasks were cancelled by TaskGroup\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["A ",(0,r.jsx)(n.code,{children:"TaskGroup"})," manages three tasks with delays of 2, 4, and 6 seconds."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"asyncio.wait_for"})," enforces a 3-second timeout."]}),"\n",(0,r.jsxs)(n.li,{children:["When the timeout occurs, ",(0,r.jsx)(n.code,{children:"TaskGroup"})," ensures all tasks are cancelled, preventing resource leaks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"return_exceptions=True"})," in ",(0,r.jsx)(n.code,{children:"gather"})," allows partial results to be collected if needed."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices-for-tasks",children:"Best Practices for Tasks"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Await tasks eventually"}),": Use ",(0,r.jsx)(n.code,{children:"asyncio.gather"}),", ",(0,r.jsx)(n.code,{children:"asyncio.wait"}),", or ",(0,r.jsx)(n.code,{children:"TaskGroup"})," to ensure tasks complete and their results are collected."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Handle exceptions"}),": Check ",(0,r.jsx)(n.code,{children:"task.result()"})," or use ",(0,r.jsx)(n.code,{children:"return_exceptions=True"})," in ",(0,r.jsx)(n.code,{children:"gather"}),". With ",(0,r.jsx)(n.code,{children:"TaskGroup"}),", exceptions are automatically propagated."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"TaskGroup"})," for structure"]}),": Prefer ",(0,r.jsx)(n.code,{children:"TaskGroup"})," (Python 3.11+) for grouped tasks to ensure cleanup and simplify error handling."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cancel cleanly"}),": Handle ",(0,r.jsx)(n.code,{children:"CancelledError"})," when cancelling tasks to close resources like files or connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enforce timeouts"}),": Use ",(0,r.jsx)(n.code,{children:"asyncio.wait_for"})," to prevent tasks from running indefinitely."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limit concurrency"}),": Use ",(0,r.jsx)(n.code,{children:"asyncio.Semaphore"})," for resource-intensive tasks to avoid overwhelming the event loop."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Monitor tasks"}),": Use ",(0,r.jsx)(n.code,{children:"task.done()"})," or ",(0,r.jsx)(n.code,{children:"task.add_done_callback"})," to track completion, especially for background tasks."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Unawaited tasks"}),": Tasks created with ",(0,r.jsx)(n.code,{children:"asyncio.create_task"})," run in the background but may be garbage-collected if not awaited."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"async def main():\n    task = asyncio.create_task(some_coroutine())  # Task may be lost\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fix"}),": Use ",(0,r.jsx)(n.code,{children:"await task"}),", ",(0,r.jsx)(n.code,{children:"await asyncio.gather(task)"}),", or ",(0,r.jsx)(n.code,{children:"TaskGroup"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Silent exceptions"}),": Tasks with unhandled exceptions won\u2019t crash the program but can fail unnoticed.\n",(0,r.jsx)(n.strong,{children:"Fix"}),": Use ",(0,r.jsx)(n.code,{children:"task.result()"}),", ",(0,r.jsx)(n.code,{children:"gather"})," with ",(0,r.jsx)(n.code,{children:"return_exceptions=True"}),", or ",(0,r.jsx)(n.code,{children:"TaskGroup"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Overusing tasks"}),": Creating too many tasks without limits can overload the event loop.\n",(0,r.jsx)(n.strong,{children:"Fix"}),": Use ",(0,r.jsx)(n.code,{children:"asyncio.Semaphore"})," or ",(0,r.jsx)(n.code,{children:"TaskGroup"})," to manage concurrency."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Improper ",(0,r.jsx)(n.code,{children:"gather"})," usage"]}),": Forgetting ",(0,r.jsx)(n.code,{children:"return_exceptions=True"})," can crash the program if one task fails.\n",(0,r.jsx)(n.strong,{children:"Fix"}),": Set ",(0,r.jsx)(n.code,{children:"return_exceptions=True"})," for robustness."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Ignoring ",(0,r.jsx)(n.code,{children:"TaskGroup"})," benefits"]}),": Manually managing tasks instead of using ",(0,r.jsx)(n.code,{children:"TaskGroup"})," can lead to messy cleanup.\n",(0,r.jsx)(n.strong,{children:"Fix"}),": Use ",(0,r.jsx)(n.code,{children:"TaskGroup"})," for structured concurrency in Python 3.11+."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"futures",children:"Futures"}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"future"})," is a low-level object representing the eventual result of an asynchronous operation. It\u2019s a placeholder for a value that will be available later. While coroutines and tasks are higher-level abstractions, futures are used internally by ",(0,r.jsx)(n.code,{children:"asyncio"})," or when integrating with external systems."]}),"\n",(0,r.jsx)(n.h3,{id:"when-to-use-3",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low-level control"}),": When you need to interface with callback-based libraries or custom event loops."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"External integration"}),": For bridging ",(0,r.jsx)(n.code,{children:"asyncio"})," with other async frameworks or systems."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rare in typical use"}),": Most ",(0,r.jsx)(n.code,{children:"asyncio"})," programs use tasks or coroutines instead, as they\u2019re more convenient."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pros-3",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible"}),": Allows manual control over result setting or exception handling."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Interoperable"}),": Useful for integrating with non-",(0,r.jsx)(n.code,{children:"asyncio"})," async code (e.g., Twisted, Tornado)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cancelable"}),": Like tasks, futures can be canceled."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"cons-3",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complex"}),": Requires manual management of state (e.g., setting results or exceptions)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error-prone"}),": Incorrect usage (e.g., not resolving a future) can lead to hanging tasks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rarely needed"}),": Higher-level abstractions like tasks usually suffice."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def set_future_result(future):\n    await asyncio.sleep(1)\n    future.set_result("Future resolved!")\n\nasync def main():\n    loop = asyncio.get_running_loop()\n    future = loop.create_future()  # Create a future\n    asyncio.create_task(set_future_result(future))  # Schedule task to set result\n    result = await future  # Wait for future to resolve\n    print(result)\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Future resolved!\n"})}),"\n",(0,r.jsx)(n.h3,{id:"notes-2",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Futures are rarely used directly in modern ",(0,r.jsx)(n.code,{children:"asyncio"})," code due to ",(0,r.jsx)(n.code,{children:"async/await"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"loop.create_future()"})," to create a future tied to the current event loop."]}),"\n",(0,r.jsxs)(n.li,{children:["Ensure futures are resolved (via ",(0,r.jsx)(n.code,{children:"set_result"})," or ",(0,r.jsx)(n.code,{children:"set_exception"}),") to avoid hangs."]}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"synchronization-in-python-asyncio",children:["Synchronization in Python ",(0,r.jsx)(n.code,{children:"asyncio"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Synchronization"})," in ",(0,r.jsx)(n.code,{children:"asyncio"})," refers to mechanisms that coordinate the execution of coroutines to prevent conflicts when accessing shared resources or to manage the order of operations in a concurrent environment. Since ",(0,r.jsx)(n.code,{children:"asyncio"})," operates in a single-threaded event loop, it avoids traditional race conditions associated with multi-threading for CPU-bound tasks. However, I/O-bound operations may still require synchronization to prevent issues like data corruption, overlapping operations, or to enforce specific execution patterns. ",(0,r.jsx)(n.code,{children:"asyncio"})," provides several synchronization primitives: ",(0,r.jsx)(n.strong,{children:"Lock"}),", ",(0,r.jsx)(n.strong,{children:"Event"}),", ",(0,r.jsx)(n.strong,{children:"Condition"}),", ",(0,r.jsx)(n.strong,{children:"Semaphore"}),", and ",(0,r.jsx)(n.strong,{children:"BoundedSemaphore"}),". Below is a detailed exploration of each, including their definitions, use cases, pros, cons, and examples."]}),"\n",(0,r.jsx)(n.h3,{id:"lock",children:"Lock"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"asyncio.Lock"})," ensures that only one coroutine can access a critical section of code or a shared resource at a time. When a coroutine acquires the lock, others attempting to acquire it must wait until it is released."]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Protecting shared resources"}),": Use when multiple coroutines modify a shared object (e.g., an in-memory counter or a file)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Preventing interleaved output"}),": Ensure that console or file output from multiple coroutines doesn\u2019t mix chaotically."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Exclusive access"}),": When a resource (e.g., a database connection) can only be used by one coroutine at a time."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-4",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When you need mutual exclusion to avoid data corruption or inconsistent states."}),"\n",(0,r.jsx)(n.li,{children:"For short critical sections to minimize contention."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"pros-4",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simple"}),": Easy to understand and use for basic mutual exclusion."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safe"}),": Prevents multiple coroutines from accessing a resource simultaneously."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Context manager support"}),": Using ",(0,r.jsx)(n.code,{children:"async with lock"})," ensures proper acquisition and release, even if exceptions occur."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cons-4",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deadlock risk"}),": Improper nesting of locks can cause deadlocks."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance overhead"}),": Holding a lock during long operations (e.g., I/O) can block other coroutines, reducing concurrency."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited flexibility"}),": Only allows one coroutine at a time, which may be too restrictive for some scenarios."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-4",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def increment_counter(lock, counter, name):\n    async with lock:  # Acquire lock safely\n        current = counter[0]\n        print(f"{name} read counter: {current}")\n        await asyncio.sleep(0.1)  # Simulate work\n        counter[0] = current + 1\n        print(f"{name} set counter: {counter[0]}")\n\nasync def main():\n    counter = [0]  # Shared resource\n    lock = asyncio.Lock()\n    tasks = [increment_counter(lock, counter, f"Task {i}") for i in range(3)]\n    await asyncio.gather(*tasks)\n    print(f"Final counter: {counter[0]}")\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Task 0 read counter: 0\nTask 0 set counter: 1\nTask 1 read counter: 1\nTask 1 set counter: 2\nTask 2 read counter: 2\nTask 2 set counter: 3\nFinal counter: 3\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),": The ",(0,r.jsx)(n.code,{children:"Lock"})," ensures that only one coroutine modifies the counter at a time, preventing race conditions that could lead to incorrect increments."]}),"\n",(0,r.jsx)(n.h4,{id:"notes-3",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"async with lock"})," to avoid manual ",(0,r.jsx)(n.code,{children:"acquire()"})," and ",(0,r.jsx)(n.code,{children:"release()"})," calls, which can be error-prone."]}),"\n",(0,r.jsxs)(n.li,{children:["Avoid holding locks during long ",(0,r.jsx)(n.code,{children:"await"})," operations to maintain concurrency."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"event",children:"Event"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"asyncio.Event"})," is a signaling mechanism that allows one or more coroutines to wait until a specific condition is met (the event is \u201cset\u201d). It\u2019s useful for coordinating coroutines without necessarily protecting a shared resource."]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-1",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Startup coordination"}),": Signal when a server or resource is ready (e.g., a web server waiting for a database connection)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"One-time triggers"}),": Notify multiple coroutines to proceed after an initial task completes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State changes"}),": Indicate when a system transitions to a new state (e.g., \u201cshutdown initiated\u201d)."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-5",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When coroutines need to wait for a single, non-repeating condition without modifying shared data."}),"\n",(0,r.jsx)(n.li,{children:"For broadcasting a signal to multiple waiting coroutines."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"pros-5",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Lightweight"}),": Simple way to coordinate coroutines without resource contention."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Broadcast capability"}),": Multiple coroutines can wait on the same event and proceed when it\u2019s set."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reusable"}),": Can be cleared and set multiple times."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cons-5",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No data passing"}),": Only signals a state change; no mechanism to share data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Manual management"}),": Requires explicit ",(0,r.jsx)(n.code,{children:"set()"})," and ",(0,r.jsx)(n.code,{children:"clear()"})," calls, which can be forgotten."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Limited use cases"}),": Less versatile than other primitives like ",(0,r.jsx)(n.code,{children:"Condition"})," for complex coordination."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-5",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def waiter(event, name):\n    print(f"{name} waiting for event")\n    await event.wait()  # Wait until event is set\n    print(f"{name} proceeding after event")\n\nasync def trigger(event):\n    print("Trigger task started")\n    await asyncio.sleep(1)  # Simulate setup work\n    print("Setting event")\n    event.set()  # Signal waiting coroutines\n\nasync def main():\n    event = asyncio.Event()\n    tasks = [\n        waiter(event, f"Waiter {i}") for i in range(3)\n    ] + [trigger(event)]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Waiter 0 waiting for event\nWaiter 1 waiting for event\nWaiter 2 waiting for event\nTrigger task started\nSetting event\nWaiter 0 proceeding after event\nWaiter 1 proceeding after event\nWaiter 2 proceeding after event\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),": The ",(0,r.jsx)(n.code,{children:"Event"})," allows multiple ",(0,r.jsx)(n.code,{children:"waiter"})," coroutines to pause until the ",(0,r.jsx)(n.code,{children:"trigger"})," coroutine sets the event, enabling coordinated startup."]}),"\n",(0,r.jsx)(n.h4,{id:"notes-4",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"event.clear()"})," to reset the event for reuse."]}),"\n",(0,r.jsxs)(n.li,{children:["Ensure ",(0,r.jsx)(n.code,{children:"set()"})," is called, or waiting coroutines will hang indefinitely."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"condition",children:"Condition"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"asyncio.Condition"})," is a more advanced synchronization primitive that allows coroutines to wait for a specific condition to be met, often in conjunction with a ",(0,r.jsx)(n.code,{children:"Lock"}),". It\u2019s used to notify waiting coroutines when a shared resource\u2019s state changes."]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-2",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Producer-consumer patterns"}),": Coordinate coroutines that produce and consume items from a shared queue."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State-based coordination"}),": Wait for a resource to reach a specific state (e.g., a buffer reaching a threshold)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic notifications"}),": Notify one or more coroutines when a condition changes, unlike the one-time nature of ",(0,r.jsx)(n.code,{children:"Event"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-6",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When coroutines need to wait for complex or dynamic conditions involving shared state."}),"\n",(0,r.jsx)(n.li,{children:"For scenarios requiring selective notification (e.g., notify one or all waiting coroutines)."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"pros-6",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible"}),": Supports complex conditions by integrating with a ",(0,r.jsx)(n.code,{children:"Lock"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Selective notification"}),": Can notify one (",(0,r.jsx)(n.code,{children:"notify()"}),") or all (",(0,r.jsx)(n.code,{children:"notify_all()"}),") waiting coroutines."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safe"}),": Built-in lock ensures thread-safe state checks."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cons-6",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complex"}),": More intricate than ",(0,r.jsx)(n.code,{children:"Lock"})," or ",(0,r.jsx)(n.code,{children:"Event"}),", requiring careful state management."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overhead"}),": Slightly heavier due to lock integration."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deadlock risk"}),": Misuse of the underlying lock can cause issues."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-6",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def producer(condition, buffer):\n    for i in range(3):\n        async with condition:\n            buffer.append(i)\n            print(f"Produced {i}, buffer: {buffer}")\n            condition.notify()  # Notify one consumer\n        await asyncio.sleep(0.5)\n\nasync def consumer(condition, buffer, name):\n    async with condition:\n        while not buffer:  # Wait for items\n            print(f"{name} waiting for items")\n            await condition.wait()\n        item = buffer.pop(0)\n        print(f"{name} consumed {item}, buffer: {buffer}")\n\nasync def main():\n    buffer = []\n    condition = asyncio.Condition()\n    tasks = [\n        producer(condition, buffer),\n        consumer(condition, buffer, "Consumer 1"),\n        consumer(condition, buffer, "Consumer 2"),\n    ]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"})," (order may vary slightly due to scheduling):"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Consumer 1 waiting for items\nConsumer 2 waiting for items\nProduced 0, buffer: [0]\nConsumer 1 consumed 0, buffer: []\nConsumer 2 waiting for items\nProduced 1, buffer: [1]\nConsumer 2 consumed 1, buffer: []\nConsumer 2 waiting for items\nProduced 2, buffer: [2]\nConsumer 2 consumed 2, buffer: []\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),": The ",(0,r.jsx)(n.code,{children:"Condition"})," coordinates producers and consumers, ensuring consumers only proceed when the buffer has items, with safe access via the condition\u2019s lock."]}),"\n",(0,r.jsx)(n.h4,{id:"notes-5",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Always check the condition after ",(0,r.jsx)(n.code,{children:"wait()"})," to avoid spurious wakeups."]}),"\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"async with condition"})," for safe lock management."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"semaphore",children:"Semaphore"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"asyncio.Semaphore"})," limits the number of coroutines that can access a resource concurrently. It maintains a counter that coroutines acquire and release, allowing up to a specified number of simultaneous accesses."]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-3",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Rate limiting"}),": Restrict the number of concurrent API requests or database queries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource pooling"}),": Manage a fixed number of resources (e.g., connections in a connection pool)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Throttling I/O"}),": Prevent overwhelming a server or disk with too many operations."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-7",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When you want to allow multiple coroutines to access a resource simultaneously, but with a cap."}),"\n",(0,r.jsxs)(n.li,{children:["For scenarios where full mutual exclusion (like ",(0,r.jsx)(n.code,{children:"Lock"}),") is too restrictive."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"pros-7",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Controlled concurrency"}),": Allows multiple coroutines to proceed, unlike ",(0,r.jsx)(n.code,{children:"Lock"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flexible"}),": Adjustable limit suits various use cases."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safe"}),": Context manager (",(0,r.jsx)(n.code,{children:"async with"}),") ensures proper acquisition and release."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cons-7",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"No exclusivity"}),": Doesn\u2019t prevent race conditions within the allowed coroutines (may need a ",(0,r.jsx)(n.code,{children:"Lock"})," for shared state)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Counter management"}),": Misuse (e.g., releasing more than acquired) can lead to errors (mitigated by ",(0,r.jsx)(n.code,{children:"BoundedSemaphore"}),")."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complexity"}),": Requires tuning the limit for optimal performance."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-7",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def access_api(semaphore, name):\n    async with semaphore:  # Limit concurrent access\n        print(f"{name} making API call")\n        await asyncio.sleep(1)  # Simulate API delay\n        print(f"{name} finished API call")\n\nasync def main():\n    semaphore = asyncio.Semaphore(2)  # Allow 2 concurrent calls\n    tasks = [access_api(semaphore, f"Task {i}") for i in range(5)]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Task 0 making API call\nTask 1 making API call\nTask 0 finished API call\nTask 1 finished API call\nTask 2 making API call\nTask 3 making API call\nTask 2 finished API call\nTask 3 finished API call\nTask 4 making API call\nTask 4 finished API call\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),": The ",(0,r.jsx)(n.code,{children:"Semaphore"})," ensures only two coroutines make API calls at a time, preventing server overload while allowing some concurrency."]}),"\n",(0,r.jsx)(n.h4,{id:"notes-6",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Choose the semaphore limit based on resource constraints (e.g., server capacity)."}),"\n",(0,r.jsxs)(n.li,{children:["Combine with a ",(0,r.jsx)(n.code,{children:"Lock"})," if the resource itself needs exclusive access within the semaphore\u2019s limit."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"boundedsemaphore",children:"BoundedSemaphore"}),"\n",(0,r.jsxs)(n.p,{children:["An ",(0,r.jsx)(n.code,{children:"asyncio.BoundedSemaphore"})," is a variant of ",(0,r.jsx)(n.code,{children:"Semaphore"})," that enforces stricter rules: it raises an error if a coroutine attempts to release the semaphore more times than it was acquired. This prevents bugs where the counter becomes artificially inflated."]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-4",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Same as Semaphore"}),": Rate limiting, resource pooling, or throttling I/O operations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety-critical systems"}),": When you need to ensure the semaphore\u2019s counter remains accurate (e.g., managing a fixed number of licenses or connections)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Debugging"}),": Helps catch programming errors during development."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-to-use-8",children:"When to Use"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["When you want the same functionality as ",(0,r.jsx)(n.code,{children:"Semaphore"})," but with added protection against over-releasing."]}),"\n",(0,r.jsx)(n.li,{children:"In production code where reliability is critical."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"pros-8",children:"Pros"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safer"}),": Prevents accidental over-release, which could allow too many coroutines to proceed."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Same benefits as Semaphore"}),": Controlled concurrency with flexible limits."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error detection"}),": Raises ",(0,r.jsx)(n.code,{children:"ValueError"})," for invalid releases, aiding debugging."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"cons-8",children:"Cons"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Slightly stricter"}),": May catch legitimate use cases if releases are intentionally unbalanced (rare)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Same limitations as Semaphore"}),": Doesn\u2019t prevent race conditions within the limit and requires tuning."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Overhead"}),": Minimal additional checks compared to ",(0,r.jsx)(n.code,{children:"Semaphore"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"example-8",children:"Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def access_resource(semaphore, name):\n    async with semaphore:\n        print(f"{name} acquired resource")\n        await asyncio.sleep(0.5)\n        print(f"{name} released resource")\n\nasync def main():\n    semaphore = asyncio.BoundedSemaphore(2)  # Allow 2 concurrent accesses\n    tasks = [access_resource(semaphore, f"Task {i}") for i in range(4)]\n    await asyncio.gather(*tasks)\n    # Attempting to release again would raise ValueError\n    try:\n        semaphore.release()\n    except ValueError as e:\n        print(f"Error: {e}")\n\nasyncio.run(main())\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Output"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"Task 0 acquired resource\nTask 1 acquired resource\nTask 0 released resource\nTask 1 released resource\nTask 2 acquired resource\nTask 3 acquired resource\nTask 2 released resource\nTask 3 released resource\nError: BoundedSemaphore released too many times\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Explanation"}),": The ",(0,r.jsx)(n.code,{children:"BoundedSemaphore"})," limits concurrent access to two coroutines, and attempting an extra ",(0,r.jsx)(n.code,{children:"release()"})," raises an error, ensuring the counter\u2019s integrity."]}),"\n",(0,r.jsx)(n.h4,{id:"notes-7",children:"Notes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"BoundedSemaphore"})," over ",(0,r.jsx)(n.code,{children:"Semaphore"})," in most cases unless you specifically need to allow unbalanced releases (rare)."]}),"\n",(0,r.jsx)(n.li,{children:"The error on over-release helps catch bugs early during testing."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"general-notes-on-synchronization",children:"General Notes on Synchronization"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsxs)(n.strong,{children:["Use ",(0,r.jsx)(n.code,{children:"async with"})]}),": For ",(0,r.jsx)(n.code,{children:"Lock"}),", ",(0,r.jsx)(n.code,{children:"Semaphore"}),", ",(0,r.jsx)(n.code,{children:"BoundedSemaphore"}),", and ",(0,r.jsx)(n.code,{children:"Condition"}),", the ",(0,r.jsx)(n.code,{children:"async with"})," syntax ensures proper acquisition and release, even if exceptions occur."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimize contention"}),": Avoid holding synchronization primitives during long ",(0,r.jsx)(n.code,{children:"await"})," operations (e.g., network calls) to maintain concurrency."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Combine primitives when needed"}),": For example, use a ",(0,r.jsx)(n.code,{children:"Lock"})," within a ",(0,r.jsx)(n.code,{children:"Semaphore"}),"-protected section if the resource requires both limited concurrency and exclusive access."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Test thoroughly"}),": Asynchronous code with synchronization can be tricky to debug, so use logging or tracing to verify correct behavior."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single-threaded context"}),": Since ",(0,r.jsx)(n.code,{children:"asyncio"})," is single-threaded, synchronization is only needed for coordinating I/O-bound operations or shared state, not for CPU-bound race conditions (which require multiprocessing or threading)."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(96540);const r={},o=i.createContext(r);function t(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);