"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[8958],{92070:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"design-patterns/solid","title":"SOLD","description":"SOLID is an acronym that represents five principles of object-oriented design that help developers create systems that are easier to manage, extend, and maintain. These principles, introduced by Robert C. Martin (Uncle Bob), are widely regarded as essential for writing clean, efficient, and maintainable code. By following these principles, developers can ensure that their software is more modular, flexible, and robust to changes.","source":"@site/docs/design-patterns/solid.md","sourceDirName":"design-patterns","slug":"/design-patterns/solid","permalink":"/docs/design-patterns/solid","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/design-patterns/solid.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1736345786000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/design-patterns/introduction"},"next":{"title":"Core Software Engineering Principles","permalink":"/docs/design-patterns/other-principles"}}');var r=s(74848),a=s(28453);const t={sidebar_position:2},l="SOLD",o={},d=[{value:"Single Responsibility Principle (SRP)**",id:"single-responsibility-principle-srp",level:2},{value:"Example",id:"example",level:3},{value:"Open/Closed Principle (OCP)**",id:"openclosed-principle-ocp",level:2},{value:"Example",id:"example-1",level:3},{value:"Liskov Substitution Principle (LSP)**",id:"liskov-substitution-principle-lsp",level:2},{value:"Example",id:"example-2",level:3},{value:"Interface Segregation Principle (ISP)**",id:"interface-segregation-principle-isp",level:2},{value:"Example",id:"example-3",level:3},{value:"Dependency Inversion Principle (DIP)**",id:"dependency-inversion-principle-dip",level:2},{value:"Example",id:"example-4",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"sold",children:"SOLD"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"SOLID"})," is an acronym that represents five principles of object-oriented design that help developers create systems that are easier to manage, extend, and maintain. These principles, introduced by Robert C. Martin (Uncle Bob), are widely regarded as essential for writing clean, efficient, and maintainable code. By following these principles, developers can ensure that their software is more modular, flexible, and robust to changes."]}),"\n",(0,r.jsx)(n.p,{children:"The SOLID principles are:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"S"})," \u2013 ",(0,r.jsx)(n.strong,{children:"Single Responsibility Principle (SRP)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"O"})," \u2013 ",(0,r.jsx)(n.strong,{children:"Open/Closed Principle (OCP)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"L"})," \u2013 ",(0,r.jsx)(n.strong,{children:"Liskov Substitution Principle (LSP)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"I"})," \u2013 ",(0,r.jsx)(n.strong,{children:"Interface Segregation Principle (ISP)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"D"})," \u2013 ",(0,r.jsx)(n.strong,{children:"Dependency Inversion Principle (DIP)"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"single-responsibility-principle-srp",children:"Single Responsibility Principle (SRP)**"}),"\n",(0,r.jsx)(n.p,{children:"The Single Responsibility Principle states that a class should have only one reason to change, meaning it should have only one job or responsibility. This means that a class should encapsulate a single concept, and it should not be responsible for multiple unrelated tasks. By adhering to SRP, the software becomes easier to understand, test, and maintain, as each class focuses on a single responsibility."}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Imagine a class ",(0,r.jsx)(n.code,{children:"User"})," that handles both user data management and sending emails. According to SRP, it should only handle one of these tasks. The responsibilities should be separated into two different classes, one for user data and one for sending emails, which leads to better modularity and easier future modifications."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Violating SRP: Single class doing multiple tasks\r\nclass User:\r\n    def __init__(self, name, email):\r\n        self.name = name\r\n        self.email = email\r\n\r\n    def save(self):\r\n        # Save user to the database\r\n        pass\r\n\r\n    def send_email(self):\r\n        # Send an email to the user\r\n        pass\r\n\r\n# Following SRP: Separate responsibilities\r\nclass User:\r\n    def __init__(self, name, email):\r\n        self.name = name\r\n        self.email = email\r\n\r\n    def save(self):\r\n        # Save user to the database\r\n        pass\r\n\r\nclass EmailService:\r\n    def send_email(self, email):\r\n        # Send email logic\r\n        pass\n"})}),"\n",(0,r.jsx)(n.h2,{id:"openclosed-principle-ocp",children:"Open/Closed Principle (OCP)**"}),"\n",(0,r.jsx)(n.p,{children:"The Open/Closed Principle states that a software entity (class, module, or function) should be open for extension but closed for modification. In other words, you should be able to add new functionality to a class without changing its existing code. This principle encourages the use of polymorphism, inheritance, and interfaces, which allow the behavior of the class to be extended without altering its original implementation."}),"\n",(0,r.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Imagine a ",(0,r.jsx)(n.code,{children:"Shape"})," class that calculates the area for different types of shapes. According to OCP, we can extend the functionality for new shapes (like ",(0,r.jsx)(n.code,{children:"Circle"}),", ",(0,r.jsx)(n.code,{children:"Rectangle"}),", etc.) without modifying the existing ",(0,r.jsx)(n.code,{children:"Shape"})," class. Instead, we can extend the base class and override its methods."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Violating OCP: Modifying the class for new shapes\r\nclass AreaCalculator:\r\n    def calculate_area(self, shape):\r\n        if isinstance(shape, Circle):\r\n            return 3.14 * shape.radius ** 2\r\n        elif isinstance(shape, Rectangle):\r\n            return shape.length * shape.width\r\n        # Additional shapes require modifying the code\r\n\r\n# Following OCP: Extending functionality via inheritance\r\nclass Shape:\r\n    def calculate_area(self):\r\n        pass\r\n\r\nclass Circle(Shape):\r\n    def __init__(self, radius):\r\n        self.radius = radius\r\n\r\n    def calculate_area(self):\r\n        return 3.14 * self.radius ** 2\r\n\r\nclass Rectangle(Shape):\r\n    def __init__(self, length, width):\r\n        self.length = length\r\n        self.width = width\r\n\r\n    def calculate_area(self):\r\n        return self.length * self.width\n"})}),"\n",(0,r.jsx)(n.h2,{id:"liskov-substitution-principle-lsp",children:"Liskov Substitution Principle (LSP)**"}),"\n",(0,r.jsx)(n.p,{children:"The Liskov Substitution Principle states that objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program. In other words, a subclass should extend the functionality of a superclass without changing its expected behavior. Violating LSP can lead to unpredictable behavior and bugs when replacing objects at runtime."}),"\n",(0,r.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Consider a ",(0,r.jsx)(n.code,{children:"Bird"})," class with a ",(0,r.jsx)(n.code,{children:"fly"})," method, and a ",(0,r.jsx)(n.code,{children:"Penguin"})," subclass. Penguins cannot fly, so violating LSP would occur if we had a ",(0,r.jsx)(n.code,{children:"Penguin"})," class inherit from ",(0,r.jsx)(n.code,{children:"Bird"})," and use the ",(0,r.jsx)(n.code,{children:"fly"})," method. Instead, ",(0,r.jsx)(n.code,{children:"Penguin"})," should either not inherit from ",(0,r.jsx)(n.code,{children:"Bird"})," or redefine its behavior in a way that does not interfere with the superclass expectations."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Violating LSP\r\nclass Bird:\r\n    def fly(self):\r\n        pass\r\n\r\nclass Penguin(Bird):\r\n    def fly(self):\r\n        raise NotImplementedError("Penguins can\'t fly")\r\n\r\n# Following LSP\r\nclass Bird:\r\n    def move(self):\r\n        pass\r\n\r\nclass Sparrow(Bird):\r\n    def move(self):\r\n        # Logic for flying\r\n\r\nclass Penguin(Bird):\r\n    def move(self):\r\n        # Logic for swimming\n'})}),"\n",(0,r.jsx)(n.h2,{id:"interface-segregation-principle-isp",children:"Interface Segregation Principle (ISP)**"}),"\n",(0,r.jsx)(n.p,{children:"The Interface Segregation Principle states that no client should be forced to depend on methods it does not use. In other words, classes should have small, focused interfaces rather than large, monolithic ones. This principle prevents clients from having to implement unnecessary methods, leading to a cleaner, more maintainable design."}),"\n",(0,r.jsx)(n.h3,{id:"example-3",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Suppose you have an interface for ",(0,r.jsx)(n.code,{children:"Machine"})," that includes methods for both ",(0,r.jsx)(n.code,{children:"print"})," and ",(0,r.jsx)(n.code,{children:"scan"}),". If a ",(0,r.jsx)(n.code,{children:"Printer"})," class only needs the ",(0,r.jsx)(n.code,{children:"print"})," functionality, it should not be forced to implement the ",(0,r.jsx)(n.code,{children:"scan"})," method, as it has no use for it."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'# Violating ISP\r\nclass Machine:\r\n    def print(self):\r\n        pass\r\n\r\n    def scan(self):\r\n        pass\r\n\r\nclass Printer(Machine):\r\n    def print(self):\r\n        pass\r\n\r\n    def scan(self):\r\n        raise NotImplementedError("Printer can\'t scan")\r\n\r\n# Following ISP\r\nclass Printer:\r\n    def print(self):\r\n        pass\r\n\r\nclass Scanner:\r\n    def scan(self):\r\n        pass\n'})}),"\n",(0,r.jsx)(n.h2,{id:"dependency-inversion-principle-dip",children:"Dependency Inversion Principle (DIP)**"}),"\n",(0,r.jsx)(n.p,{children:"The Dependency Inversion Principle states that high-level modules should not depend on low-level modules; both should depend on abstractions. Additionally, abstractions should not depend on details; details should depend on abstractions. This principle promotes loose coupling between classes and allows for easier modification and testing by inverting the direction of dependencies."}),"\n",(0,r.jsx)(n.h3,{id:"example-4",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Suppose a ",(0,r.jsx)(n.code,{children:"UserService"})," class depends on a ",(0,r.jsx)(n.code,{children:"Database"})," class for data storage. Following DIP, the ",(0,r.jsx)(n.code,{children:"UserService"})," class should depend on an abstraction (like an interface) rather than the concrete ",(0,r.jsx)(n.code,{children:"Database"})," class. This makes it easier to switch between different database implementations or mock dependencies for testing."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Violating DIP\r\nclass UserService:\r\n    def __init__(self):\r\n        self.database = Database()  # Direct dependency on Database\r\n\r\n    def save_user(self, user):\r\n        self.database.save(user)\r\n\r\nclass Database:\r\n    def save(self, user):\r\n        # Save logic\r\n        pass\r\n\r\n# Following DIP\r\nclass UserService:\r\n    def __init__(self, database: DatabaseInterface):\r\n        self.database = database  # Dependency injected through abstraction\r\n\r\n    def save_user(self, user):\r\n        self.database.save(user)\r\n\r\nclass DatabaseInterface:\r\n    def save(self, user):\r\n        pass\r\n\r\nclass MySQLDatabase(DatabaseInterface):\r\n    def save(self, user):\r\n        # MySQL save logic\r\n        pass\r\n\r\nclass MongoDatabase(DatabaseInterface):\r\n    def save(self, user):\r\n        # MongoDB save logic\r\n        pass\n"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(96540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);