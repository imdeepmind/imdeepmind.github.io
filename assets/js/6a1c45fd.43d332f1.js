"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[2595],{4014:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"programming-languages/javascript/oop","title":"Object-Oriented Programming (OOPs)","description":"Object-Oriented Programming (OOPs) is a programming paradigm that models real-world entities using objects. It provides a structured approach to organize and manage code by encapsulating data and functionality together. OOPs promotes reusability, scalability, and maintainability by employing key principles such as inheritance, encapsulation, polymorphism, and abstraction.","source":"@site/docs/programming-languages/javascript/oop.md","sourceDirName":"programming-languages/javascript","slug":"/programming-languages/javascript/oop","permalink":"/docs/programming-languages/javascript/oop","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming-languages/javascript/oop.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735588931000,"sidebarPosition":16,"frontMatter":{"sidebar_position":16},"sidebar":"tutorialSidebar","previous":{"title":"Prototypes and Inheritance","permalink":"/docs/programming-languages/javascript/prototype-inheritance"},"next":{"title":"Type Coercion vs Type Conversion","permalink":"/docs/programming-languages/javascript/coercion-conversion"}}');var t=s(4848),i=s(8453);const r={sidebar_position:16},o="Object-Oriented Programming (OOPs)",l={},c=[{value:"Core Concepts of OOP",id:"core-concepts-of-oop",level:2},{value:"Objects",id:"objects",level:3},{value:"Classes",id:"classes",level:3},{value:"Encapsulation",id:"encapsulation",level:3},{value:"Inheritance",id:"inheritance",level:3},{value:"Polymorphism",id:"polymorphism",level:3},{value:"Abstraction",id:"abstraction",level:3},{value:"Pillars of OOP",id:"pillars-of-oop",level:2},{value:"Features of OOP in JavaScript",id:"features-of-oop-in-javascript",level:2},{value:"Constructor Functions (Pre-ES6)",id:"constructor-functions-pre-es6",level:3},{value:"Prototypal Inheritance",id:"prototypal-inheritance",level:3},{value:"ES6 Classes",id:"es6-classes",level:3},{value:"Advantages of OOP",id:"advantages-of-oop",level:2},{value:"Disadvantages of OOP",id:"disadvantages-of-oop",level:2},{value:"OOP vs. Functional Programming",id:"oop-vs-functional-programming",level:2},{value:"Real-World Use Cases",id:"real-world-use-cases",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"object-oriented-programming-oops",children:"Object-Oriented Programming (OOPs)"})}),"\n",(0,t.jsx)(e.p,{children:"Object-Oriented Programming (OOPs) is a programming paradigm that models real-world entities using objects. It provides a structured approach to organize and manage code by encapsulating data and functionality together. OOPs promotes reusability, scalability, and maintainability by employing key principles such as inheritance, encapsulation, polymorphism, and abstraction."}),"\n",(0,t.jsx)(e.h2,{id:"core-concepts-of-oop",children:"Core Concepts of OOP"}),"\n",(0,t.jsx)(e.h3,{id:"objects",children:"Objects"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["An object is a collection of ",(0,t.jsx)(e.strong,{children:"properties"})," and ",(0,t.jsx)(e.strong,{children:"methods"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"Properties are key-value pairs that hold data, while methods are functions associated with the object."}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'const car = {\n  brand: "Toyota",\n  model: "Camry",\n  start: function () {\n    console.log(`${this.brand} ${this.model} is starting`);\n  },\n};\n\ncar.start(); // Output: Toyota Camry is starting\n'})}),"\n",(0,t.jsx)(e.h3,{id:"classes",children:"Classes"}),"\n",(0,t.jsx)(e.p,{children:"A class is a blueprint for creating objects. It defines the structure and behavior of the object. In JavaScript, classes were introduced in ES6 (ECMAScript 2015)."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'class Car {\n  constructor(brand, model) {\n    this.brand = brand;\n    this.model = model;\n  }\n\n  start() {\n    console.log(`${this.brand} ${this.model} is starting`);\n  }\n}\n\nconst myCar = new Car("Toyota", "Camry");\nmyCar.start(); // Output: Toyota Camry is starting\n'})}),"\n",(0,t.jsx)(e.h3,{id:"encapsulation",children:"Encapsulation"}),"\n",(0,t.jsxs)(e.p,{children:["Encapsulation refers to bundling the data (properties) and methods that operate on the data into a single unit (class or object). It also allows restricting direct access to some components using ",(0,t.jsx)(e.strong,{children:"private fields"})," or ",(0,t.jsx)(e.strong,{children:"methods"}),"."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:"class BankAccount {\n  #balance; // Private property\n\n  constructor(initialBalance) {\n    this.#balance = initialBalance;\n  }\n\n  deposit(amount) {\n    this.#balance += amount;\n  }\n\n  getBalance() {\n    return this.#balance;\n  }\n}\n\nconst account = new BankAccount(1000);\naccount.deposit(500);\nconsole.log(account.getBalance()); // Output: 1500\n// console.log(account.#balance); // Error: Private field cannot be accessed directly\n"})}),"\n",(0,t.jsx)(e.h3,{id:"inheritance",children:"Inheritance"}),"\n",(0,t.jsx)(e.p,{children:"Inheritance allows a class to inherit properties and methods from another class. This helps in reusing existing code and extending functionality."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'class Vehicle {\n  constructor(brand) {\n    this.brand = brand;\n  }\n\n  start() {\n    console.log(`${this.brand} is starting`);\n  }\n}\n\nclass Car extends Vehicle {\n  constructor(brand, model) {\n    super(brand); // Call the parent class constructor\n    this.model = model;\n  }\n\n  start() {\n    console.log(`${this.brand} ${this.model} is starting`);\n  }\n}\n\nconst myCar = new Car("Toyota", "Camry");\nmyCar.start(); // Output: Toyota Camry is starting\n'})}),"\n",(0,t.jsx)(e.h3,{id:"polymorphism",children:"Polymorphism"}),"\n",(0,t.jsx)(e.p,{children:'Polymorphism means "many forms." It allows methods to be overridden in derived classes, enabling different behaviors for the same method name.'}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'class Animal {\n  makeSound() {\n    console.log("Animal makes a sound");\n  }\n}\n\nclass Dog extends Animal {\n  makeSound() {\n    console.log("Dog barks");\n  }\n}\n\nclass Cat extends Animal {\n  makeSound() {\n    console.log("Cat meows");\n  }\n}\n\nconst animals = [new Animal(), new Dog(), new Cat()];\nanimals.forEach((animal) => animal.makeSound());\n// Output:\n// Animal makes a sound\n// Dog barks\n// Cat meows\n'})}),"\n",(0,t.jsx)(e.h3,{id:"abstraction",children:"Abstraction"}),"\n",(0,t.jsx)(e.p,{children:"Abstraction hides complex implementation details and exposes only the necessary parts of an object. In JavaScript, you can achieve abstraction by using classes and methods, and by combining public and private members."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'class CoffeeMachine {\n  #waterLevel; // Private property\n\n  constructor() {\n    this.#waterLevel = 0;\n  }\n\n  fillWater(amount) {\n    this.#waterLevel += amount;\n    console.log(`Water level: ${this.#waterLevel}`);\n  }\n\n  brewCoffee() {\n    if (this.#waterLevel > 0) {\n      console.log("Brewing coffee...");\n      this.#waterLevel -= 1;\n    } else {\n      console.log("Not enough water");\n    }\n  }\n}\n\nconst machine = new CoffeeMachine();\nmachine.fillWater(2); // Output: Water level: 2\nmachine.brewCoffee(); // Output: Brewing coffee...\n'})}),"\n",(0,t.jsx)(e.h2,{id:"pillars-of-oop",children:"Pillars of OOP"}),"\n",(0,t.jsx)(e.p,{children:"The following are the four main principles (pillars) of Object-Oriented Programming:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Encapsulation"}),": Bundling data and methods into a single unit and restricting access to some parts."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Abstraction"}),": Hiding implementation details and exposing only essential functionality."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Inheritance"}),": Reusing code by deriving new classes from existing ones."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Polymorphism"}),": Allowing the same interface to be used for different types."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"features-of-oop-in-javascript",children:"Features of OOP in JavaScript"}),"\n",(0,t.jsx)(e.h3,{id:"constructor-functions-pre-es6",children:"Constructor Functions (Pre-ES6)"}),"\n",(0,t.jsx)(e.p,{children:"Before ES6, JavaScript used constructor functions to create objects."}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'function Car(brand, model) {\n  this.brand = brand;\n  this.model = model;\n}\n\nCar.prototype.start = function () {\n  console.log(`${this.brand} ${this.model} is starting`);\n};\n\nconst myCar = new Car("Toyota", "Camry");\nmyCar.start(); // Output: Toyota Camry is starting\n'})}),"\n",(0,t.jsx)(e.h3,{id:"prototypal-inheritance",children:"Prototypal Inheritance"}),"\n",(0,t.jsxs)(e.p,{children:["JavaScript is a prototype-based language. Every object in JavaScript has an internal ",(0,t.jsx)(e.code,{children:"[[Prototype]]"})," property that refers to another object from which it can inherit properties and methods."]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Example:"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-javascript",children:'const animal = {\n  eats: true,\n  walk() {\n    console.log("Animal walks");\n  },\n};\n\nconst dog = Object.create(animal); // Create an object inheriting from `animal`\ndog.barks = true;\n\nconsole.log(dog.eats); // Output: true (inherited from `animal`)\ndog.walk(); // Output: Animal walks\n'})}),"\n",(0,t.jsx)(e.h3,{id:"es6-classes",children:"ES6 Classes"}),"\n",(0,t.jsxs)(e.p,{children:["With ES6, JavaScript introduced the ",(0,t.jsx)(e.code,{children:"class"})," syntax, which simplifies the creation of objects and inheritance."]}),"\n",(0,t.jsx)(e.h2,{id:"advantages-of-oop",children:"Advantages of OOP"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Code Reusability"}),": Inheritance allows reusing existing code."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Scalability"}),": OOP makes it easier to manage large applications."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Maintainability"}),": Encapsulation ensures better organization of code."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Flexibility"}),": Polymorphism makes code flexible and extensible."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"disadvantages-of-oop",children:"Disadvantages of OOP"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Complexity"}),": OOP can introduce unnecessary complexity for small programs."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Performance Overhead"}),": The use of objects and inheritance can sometimes add overhead."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Learning Curve"}),": Understanding OOP concepts like inheritance and polymorphism can be challenging for beginners."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"oop-vs-functional-programming",children:"OOP vs. Functional Programming"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:(0,t.jsx)(e.strong,{children:"Aspect"})}),(0,t.jsx)(e.th,{children:(0,t.jsx)(e.strong,{children:"OOP"})}),(0,t.jsx)(e.th,{children:(0,t.jsx)(e.strong,{children:"Functional Programming"})})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"State Management"})}),(0,t.jsx)(e.td,{children:"Uses objects to manage state."}),(0,t.jsx)(e.td,{children:"Uses immutable data and pure functions."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Code Structure"})}),(0,t.jsx)(e.td,{children:"Organized around classes and objects."}),(0,t.jsx)(e.td,{children:"Organized around functions and composition."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Reusability"})}),(0,t.jsx)(e.td,{children:"Achieved through inheritance."}),(0,t.jsx)(e.td,{children:"Achieved through higher-order functions."})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Suitability"})}),(0,t.jsx)(e.td,{children:"Best for modeling real-world entities."}),(0,t.jsx)(e.td,{children:"Best for tasks involving data transformation."})]})]})]}),"\n",(0,t.jsx)(e.h2,{id:"real-world-use-cases",children:"Real-World Use Cases"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Game Development"}),": OOP is used to model entities like players, enemies, and game levels."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"UI Frameworks"}),": Libraries like React use OOP concepts to manage components."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Backend Development"}),": OOP is commonly used in frameworks like Django, Ruby on Rails, and Spring."]}),"\n"]})]})}function h(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,e,s)=>{s.d(e,{R:()=>r,x:()=>o});var a=s(6540);const t={},i=a.createContext(t);function r(n){const e=a.useContext(i);return a.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);