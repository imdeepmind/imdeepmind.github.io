"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[294],{24756:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"data-structure-and-algorithms/algorithms/tree/tree-traversal","title":"Binary Tree Traversals","description":"Traversal refers to visiting each node of a binary tree exactly once in a systematic way.","source":"@site/docs/data-structure-and-algorithms/algorithms/tree/tree-traversal.md","sourceDirName":"data-structure-and-algorithms/algorithms/tree","slug":"/data-structure-and-algorithms/algorithms/tree/tree-traversal","permalink":"/docs/data-structure-and-algorithms/algorithms/tree/tree-traversal","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/data-structure-and-algorithms/algorithms/tree/tree-traversal.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1755188501000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"tutorialSidebar","previous":{"title":"Strict vs Complete Binary Tree","permalink":"/docs/data-structure-and-algorithms/algorithms/tree/strict-vs-complete-binary-tree"},"next":{"title":"Common Tree Algorithms","permalink":"/docs/data-structure-and-algorithms/algorithms/tree/common-algorithms"}}');var s=t(74848),i=t(28453);const l={sidebar_position:8},d="Binary Tree Traversals",o={},a=[{value:"Depth-First Traversals (DFS)",id:"depth-first-traversals-dfs",level:2},{value:"In-order Traversal (LNR)",id:"in-order-traversal-lnr",level:3},{value:"Pre-order Traversal (NLR)",id:"pre-order-traversal-nlr",level:3},{value:"Post-order Traversal (LRN)",id:"post-order-traversal-lrn",level:3},{value:"Breadth-First Traversal (BFS)",id:"breadth-first-traversal-bfs",level:2},{value:"Level-order Traversal",id:"level-order-traversal",level:3},{value:"Complexity Analysis",id:"complexity-analysis",level:2},{value:"Key Points to Remember",id:"key-points-to-remember",level:2}];function h(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"binary-tree-traversals",children:"Binary Tree Traversals"})}),"\n",(0,s.jsx)(r.p,{children:"Traversal refers to visiting each node of a binary tree exactly once in a systematic way."}),"\n",(0,s.jsx)(r.p,{children:"There are two main categories:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Depth-First Traversal (DFS): In-order, Pre-order, Post-order"}),"\n",(0,s.jsx)(r.li,{children:"Breadth-First Traversal (BFS): Level-order"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"depth-first-traversals-dfs",children:"Depth-First Traversals (DFS)"}),"\n",(0,s.jsx)(r.p,{children:"DFS visits nodes as far as possible along each branch before backtracking."}),"\n",(0,s.jsx)(r.h3,{id:"in-order-traversal-lnr",children:"In-order Traversal (LNR)"}),"\n",(0,s.jsx)(r.p,{children:"Order:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Visit Left subtree"}),"\n",(0,s.jsx)(r.li,{children:"Visit Node"}),"\n",(0,s.jsx)(r.li,{children:"Visit Right subtree"}),"\n"]}),"\n",(0,s.jsx)("div",{style:{textAlign:"center"},children:(0,s.jsx)(r.mermaid,{value:"graph TD\n    A[1] --\x3e B[2]\n    A --\x3e C[3]\n    B --\x3e D[4]\n    B --\x3e E[5]\n    C --\x3e F[6]\n    C --\x3e G[7]"})}),"\n",(0,s.jsx)(r.p,{children:"Example for In-order: 4, 2, 5, 1, 6, 3, 7"}),"\n",(0,s.jsx)(r.p,{children:"Python Code"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\ndef inorder(root):\n    if root:\n        inorder(root.left)   # Step 1: Left\n        print(root.key, end=" ")  # Step 2: Node\n        inorder(root.right)  # Step 3: Right\n\n# Example usage\nroot = Node(1)\nroot.left = Node(2)\nroot.right = Node(3)\nroot.left.left = Node(4)\nroot.left.right = Node(5)\nroot.right.left = Node(6)\nroot.right.right = Node(7)\n\ninorder(root)\n'})}),"\n",(0,s.jsx)(r.h3,{id:"pre-order-traversal-nlr",children:"Pre-order Traversal (NLR)"}),"\n",(0,s.jsx)(r.p,{children:"Order:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Visit Node"}),"\n",(0,s.jsx)(r.li,{children:"Visit Left subtree"}),"\n",(0,s.jsx)(r.li,{children:"Visit Right subtree"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Example: 1, 2, 4, 5, 3, 6, 7"}),"\n",(0,s.jsx)(r.p,{children:"Python Code"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'def preorder(root):\n    if root:\n        print(root.key, end=" ")  # Step 1: Node\n        preorder(root.left)       # Step 2: Left\n        preorder(root.right)      # Step 3: Right\n\npreorder(root)\n'})}),"\n",(0,s.jsx)(r.h3,{id:"post-order-traversal-lrn",children:"Post-order Traversal (LRN)"}),"\n",(0,s.jsx)(r.p,{children:"Order:"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Visit Left subtree"}),"\n",(0,s.jsx)(r.li,{children:"Visit Right subtree"}),"\n",(0,s.jsx)(r.li,{children:"Visit Node"}),"\n"]}),"\n",(0,s.jsx)(r.p,{children:"Example: 4, 5, 2, 6, 7, 3, 1"}),"\n",(0,s.jsx)(r.p,{children:"Python Code"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'def postorder(root):\n    if root:\n        postorder(root.left)   # Step 1: Left\n        postorder(root.right)  # Step 2: Right\n        print(root.key, end=" ")  # Step 3: Node\n\npostorder(root)\n'})}),"\n",(0,s.jsx)(r.h2,{id:"breadth-first-traversal-bfs",children:"Breadth-First Traversal (BFS)"}),"\n",(0,s.jsx)(r.h3,{id:"level-order-traversal",children:"Level-order Traversal"}),"\n",(0,s.jsx)(r.p,{children:"Order: Visit nodes level by level from left to right."}),"\n",(0,s.jsx)("div",{style:{textAlign:"center"},children:(0,s.jsx)(r.mermaid,{value:"graph TD\n    A[1] --\x3e B[2]\n    A --\x3e C[3]\n    B --\x3e D[4]\n    B --\x3e E[5]\n    C --\x3e F[6]\n    C --\x3e G[7]"})}),"\n",(0,s.jsx)(r.p,{children:"Level-order result: 1, 2, 3, 4, 5, 6, 7"}),"\n",(0,s.jsx)(r.p,{children:"Python Code"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:'from collections import deque\n\ndef level_order(root):\n    if not root:\n        return\n    queue = deque([root])\n    while queue:\n        node = queue.popleft()\n        print(node.key, end=" ")\n        if node.left:\n            queue.append(node.left)\n        if node.right:\n            queue.append(node.right)\n\nlevel_order(root)\n'})}),"\n",(0,s.jsx)(r.h2,{id:"complexity-analysis",children:"Complexity Analysis"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Traversal Type"}),(0,s.jsx)(r.th,{children:"Time Complexity"}),(0,s.jsx)(r.th,{children:"Space Complexity (worst case)"}),(0,s.jsx)(r.th,{children:"Space Complexity (best case)"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"In-order"}),(0,s.jsx)(r.td,{children:"O(n)"}),(0,s.jsx)(r.td,{children:"O(h) recursion stack"}),(0,s.jsx)(r.td,{children:"O(1) for skewed tree"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Pre-order"}),(0,s.jsx)(r.td,{children:"O(n)"}),(0,s.jsx)(r.td,{children:"O(h) recursion stack"}),(0,s.jsx)(r.td,{children:"O(1) for skewed tree"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Post-order"}),(0,s.jsx)(r.td,{children:"O(n)"}),(0,s.jsx)(r.td,{children:"O(h) recursion stack"}),(0,s.jsx)(r.td,{children:"O(1) for skewed tree"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Level-order"}),(0,s.jsx)(r.td,{children:"O(n)"}),(0,s.jsx)(r.td,{children:"O(n) queue"}),(0,s.jsx)(r.td,{children:"O(1) if tree has only root"})]})]})]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"n = number of nodes"}),"\n",(0,s.jsx)(r.li,{children:"h = height of the tree"}),"\n",(0,s.jsx)(r.li,{children:"Recursion space complexity applies only to DFS traversals. BFS uses a queue."}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"key-points-to-remember",children:"Key Points to Remember"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"In-order is mainly used for Binary Search Trees to get sorted order."}),"\n",(0,s.jsx)(r.li,{children:"Pre-order is used for tree cloning or serialization."}),"\n",(0,s.jsx)(r.li,{children:"Post-order is used for deleting/freeing nodes."}),"\n",(0,s.jsx)(r.li,{children:"Level-order is used for shortest path in unweighted trees and printing level-wise data."}),"\n"]})]})}function c(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},28453:(e,r,t)=>{t.d(r,{R:()=>l,x:()=>d});var n=t(96540);const s={},i=n.createContext(s);function l(e){const r=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);