"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[9073],{50985:(n,s,e)=>{e.r(s),e.d(s,{assets:()=>l,contentTitle:()=>t,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"frameworks-libraries/backend/flask/async-flask","title":"Async in Flask","description":"Flask is a popular lightweight web framework for building web applications in Python. Traditionally, Flask operates in a synchronous manner, where each request is handled one at a time, blocking the server until the request is processed and a response is returned. However, with the growing need for handling concurrent requests more efficiently (especially for I/O-bound tasks like database queries, file uploads, or network calls), Flask has started supporting asynchronous programming. This allows for non-blocking I/O operations, leading to better performance under heavy load, especially when dealing with concurrent requests.","source":"@site/docs/frameworks-libraries/backend/flask/async-flask.md","sourceDirName":"frameworks-libraries/backend/flask","slug":"/frameworks-libraries/backend/flask/async-flask","permalink":"/docs/frameworks-libraries/backend/flask/async-flask","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/frameworks-libraries/backend/flask/async-flask.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1749212834000,"sidebarPosition":12,"frontMatter":{"sidebar_position":12},"sidebar":"tutorialSidebar","previous":{"title":"Database Integration and Flask-SQLAlchemy","permalink":"/docs/frameworks-libraries/backend/flask/database-integration"},"next":{"title":"Deployment and Scaling","permalink":"/docs/frameworks-libraries/backend/flask/deployment"}}');var r=e(74848),i=e(28453);const o={sidebar_position:12},t="Async in Flask",l={},c=[{value:"Introduction to Async Programming in Flask",id:"introduction-to-async-programming-in-flask",level:2},{value:"Synchronous vs. Asynchronous",id:"synchronous-vs-asynchronous",level:3},{value:"Flask&#39;s Support for Async Programming",id:"flasks-support-for-async-programming",level:2},{value:"Key Features",id:"key-features",level:3},{value:"Defining Asynchronous View Functions",id:"defining-asynchronous-view-functions",level:2},{value:"Basic Example of an Async View Function",id:"basic-example-of-an-async-view-function",level:3},{value:"Important Notes",id:"important-notes",level:3},{value:"Running Asynchronous Tasks in Flask",id:"running-asynchronous-tasks-in-flask",level:2},{value:"Example: Using <code>aiohttp</code> for Asynchronous HTTP Requests",id:"example-using-aiohttp-for-asynchronous-http-requests",level:3},{value:"Working with Asynchronous Databases",id:"working-with-asynchronous-databases",level:2},{value:"Example: Using Async with <code>Databases</code> Library",id:"example-using-async-with-databases-library",level:3},{value:"Running Flask Asynchronously with <code>asyncio</code>",id:"running-flask-asynchronously-with-asyncio",level:2},{value:"Running Flask Asynchronously with Uvicorn",id:"running-flask-asynchronously-with-uvicorn",level:3},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:2},{value:"Flask&#39;s Threaded Model",id:"flasks-threaded-model",level:3},{value:"Asynchronous Database Support",id:"asynchronous-database-support",level:3},{value:"Flask Extensions Compatibility",id:"flask-extensions-compatibility",level:3},{value:"Complexity",id:"complexity",level:3}];function h(n){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"async-in-flask",children:"Async in Flask"})}),"\n",(0,r.jsx)(s.p,{children:"Flask is a popular lightweight web framework for building web applications in Python. Traditionally, Flask operates in a synchronous manner, where each request is handled one at a time, blocking the server until the request is processed and a response is returned. However, with the growing need for handling concurrent requests more efficiently (especially for I/O-bound tasks like database queries, file uploads, or network calls), Flask has started supporting asynchronous programming. This allows for non-blocking I/O operations, leading to better performance under heavy load, especially when dealing with concurrent requests."}),"\n",(0,r.jsxs)(s.p,{children:["In this detailed note, we will explore how asynchronous programming works in Flask, how to use ",(0,r.jsx)(s.code,{children:"async"})," and ",(0,r.jsx)(s.code,{children:"await"}),", and the integration of Flask with asynchronous tools."]}),"\n",(0,r.jsx)(s.h2,{id:"introduction-to-async-programming-in-flask",children:"Introduction to Async Programming in Flask"}),"\n",(0,r.jsx)(s.h3,{id:"synchronous-vs-asynchronous",children:"Synchronous vs. Asynchronous"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Synchronous (Blocking)"}),": Each request is handled sequentially, blocking the server's ability to handle other requests while waiting for I/O operations (such as database queries or API calls) to complete."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Asynchronous (Non-blocking)"}),": Requests can be handled concurrently, allowing the server to process other requests while waiting for I/O operations to finish. This improves the application's throughput and responsiveness."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["Flask's default behavior is synchronous, meaning each HTTP request blocks the thread until it is fully processed and a response is returned. However, with the introduction of ",(0,r.jsxs)(s.strong,{children:[(0,r.jsx)(s.code,{children:"async"}),"/",(0,r.jsx)(s.code,{children:"await"})]}),", Python allows for asynchronous execution, which can be beneficial for Flask applications, especially for I/O-bound operations."]}),"\n",(0,r.jsx)(s.h2,{id:"flasks-support-for-async-programming",children:"Flask's Support for Async Programming"}),"\n",(0,r.jsxs)(s.p,{children:["Flask 2.0 introduced asynchronous view functions, allowing Flask to handle asynchronous requests. This is based on Python's ",(0,r.jsx)(s.code,{children:"asyncio"})," framework, which provides a single-threaded event loop for concurrent tasks."]}),"\n",(0,r.jsx)(s.h3,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Async View Functions"}),": Flask allows you to define view functions as asynchronous functions using the ",(0,r.jsx)(s.code,{children:"async def"})," syntax."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Asynchronous Database and I/O Operations"}),": Flask can work with asynchronous libraries for tasks like database queries, file I/O, and external API calls, preventing blocking."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.strong,{children:"Async Support in Flask Extensions"}),": While not all Flask extensions are fully asynchronous, some (such as ",(0,r.jsx)(s.strong,{children:"Flask-SQLAlchemy"})," with SQLAlchemy 1.4+, ",(0,r.jsx)(s.strong,{children:"aiohttp"}),", and ",(0,r.jsx)(s.strong,{children:"Asyncio"}),") are compatible with asynchronous operations."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"defining-asynchronous-view-functions",children:"Defining Asynchronous View Functions"}),"\n",(0,r.jsxs)(s.p,{children:["In Flask 2.0 and beyond, you can define view functions as asynchronous using the ",(0,r.jsx)(s.code,{children:"async def"})," syntax. These asynchronous functions allow Flask to yield control back to the event loop while waiting for I/O-bound tasks, enabling Flask to handle other requests."]}),"\n",(0,r.jsx)(s.h3,{id:"basic-example-of-an-async-view-function",children:"Basic Example of an Async View Function"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"from flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route('/async')\r\nasync def async_view():\r\n    await some_async_function()  # Simulate an async operation like I/O or network call\r\n    return 'This is an async response'\r\n\r\nasync def some_async_function():\r\n    # Simulate an async task (like a database query or API request)\r\n    await asyncio.sleep(2)  # Simulating a delay\r\n    return \"Task Complete\"\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\n"})}),"\n",(0,r.jsx)(s.p,{children:"In this example:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"async def"})," keyword is used to define the view function ",(0,r.jsx)(s.code,{children:"async_view"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["The ",(0,r.jsx)(s.code,{children:"await"})," keyword is used to call an asynchronous function (",(0,r.jsx)(s.code,{children:"some_async_function"}),"), which mimics a time-consuming operation (like waiting for a response from a remote API)."]}),"\n"]}),"\n",(0,r.jsxs)(s.p,{children:["When the request is made to ",(0,r.jsx)(s.code,{children:"/async"}),", the server can handle other requests while waiting for ",(0,r.jsx)(s.code,{children:"some_async_function()"})," to complete."]}),"\n",(0,r.jsx)(s.h3,{id:"important-notes",children:"Important Notes"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"await"})," can only be used inside ",(0,r.jsx)(s.code,{children:"async"})," functions."]}),"\n",(0,r.jsxs)(s.li,{children:["Flask uses ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"asyncio"})}),", which provides the event loop that handles asynchronous tasks, but Flask's own request/response cycle remains synchronous unless explicitly handled asynchronously."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"running-asynchronous-tasks-in-flask",children:"Running Asynchronous Tasks in Flask"}),"\n",(0,r.jsx)(s.p,{children:"You can use asynchronous libraries or frameworks to handle long-running or blocking tasks without blocking the server's main thread. Common examples include making asynchronous HTTP requests or querying an asynchronous database."}),"\n",(0,r.jsxs)(s.h3,{id:"example-using-aiohttp-for-asynchronous-http-requests",children:["Example: Using ",(0,r.jsx)(s.code,{children:"aiohttp"})," for Asynchronous HTTP Requests"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:"import aiohttp\r\nimport asyncio\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route('/async-request')\r\nasync def async_request():\r\n    async with aiohttp.ClientSession() as session:\r\n        async with session.get('https://jsonplaceholder.typicode.com/todos/1') as response:\r\n            data = await response.json()\r\n            return f'Fetched data: {data}'\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\n"})}),"\n",(0,r.jsx)(s.p,{children:"In this example:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["We use ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"aiohttp"})}),", a library for making asynchronous HTTP requests, which is designed to work with ",(0,r.jsx)(s.code,{children:"async"})," and ",(0,r.jsx)(s.code,{children:"await"}),"."]}),"\n",(0,r.jsxs)(s.li,{children:["When a user visits ",(0,r.jsx)(s.code,{children:"/async-request"}),", the Flask server doesn't block the main thread while waiting for the HTTP request to complete; other requests can still be processed."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"working-with-asynchronous-databases",children:"Working with Asynchronous Databases"}),"\n",(0,r.jsxs)(s.p,{children:["Flask's synchronous database libraries, such as ",(0,r.jsx)(s.strong,{children:"Flask-SQLAlchemy"}),", don't natively support asynchronous execution. However, you can integrate Flask with asynchronous databases by using libraries like ",(0,r.jsx)(s.strong,{children:"Databases"})," or ",(0,r.jsx)(s.strong,{children:"Tortoise ORM"})," (for async database models)."]}),"\n",(0,r.jsxs)(s.h3,{id:"example-using-async-with-databases-library",children:["Example: Using Async with ",(0,r.jsx)(s.code,{children:"Databases"})," Library"]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"pip install databases asyncpg\n"})}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-python",children:'import databases\r\nfrom flask import Flask\r\n\r\nDATABASE_URL = "postgresql://user:password@localhost/mydatabase"\r\ndatabase = databases.Database(DATABASE_URL)\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/async-db\')\r\nasync def async_db():\r\n    query = "SELECT * FROM my_table"\r\n    result = await database.fetch_all(query)\r\n    return {\'data\': result}\r\n\r\nif __name__ == "__main__":\r\n    app.run(debug=True)\n'})}),"\n",(0,r.jsx)(s.p,{children:"In this example:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["We use the ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"databases"})})," library, which is an async database query library compatible with ",(0,r.jsx)(s.strong,{children:"SQLAlchemy"})," or ",(0,r.jsx)(s.strong,{children:"PostgreSQL"}),"."]}),"\n",(0,r.jsx)(s.li,{children:"The query execution is asynchronous, allowing Flask to process other requests while waiting for the database query to complete."}),"\n"]}),"\n",(0,r.jsxs)(s.h2,{id:"running-flask-asynchronously-with-asyncio",children:["Running Flask Asynchronously with ",(0,r.jsx)(s.code,{children:"asyncio"})]}),"\n",(0,r.jsxs)(s.p,{children:["Flask itself is not fully asynchronous by default, but you can run the app in an asynchronous event loop using ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"asyncio"})})," and asynchronous web servers, such as ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.code,{children:"uvicorn"})}),"."]}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:"pip install uvicorn\n"})}),"\n",(0,r.jsx)(s.h3,{id:"running-flask-asynchronously-with-uvicorn",children:"Running Flask Asynchronously with Uvicorn"}),"\n",(0,r.jsx)(s.pre,{children:(0,r.jsx)(s.code,{className:"language-bash",children:'import asyncio\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\n@app.route(\'/async\')\r\nasync def async_view():\r\n    await asyncio.sleep(2)  # Simulating async task\r\n    return "Async Response"\r\n\r\nif __name__ == "__main__":\r\n    import uvicorn\r\n    uvicorn.run(app, host="0.0.0.0", port=5000)\n'})}),"\n",(0,r.jsx)(s.p,{children:"In this example:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Flask is run with ",(0,r.jsx)(s.strong,{children:"Uvicorn"}),", an ASGI (Asynchronous Server Gateway Interface) server that supports asynchronous I/O, allowing Flask to handle asynchronous requests."]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.code,{children:"asyncio.sleep(2)"})," simulates a delay (such as waiting for an external resource or a slow I/O operation)."]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,r.jsx)(s.h3,{id:"flasks-threaded-model",children:"Flask's Threaded Model"}),"\n",(0,r.jsxs)(s.p,{children:["Flask has a ",(0,r.jsx)(s.strong,{children:"threaded model"})," that allows handling multiple requests concurrently by using threads. This works well for synchronous applications. However, asynchronous programming in Flask requires an event loop (e.g., ",(0,r.jsx)(s.code,{children:"asyncio"}),"), which may require additional setup and integration with an ASGI server (like ",(0,r.jsx)(s.code,{children:"uvicorn"})," or ",(0,r.jsx)(s.code,{children:"hypercorn"}),")."]}),"\n",(0,r.jsx)(s.h3,{id:"asynchronous-database-support",children:"Asynchronous Database Support"}),"\n",(0,r.jsxs)(s.p,{children:["Many common Flask database extensions (such as ",(0,r.jsx)(s.strong,{children:"Flask-SQLAlchemy"}),") are synchronous and don't natively support asynchronous operations. However, you can use asynchronous libraries like ",(0,r.jsx)(s.strong,{children:"Tortoise ORM"})," or ",(0,r.jsx)(s.strong,{children:"Databases"})," for async database operations."]}),"\n",(0,r.jsx)(s.h3,{id:"flask-extensions-compatibility",children:"Flask Extensions Compatibility"}),"\n",(0,r.jsx)(s.p,{children:"Not all Flask extensions support asynchronous programming. Extensions that rely on blocking I/O may not perform well in an async environment. It's important to verify whether the Flask extensions you're using are compatible with async programming."}),"\n",(0,r.jsx)(s.h3,{id:"complexity",children:"Complexity"}),"\n",(0,r.jsx)(s.p,{children:"While async programming can improve performance for I/O-bound tasks, it introduces complexity to the codebase. If the application relies heavily on blocking I/O (such as CPU-bound tasks), the overhead of async programming might not provide significant performance improvements."})]})}function d(n={}){const{wrapper:s}={...(0,i.R)(),...n.components};return s?(0,r.jsx)(s,{...n,children:(0,r.jsx)(h,{...n})}):h(n)}},28453:(n,s,e)=>{e.d(s,{R:()=>o,x:()=>t});var a=e(96540);const r={},i=a.createContext(r);function o(n){const s=a.useContext(i);return a.useMemo((function(){return"function"==typeof n?n(s):{...s,...n}}),[s,n])}function t(n){let s;return s=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:o(n.components),a.createElement(i.Provider,{value:s},n.children)}}}]);