"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[222],{91712:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"frameworks-libraries/fastapi/serialization-validation","title":"Serialization and Validation","description":"FastAPI is a modern, fast (hence the name) web framework for building APIs in Python. One of its core features is Pydantic, which is used for data validation and serialization. FastAPI leverages Pydantic to ensure that data passed to your application is valid and structured correctly. Let\u2019s dive deeper into the key concepts: Pydantic Models, Data Validation, Response Models, Nested Models, and Custom Validators.","source":"@site/docs/frameworks-libraries/fastapi/serialization-validation.md","sourceDirName":"frameworks-libraries/fastapi","slug":"/frameworks-libraries/fastapi/serialization-validation","permalink":"/docs/frameworks-libraries/fastapi/serialization-validation","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/frameworks-libraries/fastapi/serialization-validation.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1744216072000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Routes","permalink":"/docs/frameworks-libraries/fastapi/routes"},"next":{"title":"Dependency Injection","permalink":"/docs/frameworks-libraries/fastapi/dependency-injection"}}');var i=a(74848),t=a(28453);const r={sidebar_position:3},l="Serialization and Validation",d={},o=[{value:"Pydantic Models",id:"pydantic-models",level:2},{value:"Example: Basic Pydantic Model",id:"example-basic-pydantic-model",level:3},{value:"Data Validation",id:"data-validation",level:2},{value:"Example: Automatic Data Validation",id:"example-automatic-data-validation",level:3},{value:"Example Request (Invalid JSON)",id:"example-request-invalid-json",level:3},{value:"Response (Error Message)",id:"response-error-message",level:3},{value:"Response Models",id:"response-models",level:2},{value:"Example: Using Response Models",id:"example-using-response-models",level:3},{value:"Example Response:",id:"example-response",level:3},{value:"Nested Models",id:"nested-models",level:2},{value:"Example: Nested Models",id:"example-nested-models",level:3},{value:"Example Request (JSON)",id:"example-request-json",level:3},{value:"Example Response (JSON)",id:"example-response-json",level:3},{value:"Custom Validators",id:"custom-validators",level:2},{value:"Example: Using Custom Validators",id:"example-using-custom-validators",level:3},{value:"Example Request (Invalid JSON)",id:"example-request-invalid-json-1",level:3},{value:"Response (Error Message)",id:"response-error-message-1",level:3},{value:"Additional Validator Example: String Length Validation",id:"additional-validator-example-string-length-validation",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"serialization-and-validation",children:"Serialization and Validation"})}),"\n",(0,i.jsxs)(n.p,{children:["FastAPI is a modern, fast (hence the name) web framework for building APIs in Python. One of its core features is ",(0,i.jsx)(n.strong,{children:"Pydantic"}),", which is used for data validation and serialization. FastAPI leverages Pydantic to ensure that data passed to your application is valid and structured correctly. Let\u2019s dive deeper into the key concepts: ",(0,i.jsx)(n.strong,{children:"Pydantic Models"}),", ",(0,i.jsx)(n.strong,{children:"Data Validation"}),", ",(0,i.jsx)(n.strong,{children:"Response Models"}),", ",(0,i.jsx)(n.strong,{children:"Nested Models"}),", and ",(0,i.jsx)(n.strong,{children:"Custom Validators"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"pydantic-models",children:"Pydantic Models"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pydantic"})," is a data validation and parsing library that FastAPI uses to define and validate the structure of the data, both for incoming requests (body, query parameters, etc.) and outgoing responses."]}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"Pydantic model"})," is a class that inherits from ",(0,i.jsx)(n.code,{children:"pydantic.BaseModel"}),". These models define the shape of the data and automatically perform validation based on the types and constraints you specify."]}),"\n",(0,i.jsx)(n.h3,{id:"example-basic-pydantic-model",children:"Example: Basic Pydantic Model"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from pydantic import BaseModel\n\nclass Item(BaseModel):\n    name: str\n    description: str = None\n    price: float\n    tax: float = None\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Attributes"}),": The attributes ",(0,i.jsx)(n.code,{children:"name"}),", ",(0,i.jsx)(n.code,{children:"description"}),", ",(0,i.jsx)(n.code,{children:"price"}),", and ",(0,i.jsx)(n.code,{children:"tax"})," define the structure of an item."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Type Validation"}),": FastAPI uses Python's type annotations to validate the data. For example, ",(0,i.jsx)(n.code,{children:"name: str"})," ensures the ",(0,i.jsx)(n.code,{children:"name"})," is a string, and ",(0,i.jsx)(n.code,{children:"price: float"})," ensures the ",(0,i.jsx)(n.code,{children:"price"})," is a floating-point number."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Optional Fields"}),": ",(0,i.jsx)(n.code,{children:"description"})," and ",(0,i.jsx)(n.code,{children:"tax"})," are optional, as they have default values of ",(0,i.jsx)(n.code,{children:"None"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-validation",children:"Data Validation"}),"\n",(0,i.jsxs)(n.p,{children:["One of the primary benefits of using Pydantic models in FastAPI is automatic ",(0,i.jsx)(n.strong,{children:"data validation"}),". When a request body is passed to a FastAPI endpoint, FastAPI will validate it against the Pydantic model. If the data doesn't match the expected structure, FastAPI will return an error with a detailed message."]}),"\n",(0,i.jsx)(n.h3,{id:"example-automatic-data-validation",children:"Example: Automatic Data Validation"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from fastapi import FastAPI\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: str = None\n    tax: float = None\n\n@app.post("/items/")\ndef create_item(item: Item):\n    return {"item_name": item.name, "item_price": item.price}\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When a client sends a request to ",(0,i.jsx)(n.code,{children:"POST /items/"})," with invalid data (e.g., missing required fields), FastAPI will return a ",(0,i.jsx)(n.strong,{children:"422 Unprocessable Entity"})," error with details about which fields are missing or invalid."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-request-invalid-json",children:"Example Request (Invalid JSON)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "Laptop"\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"response-error-message",children:"Response (Error Message)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "detail": [\n    {\n      "loc": ["body", "price"],\n      "msg": "field required",\n      "type": "value_error.missing"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["In this case, the ",(0,i.jsx)(n.code,{children:"price"})," field is required but missing, so FastAPI returns a 422 status with an error message indicating the missing field."]}),"\n",(0,i.jsx)(n.h2,{id:"response-models",children:"Response Models"}),"\n",(0,i.jsx)(n.p,{children:"FastAPI allows you to use Pydantic models to return structured data from your endpoints. This ensures that the response data is properly validated and formatted."}),"\n",(0,i.jsx)(n.p,{children:"By default, FastAPI automatically serializes the response to JSON based on the Pydantic model."}),"\n",(0,i.jsx)(n.h3,{id:"example-using-response-models",children:"Example: Using Response Models"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pydantic import BaseModel\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: str = None\n    tax: float = None\n\n@app.post("/items/", response_model=Item)\ndef create_item(item: Item):\n    return item  # Returning the created item as a response\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response Model"}),": By specifying ",(0,i.jsx)(n.code,{children:"response_model=Item"})," in the ",(0,i.jsx)(n.code,{children:"@app.post()"})," decorator, FastAPI will ensure that the response data conforms to the ",(0,i.jsx)(n.code,{children:"Item"})," Pydantic model. This automatically validates and serializes the response before sending it back to the client."]}),"\n",(0,i.jsxs)(n.li,{children:["The response will be a JSON object with the same structure as the ",(0,i.jsx)(n.code,{children:"Item"})," model."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-response",children:"Example Response:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "Laptop",\n  "price": 999.99,\n  "description": "High-end laptop",\n  "tax": 50.99\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"If you return extra or invalid fields in the response, FastAPI will automatically handle them according to the model."}),"\n",(0,i.jsx)(n.h2,{id:"nested-models",children:"Nested Models"}),"\n",(0,i.jsx)(n.p,{children:"Pydantic models can be nested inside other models to represent complex data structures. This is especially useful for representing hierarchical or related data."}),"\n",(0,i.jsx)(n.h3,{id:"example-nested-models",children:"Example: Nested Models"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pydantic import BaseModel\n\nclass Category(BaseModel):\n    name: str\n    description: str\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    category: Category\n\n@app.post("/items/", response_model=Item)\ndef create_item(item: Item):\n    return item\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Nested Model"}),": In this example, the ",(0,i.jsx)(n.code,{children:"Item"})," model contains a nested ",(0,i.jsx)(n.code,{children:"Category"})," model, which itself has ",(0,i.jsx)(n.code,{children:"name"})," and ",(0,i.jsx)(n.code,{children:"description"})," attributes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Automatic Validation"}),": FastAPI will recursively validate the nested model. In this case, it will validate both ",(0,i.jsx)(n.code,{children:"Item"})," and the ",(0,i.jsx)(n.code,{children:"Category"})," nested inside it."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-request-json",children:"Example Request (JSON)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "Laptop",\n  "price": 999.99,\n  "category": {\n    "name": "Electronics",\n    "description": "Devices and gadgets"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"example-response-json",children:"Example Response (JSON)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "Laptop",\n  "price": 999.99,\n  "category": {\n    "name": "Electronics",\n    "description": "Devices and gadgets"\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"custom-validators",children:"Custom Validators"}),"\n",(0,i.jsxs)(n.p,{children:["While Pydantic provides built-in validation for common data types, you can also create ",(0,i.jsx)(n.strong,{children:"custom validators"})," for more complex validation logic. This allows you to ensure that the incoming data meets your application's specific requirements."]}),"\n",(0,i.jsx)(n.h3,{id:"example-using-custom-validators",children:"Example: Using Custom Validators"}),"\n",(0,i.jsxs)(n.p,{children:["You can define custom validation logic using the ",(0,i.jsx)(n.code,{children:"@validator"})," decorator in Pydantic models. Validators allow you to add custom constraints or modify the data before it\u2019s used."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from pydantic import BaseModel, validator\n\nclass Item(BaseModel):\n    name: str\n    price: float\n    description: str = None\n\n    # Custom validator for price\n    @validator("price")\n    def validate_price(cls, value):\n        if value <= 0:\n            raise ValueError("Price must be greater than 0")\n        return value\n\n@app.post("/items/")\ndef create_item(item: Item):\n    return item\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Custom Validator"}),": The ",(0,i.jsx)(n.code,{children:'@validator("price")'})," decorator allows you to define a custom validation function for the ",(0,i.jsx)(n.code,{children:"price"})," field. In this case, it checks that the price is greater than 0. If the validation fails, a ",(0,i.jsx)(n.code,{children:"ValueError"})," is raised, and FastAPI will return a 422 error."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-request-invalid-json-1",children:"Example Request (Invalid JSON)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "name": "Laptop",\n  "price": -999.99\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"response-error-message-1",children:"Response (Error Message)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "detail": [\n    {\n      "loc": ["body", "price"],\n      "msg": "Price must be greater than 0",\n      "type": "value_error"\n    }\n  ]\n}\n'})}),"\n",(0,i.jsx)(n.h3,{id:"additional-validator-example-string-length-validation",children:"Additional Validator Example: String Length Validation"}),"\n",(0,i.jsx)(n.p,{children:"You can also validate string lengths with custom validators."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Item(BaseModel):\n    name: str\n    description: str\n\n    @validator("name")\n    def name_length(cls, value):\n        if len(value) < 3:\n            raise ValueError("Name must be at least 3 characters long")\n        return value\n'})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["This custom validator ensures that the ",(0,i.jsx)(n.code,{children:"name"})," field is at least 3 characters long. If the condition fails, it raises an error."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>l});var s=a(96540);const i={},t=s.createContext(i);function r(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);