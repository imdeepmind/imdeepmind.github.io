"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[3688],{91265:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"networking/protocols/quic","title":"QUIC","description":"QUIC (Quick UDP Internet Connections) is a modern transport layer protocol developed by Google to address the limitations of older protocols like TCP (Transmission Control Protocol) and improve web performance, especially in high-latency and unreliable network conditions. QUIC runs on top of UDP (User Datagram Protocol), which is a connectionless protocol, and provides features typically associated with TCP, such as reliability, flow control, and congestion control, but with lower latency and better performance.","source":"@site/docs/networking/protocols/quic.md","sourceDirName":"networking/protocols","slug":"/networking/protocols/quic","permalink":"/docs/networking/protocols/quic","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/networking/protocols/quic.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1736950153000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"TCP","permalink":"/docs/networking/protocols/tcp"},"next":{"title":"TLS","permalink":"/docs/networking/protocols/tls"}}');var r=t(74848),o=t(28453);const s={sidebar_position:7},a="QUIC",l={},c=[{value:"Key Features of QUIC",id:"key-features-of-quic",level:3},{value:"Connection Establishment Speed",id:"connection-establishment-speed",level:3},{value:"Multiplexing Without Head-of-Line Blocking",id:"multiplexing-without-head-of-line-blocking",level:3},{value:"Built-in Encryption",id:"built-in-encryption",level:3},{value:"Forward Error Correction",id:"forward-error-correction",level:3},{value:"Congestion Control",id:"congestion-control",level:3},{value:"Migration Support",id:"migration-support",level:3},{value:"QUIC Packet Structure",id:"quic-packet-structure",level:2},{value:"QUIC Handshake and Connection Establishment",id:"quic-handshake-and-connection-establishment",level:2},{value:"QUIC Stream Management",id:"quic-stream-management",level:2},{value:"How QUIC Works Internally",id:"how-quic-works-internally",level:2},{value:"Connection Establishment and Encryption",id:"connection-establishment-and-encryption",level:3},{value:"Stream Multiplexing",id:"stream-multiplexing",level:3},{value:"Congestion Control and Flow Management",id:"congestion-control-and-flow-management",level:3},{value:"Reliability and Error Recovery",id:"reliability-and-error-recovery",level:3},{value:"Connection Migration",id:"connection-migration",level:3},{value:"QUIC vs TCP",id:"quic-vs-tcp",level:2},{value:"QUIC Deployment",id:"quic-deployment",level:2}];function d(e){const n={h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"quic",children:"QUIC"})}),"\n",(0,r.jsx)(n.p,{children:"QUIC (Quick UDP Internet Connections) is a modern transport layer protocol developed by Google to address the limitations of older protocols like TCP (Transmission Control Protocol) and improve web performance, especially in high-latency and unreliable network conditions. QUIC runs on top of UDP (User Datagram Protocol), which is a connectionless protocol, and provides features typically associated with TCP, such as reliability, flow control, and congestion control, but with lower latency and better performance."}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-quic",children:"Key Features of QUIC"}),"\n",(0,r.jsx)(n.h3,{id:"connection-establishment-speed",children:"Connection Establishment Speed"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Traditional protocols like TCP require a handshake process that can take multiple round-trip times (RTTs) before data can be transferred. QUIC reduces this by combining the handshake for both the transport and encryption layers."}),"\n",(0,r.jsx)(n.li,{children:"QUIC achieves 0-RTT (zero round-trip time) connection setup, meaning that data can start flowing as soon as the initial handshake completes."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"multiplexing-without-head-of-line-blocking",children:"Multiplexing Without Head-of-Line Blocking"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"In protocols like HTTP/2 over TCP, multiple streams share a single connection. If one stream experiences packet loss, it causes head-of-line blocking, which delays the delivery of packets in other streams."}),"\n",(0,r.jsx)(n.li,{children:"QUIC allows multiplexing multiple streams in parallel, where each stream has its own independent flow. This prevents head-of-line blocking, improving performance."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"built-in-encryption",children:"Built-in Encryption"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC integrates encryption (TLS 1.3) directly into the protocol, which means that all QUIC connections are encrypted by default. This eliminates the need for separate encryption protocols like TLS over TCP, resulting in improved security and reduced latency."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"forward-error-correction",children:"Forward Error Correction"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC can use forward error correction (FEC) to recover from packet loss more efficiently. It enables faster recovery without needing a full retransmission, improving performance in lossy networks."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"congestion-control",children:"Congestion Control"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC implements modern congestion control algorithms like BBR (Bottleneck Bandwidth and Round-trip propagation time) that are better suited for high-speed networks than traditional algorithms like TCP Reno."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"migration-support",children:"Migration Support"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC connections are not tied to a specific IP address or port. This allows the protocol to seamlessly handle network changes (e.g., switching from Wi-Fi to cellular networks) without disconnecting or re-establishing the connection."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quic-packet-structure",children:"QUIC Packet Structure"}),"\n",(0,r.jsx)(n.p,{children:"QUIC packets consist of several components that work together to manage connections, streams, and encryption. The packet structure is more complex than TCP or UDP but is designed for optimized performance."}),"\n",(0,r.jsx)(n.p,{children:"Here's a basic representation of the QUIC packet structure:"}),"\n",(0,r.jsx)("div",{class:"mermaid-container",children:(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[QUIC Packet] --\x3e B[Header]\n    B --\x3e C[Connection ID]\n    B --\x3e D[Packet Number]\n    B --\x3e E[Payload]\n    E --\x3e F[Stream Frame]\n    E --\x3e G[Acknowledgment Frame]\n    E --\x3e H[Padding]"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connection ID"}),": A unique identifier used to identify the connection."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Packet Number"}),": The number that helps to identify the order of the packet and ensures that the receiver can detect lost packets."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Payload"}),": The data being transmitted, which can include stream data (for application data), acknowledgment frames (for confirming received packets), and padding (to align the packet sizes)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quic-handshake-and-connection-establishment",children:"QUIC Handshake and Connection Establishment"}),"\n",(0,r.jsx)(n.p,{children:"In traditional protocols like TCP, the handshake involves three steps: SYN, SYN-ACK, and ACK. QUIC combines transport and cryptographic handshakes, making it faster. Here\u2019s a simplified version of the QUIC handshake:"}),"\n",(0,r.jsx)("div",{class:"mermaid-container",children:(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Server\n\n    Client->>Server: Initial Packet (0-RTT)\n    Server->>Client: Handshake Response\n    Client->>Server: Confirm Handshake\n    Server->>Client: Confirm Encryption and Session Established\n    Client->>Server: Application Data"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Initial Packet (0-RTT)"}),": The client sends the first packet with a previously used encryption key for faster reconnection."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Handshake Response"}),": The server responds with its own public key and other details for encryption."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Confirm Handshake"}),": The client sends confirmation back to the server."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Session Established"}),": Once the handshake completes, encryption is confirmed, and both parties can send application data."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"This reduces the connection setup time compared to traditional TCP handshakes, especially when using the 0-RTT mechanism."}),"\n",(0,r.jsx)(n.h2,{id:"quic-stream-management",children:"QUIC Stream Management"}),"\n",(0,r.jsx)(n.p,{children:"QUIC allows multiple independent streams to be established between the client and server over a single connection. Streams are identified by stream numbers and can be independently sent, acknowledged, and reset. This prevents head-of-line blocking since the loss of one stream doesn\u2019t impact others."}),"\n",(0,r.jsx)("div",{class:"mermaid-container",children:(0,r.jsx)(n.mermaid,{value:"graph TB\n    A[QUIC Connection]\n    A --\x3e B[Stream 1]\n    A --\x3e C[Stream 2]\n    A --\x3e D[Stream 3]\n    B --\x3e E[Stream Frame 1]\n    C --\x3e F[Stream Frame 2]\n    D --\x3e G[Stream Frame 3]"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Streams"}),": Independent channels through which data is transmitted."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stream Frames"}),": Data segments transmitted within each stream."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Each stream can be used for different parts of a web request, such as loading text, images, and JavaScript files simultaneously without affecting each other."}),"\n",(0,r.jsx)(n.h2,{id:"how-quic-works-internally",children:"How QUIC Works Internally"}),"\n",(0,r.jsx)(n.p,{children:"To understand how QUIC functions internally, we need to look at how the protocol handles communication between the client and server, as well as its management of connections, data transfer, and error handling."}),"\n",(0,r.jsx)(n.h3,{id:"connection-establishment-and-encryption",children:"Connection Establishment and Encryption"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC starts with a connection request. If the client has a cached connection ID from a previous session, it sends an initial packet encrypted with that information, enabling a 0-RTT handshake."}),"\n",(0,r.jsx)(n.li,{children:"Both the client and server exchange cryptographic keys during the handshake, with QUIC leveraging TLS 1.3 to secure the data. This happens faster than TCP because QUIC merges the transport and encryption handshakes."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"stream-multiplexing",children:"Stream Multiplexing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"After the connection is established, QUIC uses streams to transfer data. These streams are independent, meaning that packet loss in one stream does not block the transfer of data in other streams."}),"\n",(0,r.jsx)(n.li,{children:"QUIC uses stream IDs to identify each stream, and it maintains separate state for each stream to handle data independently."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"congestion-control-and-flow-management",children:"Congestion Control and Flow Management"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC incorporates modern congestion control mechanisms like BBR (Bottleneck Bandwidth and RTT) to optimize data transmission based on real-time measurements of network conditions. BBR focuses on maximizing throughput without causing excessive delays, unlike traditional TCP congestion algorithms like Reno."}),"\n",(0,r.jsx)(n.li,{children:"QUIC also manages flow control on a per-stream basis. This ensures that each stream gets the appropriate share of network resources without overwhelming the connection."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"reliability-and-error-recovery",children:"Reliability and Error Recovery"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC ensures reliability by using packet acknowledgment and retransmissions. If packets are lost, the receiver sends an acknowledgment frame to request the retransmission of the lost packet."}),"\n",(0,r.jsx)(n.li,{children:"Forward error correction (FEC) is used in QUIC to allow the recovery of lost packets without waiting for retransmissions. This reduces latency in scenarios where packet loss is common."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"connection-migration",children:"Connection Migration"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"QUIC supports connection migration, meaning that if a client switches from one network to another (e.g., from Wi-Fi to cellular), the connection can continue without needing to be re-established. This is possible because QUIC uses connection IDs instead of IP addresses or ports to track active connections."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quic-vs-tcp",children:"QUIC vs TCP"}),"\n",(0,r.jsx)(n.p,{children:"QUIC has several advantages over TCP in terms of performance and efficiency, especially for modern web applications:"}),"\n",(0,r.jsx)("div",{class:"mermaid-container",children:(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant Server\n\n    %% TCP Connection Establishment (With TLS)\n    rect rgba(0, 255, 0, 0.1)\n        Client->>Server: SYN\n        Server->>Client: SYN-ACK\n        Client->>Server: ACK\n    end\n    rect rgba(0, 255, 0, 0.1)\n        Note over Client, Server: TCP requires 3-way handshake (SYN, SYN-ACK, ACK)\n    end\n    rect rgba(255, 255, 0, 0.1)\n        Client->>Server: TLS ClientHello\n        Server->>Client: TLS ServerHello\n        Server->>Client: TLS Certificate\n        Client->>Server: TLS Finished\n        Server->>Client: TLS Finished\n    end\n    rect rgba(255, 255, 0, 0.1)\n        Note over Client, Server: TLS handshake adds additional RTTs before data transfer.\n    end\n\n    %% QUIC Connection Establishment\n    rect rgba(0, 0, 255, 0.1)\n        Client->>Server: Initial Packet (0-RTT)\n        Server->>Client: Handshake Response (Encrypted)\n        Client->>Server: Confirm Handshake\n        Server->>Client: Confirm Encryption and Session Established\n    end\n    rect rgba(0, 0, 255, 0.1)\n        Note over Client, Server: QUIC combines transport and encryption handshake, reducing RTT.\n    end"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Connection Setup"}),": QUIC requires fewer RTTs for connection setup (0-RTT in many cases), while TCP requires 1-3 RTTs."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Multiplexing"}),": QUIC avoids head-of-line blocking, while TCP suffers from it."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Encryption"}),": QUIC has built-in encryption, whereas TCP requires additional layers like TLS/SSL."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Congestion Control"}),": QUIC uses advanced congestion control algorithms like BBR, which outperform TCP\u2019s traditional congestion control methods."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"quic-deployment",children:"QUIC Deployment"}),"\n",(0,r.jsx)(n.p,{children:"QUIC is primarily used by Google, YouTube, and other services that require low-latency connections. It's also the foundation of HTTP/3, the latest version of the HTTP protocol, which runs over QUIC instead of TCP."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(96540);const r={},o=i.createContext(r);function s(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);