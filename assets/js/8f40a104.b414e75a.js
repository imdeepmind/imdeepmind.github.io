"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[5359],{59522:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"databases/database-systems/vector-index","title":"Vector Index","description":"A Vector Index is a specialized data structure used to efficiently search and retrieve vectors, particularly in applications involving high-dimensional data like machine learning, natural language processing (NLP), image search, and recommendation systems. In such systems, data is often represented as vectors (or embeddings), and traditional indexing methods (like inverted indexes) may not work efficiently for high-dimensional spaces. A Vector Index provides a way to efficiently query such data based on similarity, typically using distance metrics like Euclidean distance, cosine similarity, or Manhattan distance.","source":"@site/docs/databases/database-systems/vector-index.md","sourceDirName":"databases/database-systems","slug":"/databases/database-systems/vector-index","permalink":"/docs/databases/database-systems/vector-index","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-systems/vector-index.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1763217424000,"sidebarPosition":14,"frontMatter":{"sidebar_position":14},"sidebar":"tutorialSidebar","previous":{"title":"Inverted Indexes","permalink":"/docs/databases/database-systems/inverted-index"},"next":{"title":"Introduction","permalink":"/docs/containers/introduction"}}');var r=s(74848),t=s(28453);const a={sidebar_position:14},o="Vector Index",d={},c=[{value:"Types of Vector Indexes",id:"types-of-vector-indexes",level:2},{value:"Time and Space Complexity of Vector Index",id:"time-and-space-complexity-of-vector-index",level:2},{value:"Insertion Process for Vector Index",id:"insertion-process-for-vector-index",level:2},{value:"Example: Inserting a Vector into a Vector Index (Using HNSW)",id:"example-inserting-a-vector-into-a-vector-index-using-hnsw",level:3},{value:"Deletion Process for Vector Index",id:"deletion-process-for-vector-index",level:2},{value:"Example: Deleting a Vector from a Vector Index (Using HNSW)",id:"example-deleting-a-vector-from-a-vector-index-using-hnsw",level:3},{value:"Retrieval Process for Vector Index",id:"retrieval-process-for-vector-index",level:2},{value:"Example: Retrieving the Nearest Neighbors (Using HNSW)",id:"example-retrieving-the-nearest-neighbors-using-hnsw",level:3},{value:"Real-World Examples of Vector Indexes",id:"real-world-examples-of-vector-indexes",level:2},{value:"Search Engines",id:"search-engines",level:3},{value:"Recommender Systems",id:"recommender-systems",level:3},{value:"Image Search and Computer Vision",id:"image-search-and-computer-vision",level:3},{value:"Natural Language Processing (NLP)",id:"natural-language-processing-nlp",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"vector-index",children:"Vector Index"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Vector Index"})," is a specialized data structure used to efficiently search and retrieve vectors, particularly in applications involving ",(0,r.jsx)(n.strong,{children:"high-dimensional data"})," like ",(0,r.jsx)(n.strong,{children:"machine learning"}),", ",(0,r.jsx)(n.strong,{children:"natural language processing (NLP)"}),", ",(0,r.jsx)(n.strong,{children:"image search"}),", and ",(0,r.jsx)(n.strong,{children:"recommendation systems"}),". In such systems, data is often represented as ",(0,r.jsx)(n.strong,{children:"vectors"})," (or embeddings), and traditional indexing methods (like inverted indexes) may not work efficiently for high-dimensional spaces. A ",(0,r.jsx)(n.strong,{children:"Vector Index"})," provides a way to efficiently query such data based on similarity, typically using ",(0,r.jsx)(n.strong,{children:"distance metrics"})," like ",(0,r.jsx)(n.strong,{children:"Euclidean distance"}),", ",(0,r.jsx)(n.strong,{children:"cosine similarity"}),", or ",(0,r.jsx)(n.strong,{children:"Manhattan distance"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Vector Index"})," maps ",(0,r.jsx)(n.strong,{children:"vector representations"})," (usually of high-dimensional data) to their corresponding entries in the database, allowing for fast retrieval of similar vectors based on a similarity measure. These indexes are widely used in ",(0,r.jsx)(n.strong,{children:"search engines"}),", ",(0,r.jsx)(n.strong,{children:"recommender systems"}),", ",(0,r.jsx)(n.strong,{children:"image recognition systems"}),", and ",(0,r.jsx)(n.strong,{children:"natural language processing"})," tasks, where items (e.g., documents, images, or products) are represented by vectors in a high-dimensional space."]}),"\n",(0,r.jsx)(n.p,{children:"Common tasks that benefit from vector indexing include:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nearest Neighbor Search (k-NN)"}),": Finding vectors that are closest to a query vector."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Similarity Search"}),": Retrieving items that are most similar to a given item."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cluster Analysis"}),": Grouping similar items together in high-dimensional spaces."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"types-of-vector-indexes",children:"Types of Vector Indexes"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Brute Force Search"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A simple method where all vectors are compared to the query vector, calculating the distance between each vector and the query. Although accurate, this method becomes inefficient as the dataset grows large, particularly in high-dimensional spaces."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tree-Based Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"KD-Tree"}),": A binary tree structure used to partition space into regions, improving search speed by recursively splitting the data along different dimensions. It\u2019s efficient in lower-dimensional spaces but struggles as the dimensionality increases (curse of dimensionality)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ball Tree"}),": A tree-based structure similar to KD-Tree but organizes data into spheres (balls), which can handle higher-dimensional data better than KD-Trees."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cover Tree"}),": A more general tree-based method that works well for high-dimensional spaces and is less sensitive to the curse of dimensionality."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hashing-Based Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Locality Sensitive Hashing (LSH)"}),": A technique used for approximate nearest neighbor search in high-dimensional spaces. LSH maps similar items to the same hash bucket with high probability, allowing for quick searches by reducing the number of candidates to check."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Product Quantization"}),": Used in combination with LSH to reduce the dimensionality of vectors by splitting the vector space into several subspaces and quantizing them independently."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graph-Based Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Navigable Small World Graphs (NSW)"}),": A graph structure used for indexing vectors that can approximate nearest neighbors quickly. It builds a graph where nodes (vectors) are connected based on similarity, and traversal through the graph leads to the nearest neighbors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"HNSW (Hierarchical Navigable Small World)"}),": A more advanced version of NSW that organizes nodes in a hierarchical manner for better scalability and faster search times."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"time-and-space-complexity-of-vector-index",children:"Time and Space Complexity of Vector Index"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Brute Force Search"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(N * D), where ",(0,r.jsx)(n.code,{children:"N"})," is the number of vectors and ",(0,r.jsx)(n.code,{children:"D"})," is the number of dimensions in each vector."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N * D), storing all vectors."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tree-Based Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(log N) for low-dimensional data (e.g., KD-Tree) or O(log N + K) for range queries, where ",(0,r.jsx)(n.code,{children:"N"})," is the number of vectors and ",(0,r.jsx)(n.code,{children:"K"})," is the number of neighbors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N * D), with additional overhead for tree structures."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hashing-Based Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(1) for hashing but with an approximation error depending on the quality of the hash function. The time complexity of finding nearest neighbors is typically O(log N) with locality-sensitive hashing."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N), where ",(0,r.jsx)(n.code,{children:"N"})," is the number of vectors, with overhead for hash functions and quantization."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Graph-Based Indexes"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Time Complexity"}),": O(log N) to O(K), where ",(0,r.jsx)(n.code,{children:"N"})," is the number of vectors and ",(0,r.jsx)(n.code,{children:"K"})," is the number of nearest neighbors."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Space Complexity"}),": O(N * log N) for graph-based indexes like HNSW."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"insertion-process-for-vector-index",children:"Insertion Process for Vector Index"}),"\n",(0,r.jsx)(n.p,{children:"The insertion process involves adding a vector into the index and updating the data structure to include the new vector, ensuring that the index remains optimized for efficient search."}),"\n",(0,r.jsx)(n.h3,{id:"example-inserting-a-vector-into-a-vector-index-using-hnsw",children:"Example: Inserting a Vector into a Vector Index (Using HNSW)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Initial Index"}),": Assume we have a collection of vectors representing documents, and we are using a ",(0,r.jsx)(n.strong,{children:"HNSW (Hierarchical Navigable Small World)"})," index."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Suppose we have vectors ",(0,r.jsx)(n.code,{children:"v1"}),", ",(0,r.jsx)(n.code,{children:"v2"}),", and ",(0,r.jsx)(n.code,{children:"v3"}),", and we want to insert a new vector ",(0,r.jsx)(n.code,{children:"v4"}),"."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Add the New Vector"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The HNSW algorithm will add ",(0,r.jsx)(n.code,{children:"v4"})," by finding its nearest neighbors in the current graph structure and adding connections between ",(0,r.jsx)(n.code,{children:"v4"})," and the most similar vectors based on a similarity measure (e.g., cosine similarity or Euclidean distance)."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Existing Graph (before insertion):\nv1 -- v2 -- v3\n\nNew Vector v4:\nv1 -- v2 -- v3 -- v4 (with nearest connections)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Update the Structure"}),": The HNSW algorithm may adjust the graph to maintain its hierarchical structure, ensuring efficient retrievals for subsequent queries."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Updated Graph (after insertion):\nv1 -- v2 -- v3 -- v4 (with hierarchical neighbors)\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"deletion-process-for-vector-index",children:"Deletion Process for Vector Index"}),"\n",(0,r.jsx)(n.p,{children:"Deletion involves removing a vector from the index and adjusting the index structure accordingly to ensure it remains optimal."}),"\n",(0,r.jsx)(n.h3,{id:"example-deleting-a-vector-from-a-vector-index-using-hnsw",children:"Example: Deleting a Vector from a Vector Index (Using HNSW)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Initial Index"}),": Suppose our index has vectors ",(0,r.jsx)(n.code,{children:"v1"}),", ",(0,r.jsx)(n.code,{children:"v2"}),", ",(0,r.jsx)(n.code,{children:"v3"}),", and ",(0,r.jsx)(n.code,{children:"v4"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsxs)(n.strong,{children:["Delete Vector ",(0,r.jsx)(n.code,{children:"v2"})]}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Find all references to ",(0,r.jsx)(n.code,{children:"v2"})," in the graph structure and remove them."]}),"\n",(0,r.jsxs)(n.li,{children:["Reorganize the graph to ensure efficient neighbor retrieval without ",(0,r.jsx)(n.code,{children:"v2"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Existing Graph (before deletion):\nv1 -- v2 -- v3 -- v4\n\nAfter Deletion:\nv1 -- v3 -- v4 (v2 is removed)\n"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Rebalance the Structure"}),": After removal, the HNSW or other graph-based algorithms may rebalance the graph to maintain the optimal performance for nearest neighbor searches."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"retrieval-process-for-vector-index",children:"Retrieval Process for Vector Index"}),"\n",(0,r.jsx)(n.p,{children:"The retrieval process involves finding the nearest neighbors (most similar vectors) to a query vector. This is done by traversing the index structure, whether it's a tree, hash, or graph-based index."}),"\n",(0,r.jsx)(n.h3,{id:"example-retrieving-the-nearest-neighbors-using-hnsw",children:"Example: Retrieving the Nearest Neighbors (Using HNSW)"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Query Vector"}),": Suppose the query vector ",(0,r.jsx)(n.code,{children:"q"})," is provided, and we want to find the nearest neighbors in our vector index."]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Search Process"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Using the ",(0,r.jsx)(n.strong,{children:"HNSW"})," index, the algorithm will start at the top level of the hierarchical graph and traverse through nodes that are closest to ",(0,r.jsx)(n.code,{children:"q"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"The traversal continues through the hierarchy, pruning the search space to efficiently find the nearest vectors."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Return Nearest Neighbors"}),": The algorithm returns the ",(0,r.jsx)(n.code,{children:"k"})," nearest vectors based on the defined similarity measure (e.g., cosine similarity, Euclidean distance)."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"real-world-examples-of-vector-indexes",children:"Real-World Examples of Vector Indexes"}),"\n",(0,r.jsx)(n.h3,{id:"search-engines",children:"Search Engines"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Google Search"}),": Google uses vector-based indexing to process and rank documents based on the similarity between a search query and indexed documents. Word embeddings (e.g., Word2Vec, GloVe) are used to represent words as vectors, and a vector index helps in quickly retrieving relevant documents."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"recommender-systems",children:"Recommender Systems"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Netflix"})," and ",(0,r.jsx)(n.strong,{children:"Amazon"})," use vector indexing to recommend items (e.g., movies, products) to users. Each item (movie, product) is represented as a vector in a high-dimensional space, and similar items are retrieved using vector-based similarity search."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"image-search-and-computer-vision",children:"Image Search and Computer Vision"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Google Image Search"}),": Images are indexed using ",(0,r.jsx)(n.strong,{children:"feature vectors"}),", where each image is represented by a vector of its features (e.g., color histograms, texture). Vector indexes allow efficient retrieval of images that are similar to a given query image."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"natural-language-processing-nlp",children:"Natural Language Processing (NLP)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Word Embeddings"}),": Techniques like ",(0,r.jsx)(n.strong,{children:"Word2Vec"}),", ",(0,r.jsx)(n.strong,{children:"GloVe"}),", and ",(0,r.jsx)(n.strong,{children:"BERT"})," generate vector representations of words and phrases. Vector indexes are used to efficiently retrieve words or documents similar to a given word or phrase based on vector similarity."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var i=s(96540);const r={},t=i.createContext(r);function a(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);