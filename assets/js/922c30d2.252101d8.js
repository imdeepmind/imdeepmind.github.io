"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[7288],{85178:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"databases/database-systems/lsm-tree","title":"Log-Structured Merge Tree","description":"Log-Structured Merge (LSM) trees are a fundamental data structure used in database storage, particularly for handling high-write workloads efficiently. Here\u2019s a breakdown of key concepts and considerations when working with LSM storage:","source":"@site/docs/databases/database-systems/lsm-tree.md","sourceDirName":"databases/database-systems","slug":"/databases/database-systems/lsm-tree","permalink":"/docs/databases/database-systems/lsm-tree","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-systems/lsm-tree.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1734954494000,"sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Database Storage","permalink":"/docs/databases/database-systems/database-storage"},"next":{"title":"Index Organized Storage","permalink":"/docs/databases/database-systems/index-organized-storage"}}');var a=n(74848),r=n(28453);const t={sidebar_position:3},l="Log-Structured Merge Tree",d={},o=[{value:"Concept and Structure",id:"concept-and-structure",level:2},{value:"Write Operation (Write Path)",id:"write-operation-write-path",level:2},{value:"Read Operation (Read Path)",id:"read-operation-read-path",level:2},{value:"Compaction",id:"compaction",level:2},{value:"Performance Characteristics",id:"performance-characteristics",level:2},{value:"Use Cases",id:"use-cases",level:2},{value:"Considerations and Trade-Offs",id:"considerations-and-trade-offs",level:2},{value:"Alternatives and Comparisons",id:"alternatives-and-comparisons",level:2},{value:"MemTable Data Structure",id:"memtable-data-structure",level:2},{value:"SSTable Data Structure",id:"sstable-data-structure",level:2},{value:"LSM Tree Examples",id:"lsm-tree-examples",level:2},{value:"Key-Value and NoSQL Databases",id:"key-value-and-nosql-databases",level:3},{value:"Relational Databases",id:"relational-databases",level:3},{value:"<strong>3. Time-Series Databases</strong>",id:"3-time-series-databases",level:2},{value:"<strong>4. Search and Logging Databases</strong>",id:"4-search-and-logging-databases",level:3}];function c(e){const s={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.header,{children:(0,a.jsx)(s.h1,{id:"log-structured-merge-tree",children:"Log-Structured Merge Tree"})}),"\n",(0,a.jsx)(s.p,{children:"Log-Structured Merge (LSM) trees are a fundamental data structure used in database storage, particularly for handling high-write workloads efficiently. Here\u2019s a breakdown of key concepts and considerations when working with LSM storage:"}),"\n",(0,a.jsx)("img",{src:"/img/LSM.png",alt:"LSM Tree",style:{width:"100%"}}),"\n",(0,a.jsx)(s.h2,{id:"concept-and-structure",children:"Concept and Structure"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Write-Optimized Data Structure"}),": LSM trees are designed to optimize write operations by writing changes sequentially in memory (to a structure known as a memtable), instead of making random writes directly to disk."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Levels and Compaction"}),": Data is stored in multiple levels, and when the memtable reaches a certain size, it\u2019s flushed to disk as a new file (often called an SSTable). As these files accumulate, they are periodically merged and compacted to reduce redundancy, delete obsolete data, and keep read performance efficient."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"write-operation-write-path",children:"Write Operation (Write Path)"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Memtable Insertion"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Incoming writes (e.g., inserts, updates, deletes) are first placed into a ",(0,a.jsx)(s.strong,{children:"memtable"}),"\u2014an in-memory, sorted data structure."]}),"\n",(0,a.jsx)(s.li,{children:"Writes are handled efficiently in memory, as they avoid random disk I/O."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Write-Ahead Log (WAL)"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Before data is added to the memtable, it\u2019s written to a ",(0,a.jsx)(s.strong,{children:"write-ahead log (WAL)"}),"."]}),"\n",(0,a.jsx)(s.li,{children:"This ensures durability, as the WAL records each write operation sequentially on disk. If there\u2019s a system crash, the WAL allows the database to recover any uncommitted data."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Flushing the Memtable"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["When the memtable reaches a configured size, it\u2019s flushed to disk as an immutable, sorted file called an ",(0,a.jsx)(s.strong,{children:"SSTable"})," (Sorted String Table)."]}),"\n",(0,a.jsx)(s.li,{children:"This flush process is a sequential write, which is faster and reduces wear on the disk."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Compaction"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Over time, multiple SSTables are created, potentially containing outdated or duplicate records."}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Compaction"})," merges SSTables, removes deleted and old data, and organizes records for better read efficiency."]}),"\n",(0,a.jsx)(s.li,{children:"This reduces the number of files on disk, balancing storage space with performance."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Write Amplification"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Frequent compactions increase write amplification, as data may be written to disk multiple times."}),"\n",(0,a.jsx)(s.li,{children:"However, this process ensures that queries remain efficient and storage space is managed effectively."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"read-operation-read-path",children:"Read Operation (Read Path)"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Lookup in Memtable"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["When a read request arrives, the database first checks the ",(0,a.jsx)(s.strong,{children:"memtable"}),"."]}),"\n",(0,a.jsx)(s.li,{children:"Since the memtable is in memory and sorted, it can be quickly searched for the requested key."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Checking SSTables on Disk"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["If the key isn\u2019t found in the memtable, the search continues in the ",(0,a.jsx)(s.strong,{children:"SSTables"})," on disk."]}),"\n",(0,a.jsx)(s.li,{children:"SSTables are stored as a series of files on disk, typically organized by levels or tiers to manage access patterns."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Bloom Filters"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Each SSTable has an associated ",(0,a.jsx)(s.strong,{children:"Bloom filter"}),". This probabilistic data structure helps quickly determine whether a key might exist in a specific SSTable."]}),"\n",(0,a.jsx)(s.li,{children:"The Bloom filter check minimizes unnecessary reads by eliminating SSTables that don\u2019t contain the requested key."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Searching SSTables"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"If the Bloom filter indicates that a key might exist in an SSTable, the database reads the relevant SSTable(s)."}),"\n",(0,a.jsx)(s.li,{children:"Within each SSTable, data is sorted, allowing binary search, which is efficient for finding keys."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Merging Results"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"In cases where the key exists in multiple SSTables (due to updates or deletes), the database merges the results, applying any updates or deletes as necessary."}),"\n",(0,a.jsx)(s.li,{children:"The latest version of the record is returned to the user."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Read Amplification"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:["Searching across multiple SSTables can lead to ",(0,a.jsx)(s.strong,{children:"read amplification"}),", meaning the system may need to access several files to retrieve a single record."]}),"\n",(0,a.jsx)(s.li,{children:"Compaction mitigates this by merging SSTables over time, reducing the number of files that must be checked for each read."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"compaction",children:"Compaction"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Purpose"}),": Compaction merges multiple SSTables into fewer files, removing deleted or outdated entries and thus reducing storage overhead."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Strategies"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Leveling"}),": SSTables are organized into levels, and compaction involves moving data from one level to the next."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Size-Tiered"}),": Smaller SSTables are periodically merged into larger ones, grouping similar data together to improve access patterns."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"performance-characteristics",children:"Performance Characteristics"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Efficient Writes"}),": LSM trees are excellent for high-throughput writes, as they avoid random I/O by writing data in a log-structured fashion."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Read Amplification"}),": Due to multiple levels and compaction, LSM trees can have higher read amplification, meaning reads may need to access several files to retrieve a single key."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Write Amplification"}),": Frequent compaction results in write amplification, which is a trade-off for achieving better read performance over time."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"use-cases",children:"Use Cases"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"High-Write Workloads"}),": LSM trees are ideal for applications with high write demands, like logging, metrics storage, and real-time data analytics."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"NoSQL Databases"}),": Popular databases like Cassandra, HBase, and RocksDB leverage LSM trees for their storage engines due to their write-optimized design."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"considerations-and-trade-offs",children:"Considerations and Trade-Offs"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Storage Overhead"}),": Frequent flushing and multiple levels of data storage can result in significant storage overhead."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Latency Variability"}),": Compaction can cause spikes in latency, as it is a resource-intensive operation."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Configuration Complexity"}),": Balancing compaction frequency, SSTable size, and the number of levels is crucial for optimizing performance in an LSM-based database system."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"alternatives-and-comparisons",children:"Alternatives and Comparisons"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"B-Trees"}),": Unlike LSM trees, B-trees optimize for read-heavy workloads by storing data in a hierarchical structure that allows efficient random reads but requires more random I/O for writes."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Hybrid Approaches"}),": Some databases, like MongoDB, offer hybrid options to use either B-trees or LSM-based storage, allowing flexibility based on the workload."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"memtable-data-structure",children:"MemTable Data Structure"}),"\n",(0,a.jsx)(s.p,{children:"The MemTable, an in-memory structure, is optimized for fast writes and efficient lookups. It typically uses:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Red-Black Tree or AVL Tree"}),": Balanced binary search trees like red-black trees or AVL trees are commonly used for the MemTable. They keep data sorted, allowing efficient in-order traversal and enabling fast reads and writes (in (O(log n)) time)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Skip List"}),": Some implementations use skip lists as an alternative to trees, especially in write-heavy databases. Skip lists provide probabilistically balanced structure, making inserts, deletes, and lookups efficient (also (O(log n)) time complexity) while being simpler to implement and manage in concurrent environments."]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"sstable-data-structure",children:"SSTable Data Structure"}),"\n",(0,a.jsx)(s.p,{children:"An SSTable, a file stored on disk, is an immutable and sorted structure optimized for sequential read and efficient range queries. Its core components include:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Sorted Array (or Block-Ordered Data)"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Each SSTable is essentially a sorted array of key-value pairs or records stored sequentially on disk. The entire structure is sorted by keys, allowing efficient binary search within blocks."}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Indexing by Key"}),": Often, SSTables include a simple index (usually loaded into memory) that allows quick lookups by pointing to blocks or offsets within the file for a given key."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Data Blocks"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"SSTables are divided into data blocks (often 4 KB or 8 KB in size), each containing a subset of sorted records."}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Block-Based Indexing"}),": To reduce I/O operations, an in-memory index is maintained for each SSTable. It contains pointers to the beginning of each block within the SSTable, allowing faster access to specific blocks on disk."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.strong,{children:"Bloom Filter"}),":","\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"SSTables often include a Bloom filter, stored in memory, to quickly check if a specific key might be present in the SSTable."}),"\n",(0,a.jsx)(s.li,{children:"This filter allows the system to skip unnecessary I/O operations by eliminating SSTables that definitely don\u2019t contain the queried key."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"lsm-tree-examples",children:"LSM Tree Examples"}),"\n",(0,a.jsx)(s.h3,{id:"key-value-and-nosql-databases",children:"Key-Value and NoSQL Databases"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Cassandra"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Distributed NoSQL database."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Cassandra is known for its high write and read scalability, making it a popular choice for applications that require high availability and massive amounts of data."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"HBase"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Columnar NoSQL database built on top of Hadoop."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Used for managing large amounts of sparse data, HBase uses LSM trees to support fast writes and high data throughput."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"RocksDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Embedded key-value store."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Optimized for fast storage with LSM trees, RocksDB is used within larger systems (like MySQL or Kafka) to provide efficient storage and is popular in storage-heavy applications."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"LevelDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Embedded key-value store (developed by Google)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Uses LSM trees to support fast write operations. It\u2019s often used in desktop and mobile applications due to its simplicity and lightweight design."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"ScyllaDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": NoSQL database (Cassandra-compatible)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": ScyllaDB is designed for high-performance and low-latency workloads. It uses LSM trees along with a unique architecture that optimizes it for modern hardware."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"DynamoDB (Amazon)"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Fully managed NoSQL database by AWS."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": DynamoDB is often backed by an LSM-like storage engine optimized for high-write and low-latency applications in a fully managed cloud environment."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Bigtable (Google)"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Columnar NoSQL database (managed service on GCP)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Known for its scalability and high throughput, Bigtable is used for time-series data, IoT data, and analytical workloads that require efficient write capabilities."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"relational-databases",children:"Relational Databases"}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"MyRocks (MySQL with RocksDB)"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Relational database (MySQL variant)."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": MyRocks is a MySQL storage engine using RocksDB (which uses LSM trees). It\u2019s designed for high-write applications where reducing storage space and write amplification is critical."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"CockroachDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Distributed SQL database."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Uses LSM trees for its storage layer to manage distributed data, allowing it to handle heavy write operations and maintain high availability across regions."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"TiDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Distributed SQL database."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": TiDB uses an LSM-based storage layer (with RocksDB or TiKV) for high-performance and distributed data management, balancing SQL compatibility with NoSQL performance."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h2,{id:"3-time-series-databases",children:(0,a.jsx)(s.strong,{children:"3. Time-Series Databases"})}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"InfluxDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Time-series database."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Known for handling high-throughput time-series data, InfluxDB uses an LSM-based storage engine to optimize for frequent writes typical in monitoring, IoT, and analytics applications."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"TimescaleDB"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Time-series database built on PostgreSQL."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": While PostgreSQL uses a B-tree structure by default, TimescaleDB includes LSM options and optimizations for handling high-frequency data insertions in time-series data."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(s.h3,{id:"4-search-and-logging-databases",children:(0,a.jsx)(s.strong,{children:"4. Search and Logging Databases"})}),"\n",(0,a.jsxs)(s.ol,{children:["\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Elasticsearch"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Search and analytics engine."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": While Elasticsearch primarily uses inverted indices, its underlying data storage and segment merging incorporate LSM-like principles to handle high-ingest data efficiently."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Splunk"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Logging and analytics platform."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": Splunk uses an LSM-inspired model for its data storage to support high-speed log ingestion and indexing, essential for real-time analytics and monitoring."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(s.li,{children:["\n",(0,a.jsx)(s.p,{children:(0,a.jsx)(s.strong,{children:"Log-Structured File Systems (e.g., OpenTSDB)"})}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Type"}),": Time-series storage on HBase."]}),"\n",(0,a.jsxs)(s.li,{children:[(0,a.jsx)(s.em,{children:"Usage"}),": OpenTSDB leverages HBase's LSM tree structure to store and retrieve large volumes of time-series data for metrics tracking and monitoring purposes."]}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>t,x:()=>l});var i=n(96540);const a={},r=i.createContext(a);function t(e){const s=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);