"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[9270],{1820:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"system-design/fundamental-concepts/cap-theorem","title":"CAP Theorem","description":"The CAP Theorem, also known as Brewer\'s Theorem, is a fundamental principle in distributed systems. It was introduced by Eric Brewer in 2000 and formally proven by Seth Gilbert and Nancy Lynch in 2002. The theorem states that in a distributed system, it is impossible to simultaneously guarantee all three of the following properties:","source":"@site/docs/system-design/fundamental-concepts/cap-theorem.md","sourceDirName":"system-design/fundamental-concepts","slug":"/system-design/fundamental-concepts/cap-theorem","permalink":"/docs/system-design/fundamental-concepts/cap-theorem","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/system-design/fundamental-concepts/cap-theorem.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1736677834000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"High and Low Level Design","permalink":"/docs/system-design/fundamental-concepts/high-and-low-level-design"},"next":{"title":"Latency and Throughput","permalink":"/docs/system-design/fundamental-concepts/latency-and-throughput"}}');var r=i(74848),t=i(28453);const l={sidebar_position:2},a="CAP Theorem",o={},c=[{value:"Scalability",id:"scalability",level:2},{value:"Vertical Scaling",id:"vertical-scaling",level:3},{value:"Key Characteristics",id:"key-characteristics",level:4},{value:"Benefits",id:"benefits",level:4},{value:"Challenges",id:"challenges",level:4},{value:"Use Cases",id:"use-cases",level:4},{value:"Horizontal Scaling",id:"horizontal-scaling",level:3},{value:"Key Characteristics",id:"key-characteristics-1",level:4},{value:"Benefits",id:"benefits-1",level:4},{value:"Challenges",id:"challenges-1",level:4},{value:"Use Cases",id:"use-cases-1",level:4},{value:"Comparison Table",id:"comparison-table",level:3},{value:"Choosing Between Horizontal and Vertical Scaling",id:"choosing-between-horizontal-and-vertical-scaling",level:3},{value:"Availability",id:"availability",level:2},{value:"Factors Influencing Availability",id:"factors-influencing-availability",level:3},{value:"Measuring Availability",id:"measuring-availability",level:3},{value:"Reliability",id:"reliability",level:2},{value:"Characteristics of Reliability",id:"characteristics-of-reliability",level:3},{value:"Enhancing Reliability",id:"enhancing-reliability",level:3},{value:"Metrics for Reliability",id:"metrics-for-reliability",level:3},{value:"Partition Tolerance",id:"partition-tolerance",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Partition Tolerance Techniques",id:"partition-tolerance-techniques",level:3},{value:"Trade-offs in CAP",id:"trade-offs-in-cap",level:2},{value:"Google Spanner and the CAP Theorem",id:"google-spanner-and-the-cap-theorem",level:2},{value:"Key Features of Google Spanner",id:"key-features-of-google-spanner",level:3},{value:"How Spanner &quot;Breaks&quot; CAP",id:"how-spanner-breaks-cap",level:3},{value:"Limitations and Practical Considerations",id:"limitations-and-practical-considerations",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"cap-theorem",children:"CAP Theorem"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.strong,{children:"CAP Theorem"}),", also known as Brewer's Theorem, is a fundamental principle in distributed systems. It was introduced by Eric Brewer in 2000 and formally proven by Seth Gilbert and Nancy Lynch in 2002. The theorem states that in a distributed system, it is impossible to simultaneously guarantee all three of the following properties:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency (C):"})," Every read receives the most recent write or an error. In other words, all nodes in the system see the same data at the same time."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Availability (A):"})," Every request (read or write) receives a response, even if some nodes in the system are down."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Partition Tolerance (P):"})," The system continues to operate despite arbitrary partitioning due to network failures."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["In the presence of a network partition, a distributed system must choose between ",(0,r.jsx)(n.strong,{children:"consistency"})," and ",(0,r.jsx)(n.strong,{children:"availability"}),", as achieving both is theoretically impossible."]}),"\n",(0,r.jsx)(n.h2,{id:"scalability",children:"Scalability"}),"\n",(0,r.jsx)(n.p,{children:"Scaling in computing refers to the ability to handle increasing workloads by expanding resources. There are two primary types of scaling: horizontal scaling and vertical scaling. Below is a detailed breakdown of both approaches, including their definitions, benefits, challenges, and use cases."}),"\n",(0,r.jsx)(n.h3,{id:"vertical-scaling",children:"Vertical Scaling"}),"\n",(0,r.jsx)(n.p,{children:"Vertical scaling, also known as scaling up, involves adding more resources (e.g., CPU, memory, or storage) to an existing server. Instead of adding more servers, the capacity of a single machine is enhanced."}),"\n",(0,r.jsx)(n.h4,{id:"key-characteristics",children:"Key Characteristics"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Resource Augmentation:"})," Upgrades a single machine with better hardware."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Centralized Architecture:"})," Focuses on improving the performance of one node."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easier Management:"})," Fewer nodes to manage compared to horizontal scaling."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"benefits",children:"Benefits"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplified Architecture:"})," No need for load balancers or distributed systems."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ease of Implementation:"})," Easier to upgrade an existing server than to manage a cluster."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency:"})," Single-node systems do not face distributed consistency issues."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimized Resource Utilization:"})," Makes full use of hardware capabilities."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"challenges",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Hardware Limits:"})," Physical hardware imposes a ceiling on how much you can scale."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Downtime:"})," Upgrading a server often requires downtime."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cost:"})," High-performance servers are more expensive."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Point of Failure:"})," If the server fails, the entire system is affected."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Legacy Systems:"})," Applications not designed for distributed architecture."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Databases:"})," High-performance databases that require more memory or CPU."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Enterprise Applications:"})," Systems with predictable workloads."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Quick Fixes:"})," Temporary solutions where horizontal scaling is not immediately feasible."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"horizontal-scaling",children:"Horizontal Scaling"}),"\n",(0,r.jsx)(n.p,{children:"Horizontal scaling, also known as scaling out, involves adding more machines or nodes to a system. Instead of increasing the power of a single server, additional servers are introduced to distribute the workload."}),"\n",(0,r.jsx)(n.h4,{id:"key-characteristics-1",children:"Key Characteristics"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node Addition:"})," Increases capacity by adding more servers to the cluster."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundancy:"})," Multiple nodes improve fault tolerance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distribution:"})," Requires load balancing to distribute traffic among the nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decentralized Architecture:"})," Often associated with distributed systems like microservices."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"benefits-1",children:"Benefits"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Improved Fault Tolerance:"})," If one server fails, others can take over the workload."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cost-Effective Scaling:"})," Commodity hardware can be used instead of investing in high-end servers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Infinite Scalability:"})," There is theoretically no limit to how many nodes you can add."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Geographic Distribution:"})," Nodes can be deployed across different regions for better latency and user experience."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"challenges-1",children:"Challenges"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Complexity:"})," Managing and orchestrating multiple nodes can be complex."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistency Issues:"})," Data consistency can be harder to maintain in distributed databases."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Load Balancing:"})," Requires robust mechanisms to evenly distribute traffic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Inter-node Communication:"})," High latency between nodes can affect performance."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"use-cases-1",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Web Applications:"})," High-traffic websites like e-commerce platforms."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cloud Services:"})," Systems like Amazon Web Services (AWS), Google Cloud Platform (GCP), and Microsoft Azure."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Big Data Systems:"})," Distributed data processing systems such as Hadoop and Apache Spark."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Content Delivery Networks (CDNs):"})," Distributing content closer to users for faster delivery."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Aspect"}),(0,r.jsx)(n.th,{children:"Horizontal Scaling"}),(0,r.jsx)(n.th,{children:"Vertical Scaling"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Definition"})}),(0,r.jsx)(n.td,{children:"Adding more servers to the system."}),(0,r.jsx)(n.td,{children:"Adding more resources to a server."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Architecture"})}),(0,r.jsx)(n.td,{children:"Decentralized and distributed."}),(0,r.jsx)(n.td,{children:"Centralized."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Scalability"})}),(0,r.jsx)(n.td,{children:"Theoretically infinite."}),(0,r.jsx)(n.td,{children:"Limited by hardware constraints."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Complexity"})}),(0,r.jsx)(n.td,{children:"High due to orchestration needs."}),(0,r.jsx)(n.td,{children:"Low, as fewer nodes are involved."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Fault Tolerance"})}),(0,r.jsx)(n.td,{children:"High, as failure of one node is manageable."}),(0,r.jsx)(n.td,{children:"Low, as a single point of failure exists."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Cost"})}),(0,r.jsx)(n.td,{children:"Incremental cost with commodity hardware."}),(0,r.jsx)(n.td,{children:"High, due to expensive upgrades."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Implementation Time"})}),(0,r.jsx)(n.td,{children:"Longer, requires planning and orchestration."}),(0,r.jsx)(n.td,{children:"Faster, as it involves upgrading one machine."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Use Case Examples"})}),(0,r.jsx)(n.td,{children:"Web apps, big data, cloud systems."}),(0,r.jsx)(n.td,{children:"Legacy systems, databases, enterprise apps."})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"choosing-between-horizontal-and-vertical-scaling",children:"Choosing Between Horizontal and Vertical Scaling"}),"\n",(0,r.jsx)(n.p,{children:"The choice between horizontal and vertical scaling depends on various factors:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Workload Characteristics:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Horizontal scaling is ideal for unpredictable workloads with spikes."}),"\n",(0,r.jsx)(n.li,{children:"Vertical scaling works for steady workloads that demand high resource usage."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Budget:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Horizontal scaling can be more cost-effective with commodity hardware."}),"\n",(0,r.jsx)(n.li,{children:"Vertical scaling may incur higher initial costs for hardware upgrades."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fault Tolerance Needs:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If high availability is crucial, horizontal scaling is preferable."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Legacy Constraints:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applications not designed for distributed environments may require vertical scaling."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Future Growth:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Horizontal scaling offers more flexibility for long-term growth."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"availability",children:"Availability"}),"\n",(0,r.jsx)(n.p,{children:"Availability refers to the degree to which a system is operational and accessible when needed. It is typically expressed as a percentage (e.g., 99.9% uptime)."}),"\n",(0,r.jsx)(n.h3,{id:"factors-influencing-availability",children:"Factors Influencing Availability"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Redundancy:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Having backup components or systems (e.g., multiple servers, replicated databases) to ensure continuity in case of failure."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Failover Mechanisms:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically switching to a standby system or resource when the primary one fails."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Monitoring and Alerts:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Proactive identification of issues through health checks and notifications."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"measuring-availability",children:"Measuring Availability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Formula:"})," ",(0,r.jsx)(n.code,{children:"Availability = (Uptime / Total Time) * 100"})]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"Example Availability Levels:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'99.9% ("Three Nines") \u2013 ~8.77 hours of downtime per year.'}),"\n",(0,r.jsx)(n.li,{children:'99.99% ("Four Nines") \u2013 ~52.6 minutes of downtime per year.'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"reliability",children:"Reliability"}),"\n",(0,r.jsx)(n.p,{children:"Reliability refers to a system\u2019s ability to perform its intended function consistently and correctly over time, even under adverse conditions."}),"\n",(0,r.jsx)(n.h3,{id:"characteristics-of-reliability",children:"Characteristics of Reliability"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Consistency:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The system produces the same results for the same input."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Fault Tolerance:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The ability to handle and recover from failures gracefully."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Durability:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensuring data is not lost or corrupted even in the event of system crashes."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"enhancing-reliability",children:"Enhancing Reliability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundant Systems:"})," Having backups for critical components."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Regular Testing:"})," Implementing failure injection testing, such as chaos engineering."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Backups:"})," Regularly creating and testing backups to prevent data loss."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"metrics-for-reliability",children:"Metrics for Reliability"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mean Time Between Failures (MTBF):"})," Average time between system failures."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mean Time to Repair (MTTR):"})," Average time required to restore the system after a failure."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"partition-tolerance",children:"Partition Tolerance"}),"\n",(0,r.jsx)(n.p,{children:"Partition tolerance is the ability of a system to continue operating properly in the event of a failure of one or more of its components."}),"\n",(0,r.jsx)(n.h3,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Redundancy:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Incorporating duplicate components (e.g., multiple instances of a service) to take over if one fails."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Replication:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Copying data across multiple nodes to ensure it remains available and consistent despite node failures."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Graceful Degradation:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Allowing the system to operate in a reduced capacity rather than failing completely (e.g., serving cached data)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Failover Systems:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatically switching to a backup system in case of a primary system failure."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"partition-tolerance-techniques",children:"Partition Tolerance Techniques"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Active-Active Systems:"})," All systems are actively serving requests, providing load balancing and redundancy."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Active-Passive Systems:"})," A standby system is kept ready to take over if the active system fails."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Error Detection and Recovery:"})," Mechanisms like checksums and retries ensure errors are identified and corrected."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"trade-offs-in-cap",children:"Trade-offs in CAP"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CP Systems:"})," Prioritize consistency over availability during network partitions. For example, databases like HBase and MongoDB in certain configurations."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"AP Systems:"})," Prioritize availability over consistency, ensuring the system remains operational but might serve stale or inconsistent data. Examples include DynamoDB and Cassandra."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CA Systems:"})," These are achievable only in systems without partitions, which is impractical in real-world distributed systems due to the inevitability of network failures."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"google-spanner-and-the-cap-theorem",children:"Google Spanner and the CAP Theorem"}),"\n",(0,r.jsxs)(n.p,{children:["Google Spanner is a globally distributed database that appears to challenge the CAP theorem by offering ",(0,r.jsx)(n.strong,{children:"strong consistency"}),", ",(0,r.jsx)(n.strong,{children:"high availability"}),", and ",(0,r.jsx)(n.strong,{children:"partition tolerance"}),". It achieves this through innovative architectural and algorithmic designs. Here's how Spanner addresses CAP:"]}),"\n",(0,r.jsx)(n.h3,{id:"key-features-of-google-spanner",children:"Key Features of Google Spanner"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"TrueTime API:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spanner leverages Google's TrueTime API, a globally synchronized clock with bounded uncertainty. This allows Spanner to timestamp transactions with confidence, ensuring strong consistency."}),"\n",(0,r.jsx)(n.li,{children:"TrueTime's API enables linearizable consistency by defining precise time intervals during which events occur, avoiding ambiguity."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Synchronous Replication:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spanner uses Paxos-based consensus protocols for synchronous replication across multiple nodes. This ensures that all replicas agree on the order of transactions, maintaining consistency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Partition Tolerance:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"By design, Spanner ensures that partitions do not compromise the integrity of the system. While partitions might delay operations, Spanner's synchronous replication and distributed consensus allow it to resume consistent operations once connectivity is restored."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"High Availability:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Spanner's architecture is designed to mitigate the impact of network partitions. It replicates data across geographically dispersed nodes, ensuring availability even during localized failures."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"how-spanner-breaks-cap",children:'How Spanner "Breaks" CAP'}),"\n",(0,r.jsx)(n.p,{children:"Spanner operates in the CP space of the CAP theorem, prioritizing consistency and partition tolerance. It avoids the typical trade-offs by:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Minimizing Partition Effects:"})," Spanner's reliance on Google's highly reliable and low-latency network infrastructure significantly reduces the likelihood and impact of network partitions."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bounded Delays:"})," Spanner introduces controlled delays using TrueTime to maintain strong consistency without sacrificing availability significantly. These delays are often imperceptible to users."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"limitations-and-practical-considerations",children:"Limitations and Practical Considerations"}),"\n",(0,r.jsx)(n.p,{children:"While Spanner's design is groundbreaking, it doesn't completely escape the CAP theorem. Instead, it mitigates the trade-offs by operating in a controlled environment with:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Strict infrastructure requirements (e.g., Google's custom network and TrueTime)."}),"\n",(0,r.jsx)(n.li,{children:"Higher operational costs due to its reliance on synchronous replication and global clock synchronization."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},28453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var s=i(96540);const r={},t=s.createContext(r);function l(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);