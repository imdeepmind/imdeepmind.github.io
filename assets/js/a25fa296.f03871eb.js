"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[9859],{72621:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"system-design/fundamental-concepts/load-balancer","title":"Distributed Load Balancer","description":"A Distributed Load Balancer is a specialized system designed to distribute network traffic across multiple servers or resources in a distributed environment. Unlike traditional load balancers, which may operate within a single data center, distributed load balancers function across multiple geographic locations or cloud regions.","source":"@site/docs/system-design/fundamental-concepts/load-balancer.md","sourceDirName":"system-design/fundamental-concepts","slug":"/system-design/fundamental-concepts/load-balancer","permalink":"/docs/system-design/fundamental-concepts/load-balancer","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/system-design/fundamental-concepts/load-balancer.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1736688280000,"sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Caching","permalink":"/docs/system-design/fundamental-concepts/caching"},"next":{"title":"Proxies","permalink":"/docs/system-design/fundamental-concepts/proxies"}}');var r=s(74848),l=s(28453);const t={sidebar_position:5},a="Distributed Load Balancer",d={},c=[{value:"Benefits of Distributed Load Balancers",id:"benefits-of-distributed-load-balancers",level:2},{value:"Load Balancer Algorithms",id:"load-balancer-algorithms",level:2},{value:"Round-Robin",id:"round-robin",level:3},{value:"Weighted Round-Robin",id:"weighted-round-robin",level:3},{value:"Least Connections",id:"least-connections",level:3},{value:"Weighted Least Connections",id:"weighted-least-connections",level:3},{value:"IP Hash",id:"ip-hash",level:3},{value:"Random",id:"random",level:3},{value:"Geolocation",id:"geolocation",level:3},{value:"Consistent Hashing",id:"consistent-hashing",level:3},{value:"Algorithm Comparison Table",id:"algorithm-comparison-table",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"Core Architecture of a Distributed Load Balancer",id:"core-architecture-of-a-distributed-load-balancer",level:3},{value:"Request Flow in a Distributed Load Balancer",id:"request-flow-in-a-distributed-load-balancer",level:3},{value:"Internal Workflow of Distributed Load Balancers",id:"internal-workflow-of-distributed-load-balancers",level:3},{value:"Step 1: DNS Resolution",id:"step-1-dns-resolution",level:4},{value:"Step 2: Accepting the Request",id:"step-2-accepting-the-request",level:4},{value:"Step 3: Routing Decision",id:"step-3-routing-decision",level:4},{value:"Step 4: Forwarding the Request",id:"step-4-forwarding-the-request",level:4},{value:"Step 5: Response Handling",id:"step-5-response-handling",level:4},{value:"Distributed Health Monitoring",id:"distributed-health-monitoring",level:3},{value:"Distributed State Management",id:"distributed-state-management",level:3},{value:"High Availability and Failover",id:"high-availability-and-failover",level:3},{value:"Dynamic Scaling",id:"dynamic-scaling",level:3},{value:"Key Considerations",id:"key-considerations",level:3},{value:"Example",id:"example",level:2},{value:"Explanation",id:"explanation",level:3},{value:"Testing the Load Balancer",id:"testing-the-load-balancer",level:3}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"distributed-load-balancer",children:"Distributed Load Balancer"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.strong,{children:"Distributed Load Balancer"})," is a specialized system designed to distribute network traffic across multiple servers or resources in a distributed environment. Unlike traditional load balancers, which may operate within a single data center, distributed load balancers function across multiple geographic locations or cloud regions."]}),"\n",(0,r.jsx)(n.p,{children:"The primary goal of a distributed load balancer is to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Ensure high availability"}),": By rerouting traffic from unhealthy or unreachable servers to healthy ones."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optimize performance"}),": By reducing latency and efficiently utilizing server resources."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Support scalability"}),": By enabling the system to handle fluctuating traffic volumes through dynamic scaling."]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"These systems can be deployed on-premises, in the cloud, or as hybrid solutions and operate at different layers of the OSI model:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Layer 4 (Transport Layer)"}),": Operates using TCP/UDP protocols and is faster but less application-aware."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Layer 7 (Application Layer)"}),": Operates using HTTP/HTTPS protocols and can make routing decisions based on content, such as URLs or headers."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Examples include global solutions like ",(0,r.jsx)(n.strong,{children:"AWS Elastic Load Balancer"}),", ",(0,r.jsx)(n.strong,{children:"Google Cloud Load Balancer"}),", and ",(0,r.jsx)(n.strong,{children:"Azure Load Balancer"}),", as well as on-premises systems like ",(0,r.jsx)(n.strong,{children:"Nginx"})," and ",(0,r.jsx)(n.strong,{children:"HAProxy"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"benefits-of-distributed-load-balancers",children:"Benefits of Distributed Load Balancers"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"High Availability"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensures uninterrupted access to applications by routing traffic away from failed or overloaded servers to operational ones."}),"\n",(0,r.jsx)(n.li,{children:"Supports redundancy by deploying multiple load balancers across regions to prevent single points of failure."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Improved Performance"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduces latency by routing users to the nearest or most optimal server based on their geographic location or server load."}),"\n",(0,r.jsx)(n.li,{children:"Balances the workload among servers, preventing any one server from becoming a bottleneck."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Scalability"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Enables applications to handle traffic spikes by adding new servers dynamically and distributing traffic evenly among them."}),"\n",(0,r.jsx)(n.li,{children:"Works seamlessly in autoscaling environments, such as those in cloud infrastructures."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Global Reach"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Distributes traffic across multiple geographic regions, ensuring a consistent user experience worldwide."}),"\n",(0,r.jsx)(n.li,{children:"Supports geographic routing to direct users to the server closest to them, enhancing responsiveness."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Security"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Protects backend resources from Distributed Denial-of-Service (DDoS) attacks by absorbing excess traffic and implementing rate-limiting policies."}),"\n",(0,r.jsx)(n.li,{children:"Can provide SSL termination, encrypting client-server communications while offloading decryption tasks from backend servers."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Cost Efficiency"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Optimizes resource usage by routing traffic to underutilized servers, reducing the need for over-provisioning."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Flexibility in Traffic Handling"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Supports both stateless (e.g., static websites) and stateful applications (e.g., user sessions) by offering session persistence mechanisms."}),"\n",(0,r.jsx)(n.li,{children:"Handles multiple protocols (HTTP, HTTPS, TCP, UDP, etc.) to support various application needs."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"load-balancer-algorithms",children:"Load Balancer Algorithms"}),"\n",(0,r.jsx)(n.p,{children:"Distributed load balancers use different algorithms to decide how to distribute traffic among servers. These algorithms are chosen based on the application type, server configurations, and expected traffic patterns. Each algorithm offers unique benefits and is suited to specific use cases."}),"\n",(0,r.jsx)(n.h3,{id:"round-robin",children:"Round-Robin"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Distributes requests sequentially across all servers in a cyclic order."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stateless applications where all servers have identical configurations and capabilities."}),"\n",(0,r.jsx)(n.li,{children:"Simple setups, such as static content delivery (e.g., image hosting)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Easy to configure and implement."}),"\n",(0,r.jsx)(n.li,{children:"Ensures equal distribution of requests when all servers have the same capacity."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Doesn\u2019t consider the current server load or capacity, which can lead to overloaded servers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"weighted-round-robin",children:"Weighted Round-Robin"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Similar to round-robin but assigns weights to servers based on their capacity (e.g., CPU, memory)."}),"\n",(0,r.jsx)(n.li,{children:"Servers with higher weights handle more requests."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Environments with servers of varying capacities, where some can handle more traffic than others."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Accounts for differences in server capacity, leading to better resource utilization."}),"\n",(0,r.jsx)(n.li,{children:"Provides finer control over traffic distribution."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Requires manual configuration of weights, which can be error-prone in dynamic environments."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"least-connections",children:"Least Connections"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Routes traffic to the server with the fewest active connections."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applications with long-lived connections, such as video streaming, database queries, or chat systems."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Dynamically balances the load based on real-time server usage."}),"\n",(0,r.jsx)(n.li,{children:"Prevents overloading servers that already have many active connections."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"May not consider server capacity, potentially overloading less powerful servers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"weighted-least-connections",children:"Weighted Least Connections"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Extends the least connections algorithm by adding server weights to account for their capacity."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Long-lived connections in environments with heterogeneous servers."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Optimizes traffic distribution by considering both server load and capacity."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Slightly more complex configuration than basic least connections."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"ip-hash",children:"IP Hash"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A hash function maps the client\u2019s IP address to a specific server, ensuring that requests from the same IP are routed to the same server."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applications requiring session persistence without relying on cookies or application-level mechanisms."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Ensures consistent client-server mapping, preserving user sessions."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Doesn\u2019t evenly distribute traffic, especially if client IP distribution is skewed."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"random",children:"Random"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Traffic is distributed randomly across servers."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Testing environments or applications with predictable workloads and uniform resource requirements."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple to implement."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Traffic distribution may become uneven in real-world scenarios."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"geolocation",children:"Geolocation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Routes users to the server geographically closest to them."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applications with global user bases, such as content delivery networks (CDNs) or online gaming platforms."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reduces latency and improves user experience by serving requests from nearby servers."}),"\n",(0,r.jsx)(n.li,{children:"Supports compliance with data sovereignty laws by keeping user data within specific regions."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Requires accurate geographic data and may not work well for clients using VPNs."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"consistent-hashing",children:"Consistent Hashing"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"How it Works"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses a hash ring to map client requests to specific servers. Adding or removing servers minimally disrupts the mapping."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Best Use Cases"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Distributed caching systems (e.g., Memcached, Redis) and applications requiring minimal disruption during scaling."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Advantages"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Minimizes data movement when scaling resources."}),"\n",(0,r.jsx)(n.li,{children:"Supports session persistence and load balancing."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Drawbacks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Complex to implement and configure."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"algorithm-comparison-table",children:"Algorithm Comparison Table"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Algorithm"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Best For"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Advantages"})}),(0,r.jsx)(n.th,{children:(0,r.jsx)(n.strong,{children:"Limitations"})})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Round-Robin"})}),(0,r.jsx)(n.td,{children:"Stateless apps, identical servers"}),(0,r.jsx)(n.td,{children:"Simple, even distribution"}),(0,r.jsx)(n.td,{children:"Ignores server load"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Weighted Round-Robin"})}),(0,r.jsx)(n.td,{children:"Heterogeneous server environments"}),(0,r.jsx)(n.td,{children:"Considers server capacity"}),(0,r.jsx)(n.td,{children:"Requires manual configuration"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Least Connections"})}),(0,r.jsx)(n.td,{children:"Long-lived connections, real-time apps"}),(0,r.jsx)(n.td,{children:"Balances dynamically"}),(0,r.jsx)(n.td,{children:"Ignores server capacity"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Weighted Least Conn."})}),(0,r.jsx)(n.td,{children:"Long-lived connections with varied servers"}),(0,r.jsx)(n.td,{children:"Optimized for capacity and load"}),(0,r.jsx)(n.td,{children:"More complex configuration"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"IP Hash"})}),(0,r.jsx)(n.td,{children:"Session persistence without cookies"}),(0,r.jsx)(n.td,{children:"Consistent routing for sessions"}),(0,r.jsx)(n.td,{children:"Traffic imbalance possible"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Geolocation"})}),(0,r.jsx)(n.td,{children:"Global apps, low-latency needs"}),(0,r.jsx)(n.td,{children:"Reduces latency, user proximity focus"}),(0,r.jsx)(n.td,{children:"VPNs or proxies can disrupt routing"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.strong,{children:"Consistent Hashing"})}),(0,r.jsx)(n.td,{children:"Distributed caching, minimal scaling impact"}),(0,r.jsx)(n.td,{children:"Reduces disruption during scaling"}),(0,r.jsx)(n.td,{children:"Complex to implement"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,r.jsx)(n.h3,{id:"core-architecture-of-a-distributed-load-balancer",children:"Core Architecture of a Distributed Load Balancer"}),"\n",(0,r.jsx)(n.p,{children:"Distributed load balancers consist of several key components working together to manage traffic efficiently:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Control Plane"}),": Handles global state management, server health monitoring, and traffic distribution logic."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Data Plane"}),": Processes actual client traffic, applies routing rules, and forwards it to backend servers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Health Check System"}),": Monitors server availability and performance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Distributed State Management"}),": Ensures consistent views of server health and configuration across all nodes."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"request-flow-in-a-distributed-load-balancer",children:"Request Flow in a Distributed Load Balancer"}),"\n",(0,r.jsx)(n.p,{children:"When a client makes a request, here\u2019s the high-level flow:"}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant DNS\n    participant LoadBalancerNode\n    participant BackendServer\n\n    Client->>DNS: Resolve example.com\n    DNS--\x3e>Client: IP of the nearest Load Balancer\n    Client->>LoadBalancerNode: Send Request\n    LoadBalancerNode->>BackendServer: Forward Request\n    BackendServer--\x3e>LoadBalancerNode: Send Response\n    LoadBalancerNode--\x3e>Client: Forward Response"})}),"\n",(0,r.jsx)(n.h3,{id:"internal-workflow-of-distributed-load-balancers",children:"Internal Workflow of Distributed Load Balancers"}),"\n",(0,r.jsx)(n.h4,{id:"step-1-dns-resolution",children:"Step 1: DNS Resolution"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["The client requests ",(0,r.jsx)(n.code,{children:"example.com"})," from the DNS server."]}),"\n",(0,r.jsxs)(n.li,{children:["The DNS server routes the client to the closest load balancer node based on:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Geolocation"}),": To minimize latency."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Server Health"}),": Avoiding unhealthy or overloaded nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Anycast Routing"}),": A single IP is shared by multiple nodes, and the nearest one responds."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"step-2-accepting-the-request",children:"Step 2: Accepting the Request"}),"\n",(0,r.jsx)(n.p,{children:"The load balancer node accepts the client\u2019s connection and begins processing:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Network Listener"}),": A listener on ports like 80/443 accepts incoming TCP/UDP connections using efficient I/O models (e.g., epoll or kqueue)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Decryption (Optional)"}),": If the request is HTTPS, the load balancer terminates the SSL/TLS connection."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Request Parsing"}),": The load balancer inspects HTTP headers, paths, and other metadata for routing decisions."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"step-3-routing-decision",children:"Step 3: Routing Decision"}),"\n",(0,r.jsx)(n.p,{children:"The load balancer decides which backend server to forward the request to, using:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Routing Algorithms"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Round Robin"}),": Cycles through servers in order."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Least Connections"}),": Chooses the server with the fewest active connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Consistent Hashing"}),": Maps requests (e.g., based on client IP) to specific servers for session affinity."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Health Monitoring"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Skips unhealthy servers based on active/passive checks."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Traffic Splitting"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Supports A/B testing, canary deployments, or traffic weighting."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"step-4-forwarding-the-request",children:"Step 4: Forwarding the Request"}),"\n",(0,r.jsx)(n.p,{children:"The load balancer connects to the selected backend server:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connection Handling"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reuses persistent connections with the backend (if supported)."}),"\n",(0,r.jsx)(n.li,{children:"Uses NAT or acts as a proxy to hide internal server details."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Packet Transformation"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Adds headers like ",(0,r.jsx)(n.code,{children:"X-Forwarded-For"})," to preserve the client\u2019s IP."]}),"\n",(0,r.jsx)(n.li,{children:"Modifies cookies for session persistence."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"graph TD\n    A[Load Balancer] --\x3e|Decision: Round Robin| B[Server 1]\n    A --\x3e|Decision: Least Connections| C[Server 2]\n    A --\x3e|Decision: Session Affinity| D[Server 3]"})}),"\n",(0,r.jsx)(n.h4,{id:"step-5-response-handling",children:"Step 5: Response Handling"}),"\n",(0,r.jsx)(n.p,{children:"Once the backend processes the request:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Response Delivery"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The response is returned to the client through the load balancer."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Optional Enhancements"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Caching"}),": Frequently requested content is served from an in-memory cache."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compression"}),": Responses are compressed (e.g., gzip) before delivery."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"distributed-health-monitoring",children:"Distributed Health Monitoring"}),"\n",(0,r.jsx)(n.p,{children:"Distributed load balancers actively monitor backend servers to ensure traffic is only routed to healthy servers."}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"graph TD\n    H1[Health Check Module] --\x3e|HTTP Ping| S1[Server 1]\n    H1 --\x3e|TCP Check| S2[Server 2]\n    H1 --\x3e|Latency Monitoring| S3[Server 3]"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Active Health Checks"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sends periodic probes (e.g., HTTP GET or TCP SYN) to each server."}),"\n",(0,r.jsx)(n.li,{children:"Marks servers as healthy/unhealthy based on responses."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Passive Monitoring"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitors real traffic for failures (e.g., 5xx responses) and adjusts routing dynamically."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"distributed-state-management",children:"Distributed State Management"}),"\n",(0,r.jsx)(n.p,{children:"In a distributed system, maintaining a consistent view of server health, traffic metrics, and configurations is crucial."}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"graph TD\n    C1[Control Plane] --\x3e DB1[Etcd or Consul]\n    DB1 --\x3e L1[Load Balancer Node 1]\n    DB1 --\x3e L2[Load Balancer Node 2]\n    DB1 --\x3e L3[Load Balancer Node 3]"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"State Consistency"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Uses distributed key-value stores (e.g., ",(0,r.jsx)(n.strong,{children:"Etcd"}),", ",(0,r.jsx)(n.strong,{children:"Zookeeper"}),") to replicate state across nodes."]}),"\n",(0,r.jsxs)(n.li,{children:["Implements consensus protocols like ",(0,r.jsx)(n.strong,{children:"Raft"})," or ",(0,r.jsx)(n.strong,{children:"Paxos"})," to ensure consistency."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamic Updates"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Allows real-time updates to routing rules and configurations without downtime."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"high-availability-and-failover",children:"High Availability and Failover"}),"\n",(0,r.jsx)(n.p,{children:"Distributed load balancers are designed to handle failures gracefully."}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"graph TD\n    Client1[Client] --\x3e LB1[Load Balancer Node 1]\n    LB1 --\x3e|Healthy| S1[Server 1]\n    LB1 --\x3e|Healthy| S2[Server 2]\n    LB1 --\x3e|Unhealthy| S3[Server 3]\n    LB1 --\x3e LB2[Load Balancer Node 2 for Failover]"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Redundancy"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Deploy multiple load balancer nodes in different regions."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Failover"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If a node goes down, traffic is redirected to other nodes."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Leader Election"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses consensus algorithms to elect a new leader node for coordination."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"dynamic-scaling",children:"Dynamic Scaling"}),"\n",(0,r.jsx)(n.p,{children:"Distributed load balancers adapt to varying traffic loads."}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"graph TD\n    M1[Monitoring System] --\x3e T1[CPU/Memory Check]\n    T1 --\x3e A1[Autoscaler]\n    A1 --\x3e|Scale Out| S1[New Server]"})}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Autoscaling"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitors traffic and server metrics to add/remove servers dynamically."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Traffic Redistribution"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Updates routing tables to balance the load across new servers."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-considerations",children:"Key Considerations"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Performance"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use efficient I/O models and caching to reduce latency."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Security"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Encrypt traffic with SSL/TLS and sanitize headers."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Fault Tolerance"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Implement redundancy at every layer."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["Here's a simple Python-based load balancer using the ",(0,r.jsx)(n.code,{children:"socket"})," library. This load balancer will listen on a specific port, forward incoming requests to multiple backend servers in a round-robin fashion, and then return the response from the backend server to the client."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"import socket\nimport threading\n\n# List of backend servers (IP, PORT)\nbackend_servers = [\n    ('127.0.0.1', 8001),\n    ('127.0.0.1', 8002),\n    ('127.0.0.1', 8003)\n]\n\n# Round-robin index to distribute the load\nround_robin_index = 0\n\ndef handle_client(client_socket):\n    global round_robin_index\n\n    # Select backend server in a round-robin manner\n    backend_ip, backend_port = backend_servers[round_robin_index]\n    round_robin_index = (round_robin_index + 1) % len(backend_servers)\n\n    # Connect to the selected backend server\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as backend_socket:\n        backend_socket.connect((backend_ip, backend_port))\n\n        # Receive data from the client\n        client_data = client_socket.recv(1024)\n\n        # Send the data to the backend server\n        backend_socket.sendall(client_data)\n\n        # Receive the response from the backend server\n        backend_response = backend_socket.recv(1024)\n\n        # Send the response back to the client\n        client_socket.sendall(backend_response)\n\n    # Close the client connection\n    client_socket.close()\n\ndef start_load_balancer(host, port):\n    # Create a server socket to listen for incoming client requests\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server_socket:\n        server_socket.bind((host, port))\n        server_socket.listen(5)\n        print(f\"Load Balancer listening on {host}:{port}...\")\n\n        while True:\n            # Accept incoming client connection\n            client_socket, client_address = server_socket.accept()\n            print(f\"Received connection from {client_address}\")\n\n            # Handle the client in a new thread\n            client_thread = threading.Thread(target=handle_client, args=(client_socket,))\n            client_thread.start()\n\nif __name__ == \"__main__\":\n    # Start the load balancer on port 9000\n    start_load_balancer('127.0.0.1', 9000)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"explanation",children:"Explanation"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Backend Servers:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"backend_servers"})," list contains the IP addresses and ports of the backend servers to which the load balancer will forward traffic."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Round-robin Load Balancing:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The load balancer uses a simple round-robin strategy to distribute incoming requests to the backend servers. The ",(0,r.jsx)(n.code,{children:"round_robin_index"})," variable is incremented after each request to ensure the next request is sent to the next backend server in the list."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Handling Client Requests:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"When the load balancer receives a client request, it establishes a connection to the selected backend server, sends the client request to the server, and then forwards the response back to the client."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Multithreading:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["To handle multiple client requests concurrently, each client connection is handled in a separate thread using Python's ",(0,r.jsx)(n.code,{children:"threading"})," module."]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Running the Load Balancer:"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The load balancer listens on ",(0,r.jsx)(n.code,{children:"127.0.0.1:9000"})," (localhost and port 9000). We can modify this to run on a different host and port if needed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"testing-the-load-balancer",children:"Testing the Load Balancer"}),"\n",(0,r.jsx)(n.p,{children:"To test this load balancer, we would need to run a few backend servers (e.g., simple Python HTTP servers) on different ports (e.g., 8001, 8002, 8003). Here\u2019s how we can do that using Python\u2019s built-in HTTP server module:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"# Start backend server on port 8001\npython -m http.server 8001\n\n# Start backend server on port 8002\npython -m http.server 8002\n\n# Start backend server on port 8003\npython -m http.server 8003\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then, run the load balancer script. We can test it by sending HTTP requests to the load balancer's address (",(0,r.jsx)(n.code,{children:"127.0.0.1:9000"}),"). The load balancer will forward requests to the backend servers in a round-robin fashion."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var i=s(96540);const r={},l=i.createContext(r);function t(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);