"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[6164],{29857:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"frameworks-libraries/frontend/react/performance-optimization","title":"Performance Optimization","description":"In React, performance optimization is crucial to ensure that your application remains fast, responsive, and scalable, especially as the size of the application grows. React provides various techniques and tools to optimize the rendering process, reduce unnecessary re-renders, and improve load times.","source":"@site/docs/frameworks-libraries/frontend/react/performance-optimization.md","sourceDirName":"frameworks-libraries/frontend/react","slug":"/frameworks-libraries/frontend/react/performance-optimization","permalink":"/docs/frameworks-libraries/frontend/react/performance-optimization","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/frameworks-libraries/frontend/react/performance-optimization.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1749212834000,"sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"Imperative React","permalink":"/docs/frameworks-libraries/frontend/react/imperative-react"},"next":{"title":"Styling","permalink":"/docs/frameworks-libraries/frontend/react/styling"}}');var i=o(74848),s=o(28453);const r={sidebar_position:10},a="Performance Optimization",l={},d=[{value:"React.memo",id:"reactmemo",level:2},{value:"How <code>React.memo</code> Works",id:"how-reactmemo-works",level:3},{value:"Example",id:"example",level:3},{value:"When to Use <code>React.memo</code>",id:"when-to-use-reactmemo",level:3},{value:"PureComponent",id:"purecomponent",level:2},{value:"How <code>PureComponent</code> Works",id:"how-purecomponent-works",level:3},{value:"Example",id:"example-1",level:3},{value:"When to Use <code>PureComponent</code>",id:"when-to-use-purecomponent",level:3},{value:"Virtual DOM",id:"virtual-dom",level:2},{value:"How the Virtual DOM Works",id:"how-the-virtual-dom-works",level:3},{value:"Benefits of Virtual DOM",id:"benefits-of-virtual-dom",level:3},{value:"Example",id:"example-2",level:3},{value:"Code Splitting",id:"code-splitting",level:2},{value:"How Code Splitting Works",id:"how-code-splitting-works",level:3},{value:"Example with Dynamic Imports",id:"example-with-dynamic-imports",level:3},{value:"Lazy Loading",id:"lazy-loading",level:2},{value:"How Lazy Loading Works",id:"how-lazy-loading-works",level:3},{value:"Example of Lazy Loading",id:"example-of-lazy-loading",level:3},{value:"When to Use Lazy Loading",id:"when-to-use-lazy-loading",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"performance-optimization",children:"Performance Optimization"})}),"\n",(0,i.jsx)(n.p,{children:"In React, performance optimization is crucial to ensure that your application remains fast, responsive, and scalable, especially as the size of the application grows. React provides various techniques and tools to optimize the rendering process, reduce unnecessary re-renders, and improve load times."}),"\n",(0,i.jsx)(n.h2,{id:"reactmemo",children:"React.memo"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"React.memo"})," is a higher-order component (HOC) that helps optimize the performance of ",(0,i.jsx)(n.strong,{children:"functional components"})," by memoizing their output. This prevents unnecessary re-renders when the props passed to the component have not changed."]}),"\n",(0,i.jsxs)(n.h3,{id:"how-reactmemo-works",children:["How ",(0,i.jsx)(n.code,{children:"React.memo"})," Works"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"By default, functional components re-render whenever their parent component re-renders, even if the props they receive have not changed."}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"React.memo"})," compares the current and previous props, and if they are the same, it skips re-rendering the component."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React from "react";\n\nconst ChildComponent = React.memo(({ data }) => {\n  console.log("ChildComponent rendered");\n  return <div>{data}</div>;\n});\n\nfunction ParentComponent() {\n  const [count, setCount] = React.useState(0);\n  const data = "Hello, World!";\n\n  return (\n    <div>\n      <ChildComponent data={data} />\n      <button onClick={() => setCount(count + 1)}>Increase Count</button>\n    </div>\n  );\n}\n\nexport default ParentComponent;\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ChildComponent"})," is wrapped in ",(0,i.jsx)(n.code,{children:"React.memo"}),". This means the child component will only re-render when the ",(0,i.jsx)(n.code,{children:"data"})," prop changes."]}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"setCount"})," is called and the ",(0,i.jsx)(n.code,{children:"data"})," prop doesn't change, the child component will not re-render, resulting in better performance."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"when-to-use-reactmemo",children:["When to Use ",(0,i.jsx)(n.code,{children:"React.memo"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"React.memo"})," when a component is purely presentational and does not need to re-render unless its props change."]}),"\n",(0,i.jsx)(n.li,{children:"It is beneficial for components that receive complex objects or arrays as props, as React\u2019s default shallow comparison may not catch deep changes."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"purecomponent",children:"PureComponent"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"PureComponent"})," is a class component version of ",(0,i.jsx)(n.code,{children:"React.memo"}),". It automatically implements ",(0,i.jsx)(n.code,{children:"shouldComponentUpdate"})," with a shallow comparison of both ",(0,i.jsx)(n.code,{children:"props"})," and ",(0,i.jsx)(n.code,{children:"state"}),"."]}),"\n",(0,i.jsxs)(n.h3,{id:"how-purecomponent-works",children:["How ",(0,i.jsx)(n.code,{children:"PureComponent"})," Works"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When a component extends ",(0,i.jsx)(n.code,{children:"React.PureComponent"}),", it avoids unnecessary re-renders by comparing the new props and state with the previous ones using a shallow comparison."]}),"\n",(0,i.jsx)(n.li,{children:"If the props or state have not changed, React will skip re-rendering the component."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-1",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { PureComponent } from "react";\n\nclass ChildComponent extends PureComponent {\n  render() {\n    console.log("ChildComponent rendered");\n    return <div>{this.props.data}</div>;\n  }\n}\n\nclass ParentComponent extends React.Component {\n  state = { count: 0, data: "Hello, World!" };\n\n  render() {\n    return (\n      <div>\n        <ChildComponent data={this.state.data} />\n        <button onClick={() => this.setState({ count: this.state.count + 1 })}>\n          Increase Count\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default ParentComponent;\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ChildComponent"})," extends ",(0,i.jsx)(n.code,{children:"PureComponent"}),", so it will only re-render when the ",(0,i.jsx)(n.code,{children:"data"})," prop changes."]}),"\n",(0,i.jsxs)(n.li,{children:["If only the ",(0,i.jsx)(n.code,{children:"count"})," state in the ",(0,i.jsx)(n.code,{children:"ParentComponent"})," changes, ",(0,i.jsx)(n.code,{children:"ChildComponent"})," will not re-render, improving performance."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"when-to-use-purecomponent",children:["When to Use ",(0,i.jsx)(n.code,{children:"PureComponent"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Use ",(0,i.jsx)(n.code,{children:"PureComponent"})," for class components that receive simple props and do not require deep comparison of props or state."]}),"\n",(0,i.jsxs)(n.li,{children:["Avoid ",(0,i.jsx)(n.code,{children:"PureComponent"})," for components that receive complex objects or arrays, as shallow comparison may not catch deep changes."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"virtual-dom",children:"Virtual DOM"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Virtual DOM"})," (VDOM) is an in-memory representation of the real DOM. React uses the virtual DOM to optimize updates and re-renders, which significantly improves performance."]}),"\n",(0,i.jsx)(n.h3,{id:"how-the-virtual-dom-works",children:"How the Virtual DOM Works"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initial Render:"})," When a React component is rendered, it generates a virtual DOM tree, which is a lightweight copy of the actual DOM."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State or Prop Change:"})," When the state or props of a component change, React creates a new virtual DOM tree."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Diffing Algorithm:"}),' React compares the new virtual DOM with the previous one (this process is called "reconciliation").']}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimal Updates:"}),' React determines the differences (or "diffs") between the old and new virtual DOM trees and calculates the minimal set of changes required to update the real DOM.']}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"benefits-of-virtual-dom",children:"Benefits of Virtual DOM"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Faster Updates:"})," Since the virtual DOM is much faster to manipulate than the actual DOM, React can update it quickly and then apply only the necessary changes to the real DOM."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Batching:"})," React batches updates to the DOM, reducing the number of reflows and repaints, which improves performance."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-2",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:"function MyComponent() {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  );\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["When the ",(0,i.jsx)(n.code,{children:"setCount"})," function is called, React updates the virtual DOM first and then compares it with the previous virtual DOM. It only updates the part of the real DOM that needs to change, making the process efficient."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"code-splitting",children:"Code Splitting"}),"\n",(0,i.jsx)(n.p,{children:"Code splitting is a technique that involves breaking up your application into smaller bundles and loading them only when they are needed. This can significantly reduce the initial load time of your app."}),"\n",(0,i.jsxs)(n.p,{children:["React supports code splitting through dynamic imports and React's ",(0,i.jsx)(n.code,{children:"Suspense"})," component."]}),"\n",(0,i.jsx)(n.h3,{id:"how-code-splitting-works",children:"How Code Splitting Works"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Code splitting divides your app into smaller bundles that are loaded dynamically. React will load only the required bundles when the user navigates to different parts of the application."}),"\n",(0,i.jsx)(n.li,{children:"This results in faster initial page loads and reduced memory usage."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-with-dynamic-imports",children:"Example with Dynamic Imports"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { Suspense, lazy } from "react";\n\nconst MyComponent = lazy(() => import("./MyComponent"));\n\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <MyComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MyComponent"})," is dynamically imported using ",(0,i.jsx)(n.code,{children:"React.lazy()"}),". The component will be loaded only when it is needed."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"Suspense"})," component is used to show a loading state while the component is being fetched."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"lazy-loading",children:"Lazy Loading"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Lazy loading"})," is a technique where components are loaded only when they are needed, instead of loading everything upfront. This improves the initial load time by reducing the amount of JavaScript that needs to be executed."]}),"\n",(0,i.jsx)(n.h3,{id:"how-lazy-loading-works",children:"How Lazy Loading Works"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["React provides ",(0,i.jsx)(n.code,{children:"React.lazy()"})," to enable lazy loading for components."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"React.lazy()"})," allows you to define a component that will only be loaded when it is required."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Suspense"})," is used to show a fallback UI until the component is loaded."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"example-of-lazy-loading",children:"Example of Lazy Loading"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-jsx",children:'import React, { Suspense, lazy } from "react";\n\nconst SomeComponent = lazy(() => import("./SomeComponent"));\n\nfunction App() {\n  return (\n    <div>\n      <Suspense fallback={<div>Loading...</div>}>\n        <SomeComponent />\n      </Suspense>\n    </div>\n  );\n}\n\nexport default App;\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"SomeComponent"})," is lazily loaded when it's required."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"Suspense"})," component handles the fallback UI while the component is being loaded."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-lazy-loading",children:"When to Use Lazy Loading"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Use lazy loading for large components or parts of your app that are not immediately necessary."}),"\n",(0,i.jsx)(n.li,{children:"It\u2019s especially useful in scenarios where the initial load time is critical, such as on mobile devices or for large-scale web apps."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},28453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>a});var t=o(96540);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);