"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[4123],{39635:(e,s,r)=>{r.r(s),r.d(s,{assets:()=>t,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"databases/database-engineering/cursor","title":"Cursors","description":"A cursor in database management systems (DBMS) is a database object used to retrieve, manipulate, and traverse rows of a result set returned by a query. It acts as a pointer that allows the application to iterate over a set of records one at a time. Cursors are particularly useful when dealing with large datasets or when you need to perform row-by-row operations (like updates or complex calculations) that cannot be achieved in a single SQL query.","source":"@site/docs/databases/database-engineering/cursor.md","sourceDirName":"databases/database-engineering","slug":"/databases/database-engineering/cursor","permalink":"/docs/databases/database-engineering/cursor","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/databases/database-engineering/cursor.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735558067000,"sidebarPosition":11,"frontMatter":{"sidebar_position":11},"sidebar":"tutorialSidebar","previous":{"title":"Replication","permalink":"/docs/databases/database-engineering/replication"},"next":{"title":"Introduction","permalink":"/docs/databases/database-systems/introduction"}}');var i=r(74848),l=r(28453);const o={sidebar_position:11},a="Cursors",t={},c=[{value:"Types of Cursors",id:"types-of-cursors",level:2},{value:"Implicit Cursors",id:"implicit-cursors",level:3},{value:"Explicit Cursors",id:"explicit-cursors",level:3},{value:"Types of Cursors Based on Behavior",id:"types-of-cursors-based-on-behavior",level:2},{value:"Static Cursor",id:"static-cursor",level:3},{value:"Dynamic Cursor",id:"dynamic-cursor",level:3},{value:"Forward-Only Cursor",id:"forward-only-cursor",level:3},{value:"Scroll Cursor",id:"scroll-cursor",level:3},{value:"Read-Only Cursor",id:"read-only-cursor",level:3},{value:"Updatable Cursor",id:"updatable-cursor",level:3},{value:"Cursors Based on Location (Server vs Client)",id:"cursors-based-on-location-server-vs-client",level:2},{value:"Server Cursor",id:"server-cursor",level:3},{value:"Client Cursor",id:"client-cursor",level:3},{value:"Cursor Life Cycle",id:"cursor-life-cycle",level:2},{value:"Declare",id:"declare",level:3},{value:"Open",id:"open",level:3},{value:"Fetch",id:"fetch",level:3},{value:"Close",id:"close",level:3},{value:"Deallocate",id:"deallocate",level:3},{value:"Use Cases for Cursors",id:"use-cases-for-cursors",level:2},{value:"Row-by-Row Processing",id:"row-by-row-processing",level:3},{value:"Data Migration",id:"data-migration",level:3},{value:"Batch Processing",id:"batch-processing",level:3},{value:"Reporting",id:"reporting",level:3},{value:"Complex Data Manipulations",id:"complex-data-manipulations",level:3},{value:"Pros and Cons of Using Cursors",id:"pros-and-cons-of-using-cursors",level:2},{value:"Pros",id:"pros",level:3},{value:"Cons",id:"cons",level:3}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"cursors",children:"Cursors"})}),"\n",(0,i.jsxs)(s.p,{children:["A ",(0,i.jsx)(s.strong,{children:"cursor"})," in database management systems (DBMS) is a database object used to retrieve, manipulate, and traverse rows of a result set returned by a query. It acts as a pointer that allows the application to iterate over a set of records one at a time. Cursors are particularly useful when dealing with large datasets or when you need to perform row-by-row operations (like updates or complex calculations) that cannot be achieved in a single SQL query."]}),"\n",(0,i.jsx)(s.h2,{id:"types-of-cursors",children:"Types of Cursors"}),"\n",(0,i.jsxs)(s.p,{children:["Cursors are primarily classified based on their ",(0,i.jsx)(s.strong,{children:"scope"})," (how they handle result sets) and their ",(0,i.jsx)(s.strong,{children:"behavior"})," (how they interact with the data)."]}),"\n",(0,i.jsx)(s.h3,{id:"implicit-cursors",children:"Implicit Cursors"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"These are automatically created by the DBMS when an SQL statement is executed that returns a result."}),"\n",(0,i.jsx)(s.li,{children:"The database system internally manages these cursors, so users do not explicitly declare or open them."}),"\n",(0,i.jsxs)(s.li,{children:["Example: In SQL, a ",(0,i.jsx)(s.code,{children:"SELECT"})," query without explicitly defining a cursor results in an implicit cursor being used by the DBMS."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"explicit-cursors",children:"Explicit Cursors"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"These cursors are defined and controlled explicitly by the user."}),"\n",(0,i.jsx)(s.li,{children:"Users declare, open, fetch, and close them, offering full control over the query execution process."}),"\n",(0,i.jsx)(s.li,{children:"Explicit cursors are typically used when the result set is large or when complex, row-by-row operations are needed."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Examples"}),": ",(0,i.jsx)(s.code,{children:"DECLARE CURSOR"})," in SQL (used in databases like PostgreSQL, Oracle)."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"types-of-cursors-based-on-behavior",children:"Types of Cursors Based on Behavior"}),"\n",(0,i.jsx)(s.h3,{id:"static-cursor",children:"Static Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A static cursor makes a snapshot of the result set when it is opened and does not reflect changes made to the data after the cursor is opened."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use case"}),": Ideal for reporting scenarios where the data doesn't change during the operation."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"dynamic-cursor",children:"Dynamic Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A dynamic cursor reflects changes to the underlying data during cursor operations, such as insertions, deletions, or updates."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use case"}),": Useful in real-time applications where data may change while the cursor is in use."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"forward-only-cursor",children:"Forward-Only Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"This type of cursor only allows moving forward through the result set, and once a row is fetched, it cannot be retrieved again."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use case"}),": Often used when data is being processed sequentially."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"scroll-cursor",children:"Scroll Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A scroll cursor allows movement both forward and backward through the result set."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use case"}),": Useful when you need random access to rows and may need to navigate in both directions."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"read-only-cursor",children:"Read-Only Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A read-only cursor allows only retrieval of data and not any modifications."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use case"}),": Used when you only need to display data, not alter it."]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"updatable-cursor",children:"Updatable Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"An updatable cursor allows for both retrieving and modifying data."}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Use case"}),": Used when you need to process rows and possibly update the underlying database."]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"cursors-based-on-location-server-vs-client",children:"Cursors Based on Location (Server vs Client)"}),"\n",(0,i.jsx)(s.h3,{id:"server-cursor",children:"Server Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"The cursor is managed and stored on the database server."}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"The server handles the cursor\u2019s life cycle, including opening, fetching, and closing."}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Advantages"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Reduces network traffic as the database server processes the data and only sends required rows to the client."}),"\n",(0,i.jsx)(s.li,{children:"More efficient for large datasets because the client only fetches the data as needed."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Disadvantages"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Can put a load on the database server, especially for long-running queries."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Examples"}),": In databases like Oracle or SQL Server, the server handles the cursor in the back-end, and clients fetch rows from it."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"client-cursor",children:"Client Cursor"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"The cursor is managed on the client-side, with the client application handling the cursor\u2019s lifecycle."}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsx)(s.p,{children:"This involves fetching the entire result set from the server into memory, after which the application iterates over the rows locally."}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Advantages"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Reduces load on the database server as it does not have to manage the cursor."}),"\n",(0,i.jsx)(s.li,{children:"Better control over the result set on the client-side."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Disadvantages"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"High memory consumption as the entire result set must be transferred and stored locally."}),"\n",(0,i.jsx)(s.li,{children:"Slower performance with large datasets due to the transfer of all rows to the client."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Examples"}),": When using ODBC (Open Database Connectivity) or JDBC (Java Database Connectivity) in a client-server environment."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"cursor-life-cycle",children:"Cursor Life Cycle"}),"\n",(0,i.jsx)(s.p,{children:"The life cycle of a cursor involves several stages:"}),"\n",(0,i.jsx)(s.h3,{id:"declare",children:"Declare"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"A cursor is declared with a SQL query that defines the result set. This step does not execute the query but simply prepares it for use."}),"\n",(0,i.jsxs)(s.li,{children:["Example (in SQL):","\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"DECLARE cursor_name CURSOR FOR SELECT column1, column2 FROM table;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"open",children:"Open"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"The cursor is opened, executing the associated query and allocating resources. This step positions the cursor before the first row of the result set."}),"\n",(0,i.jsxs)(s.li,{children:["Example:","\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"OPEN cursor_name;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"fetch",children:"Fetch"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["The ",(0,i.jsx)(s.code,{children:"FETCH"})," operation retrieves one or more rows from the result set. After each fetch, the cursor moves to the next row."]}),"\n",(0,i.jsxs)(s.li,{children:["Example:","\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"FETCH NEXT FROM cursor_name INTO @variable1, @variable2;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"close",children:"Close"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"After all required operations are completed, the cursor is closed, releasing any associated resources."}),"\n",(0,i.jsxs)(s.li,{children:["Example:","\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"CLOSE cursor_name;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"deallocate",children:"Deallocate"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Optionally, after the cursor is closed, the cursor is deallocated to remove it from memory."}),"\n",(0,i.jsxs)(s.li,{children:["Example:","\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-sql",children:"DEALLOCATE cursor_name;\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"use-cases-for-cursors",children:"Use Cases for Cursors"}),"\n",(0,i.jsx)(s.h3,{id:"row-by-row-processing",children:"Row-by-Row Processing"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"When you need to process each row of a result set individually, such as calculating values or performing complex transformations."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"data-migration",children:"Data Migration"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Moving data from one database or table to another, where row-by-row processing is required, such as when transforming data during the migration."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"batch-processing",children:"Batch Processing"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Performing batch updates or complex operations where each row needs to be processed sequentially."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"reporting",children:"Reporting"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Generating reports that require complex calculations or aggregations on each row in the result set."}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"complex-data-manipulations",children:"Complex Data Manipulations"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"For operations like auditing, where you need to check or modify data based on certain conditions on a row-by-row basis."}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"pros-and-cons-of-using-cursors",children:"Pros and Cons of Using Cursors"}),"\n",(0,i.jsx)(s.h3,{id:"pros",children:"Pros"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Fine-Grained Control"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Cursors provide full control over the retrieval and manipulation of each row, useful for complex operations that cannot be performed in a single SQL query."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Flexibility"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"They allow for operations like updates or inserts to be performed one row at a time, making it easier to manage large datasets or perform custom logic on each row."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Error Handling"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Cursors allow for more detailed error handling, as the application can control the process and manage issues one row at a time."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"cons",children:"Cons"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Performance Overhead"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Cursors can be slower than set-based operations. Fetching data row by row is inefficient for large datasets compared to operations that return results in bulk."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Resource Intensive"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Cursors consume significant memory, especially on the server-side (in the case of server cursors). Each open cursor uses resources, and if not properly closed, they can lead to resource leaks."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Complexity"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Using cursors introduces additional complexity in managing their lifecycle (open, fetch, close, deallocate), which can lead to code maintenance challenges."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Potential for Deadlocks"}),":"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Long-running cursors, especially those with large result sets, can hold locks on database resources for extended periods, increasing the risk of deadlocks."}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,l.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,s,r)=>{r.d(s,{R:()=>o,x:()=>a});var n=r(96540);const i={},l=n.createContext(i);function o(e){const s=n.useContext(l);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(l.Provider,{value:s},e.children)}}}]);