"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[9278],{28241:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"programming/programming-languages/python/multiprocessing","title":"Multiprocessing","description":"Multiprocessing is Python\'s solution to achieving true parallelism by running multiple processes simultaneously. Unlike threading (which shares memory but is limited by the GIL), multiprocessing creates separate Python processes, each with its own memory space and Python interpreter.","source":"@site/docs/programming/programming-languages/python/multiprocessing.md","sourceDirName":"programming/programming-languages/python","slug":"/programming/programming-languages/python/multiprocessing","permalink":"/docs/programming/programming-languages/python/multiprocessing","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming/programming-languages/python/multiprocessing.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1749211863000,"sidebarPosition":14,"frontMatter":{"sidebar_position":14},"sidebar":"tutorialSidebar","previous":{"title":"Threading","permalink":"/docs/programming/programming-languages/python/threads"},"next":{"title":"Asynchronous Programming","permalink":"/docs/programming/programming-languages/python/async"}}');var i=s(74848),o=s(28453);const t={sidebar_position:14},a="Multiprocessing",l={},c=[{value:"Key Advantages",id:"key-advantages",level:2},{value:"Basic Example: Running Simple Processes",id:"basic-example-running-simple-processes",level:2},{value:"Process Pools",id:"process-pools",level:2},{value:"Key Methods",id:"key-methods",level:3},{value:"Basic Example",id:"basic-example",level:3},{value:"Async Example (Non-Blocking)",id:"async-example-non-blocking",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"When to Use Process Pools?",id:"when-to-use-process-pools",level:3},{value:"Sharing Data Between Processes",id:"sharing-data-between-processes",level:2},{value:"Using Queues for Communication",id:"using-queues-for-communication",level:3},{value:"Shared Memory with Value and Array",id:"shared-memory-with-value-and-array",level:3},{value:"Synchronization Between Processes",id:"synchronization-between-processes",level:2},{value:"Using Locks for Safe Access",id:"using-locks-for-safe-access",level:3},{value:"When to Use Multiprocessing?",id:"when-to-use-multiprocessing",level:2},{value:"Good Use Cases",id:"good-use-cases",level:3},{value:"When to Avoid",id:"when-to-avoid",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"multiprocessing",children:"Multiprocessing"})}),"\n",(0,i.jsx)(n.p,{children:"Multiprocessing is Python's solution to achieving true parallelism by running multiple processes simultaneously. Unlike threading (which shares memory but is limited by the GIL), multiprocessing creates separate Python processes, each with its own memory space and Python interpreter."}),"\n",(0,i.jsx)(n.h2,{id:"key-advantages",children:"Key Advantages"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"True parallel execution"})," (no GIL limitations)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Better CPU utilization"})," for computation-heavy tasks"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Process isolation"})," prevents memory corruption"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Crash resilience"})," (one process crashing doesn't affect others)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-example-running-simple-processes",children:"Basic Example: Running Simple Processes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from multiprocessing import Process\nimport os\n\ndef task(name):\n    """A simple task that prints process info"""\n    print(f"Task {name} running in process {os.getpid()}")\n\nif __name__ == \'__main__\':\n    # Create 3 processes\n    processes = []\n    for i in range(3):\n        p = Process(target=task, args=(f"Job-{i}",))\n        processes.append(p)\n        p.start()  # Launch the process\n\n    # Wait for all to complete\n    for p in processes:\n        p.join()\n\n    print("All processes completed")\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["We define a ",(0,i.jsx)(n.code,{children:"task()"})," function that each process will run"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Process()"})," creates a new process (but doesn't start it yet)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"start()"})," launches the process"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"join()"})," makes the main program wait for child processes"]}),"\n",(0,i.jsx)(n.li,{children:"Each process gets its own PID (process ID)"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"process-pools",children:"Process Pools"}),"\n",(0,i.jsx)(n.p,{children:"Process pools create a fixed number of worker processes that can handle multiple tasks efficiently. They:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Maintain reusable worker processes (avoid creation overhead)"}),"\n",(0,i.jsx)(n.li,{children:"Automatically distribute tasks"}),"\n",(0,i.jsx)(n.li,{children:"Collect results in order"}),"\n",(0,i.jsx)(n.li,{children:"Are ideal for parallelizing CPU-bound operations"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"key-methods",children:"Key Methods"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"map()"})," - Parallel version of built-in ",(0,i.jsx)(n.code,{children:"map()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"apply()"})," - Run one task at a time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"map_async()"})," - Non-blocking ",(0,i.jsx)(n.code,{children:"map()"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"apply_async()"})," - Non-blocking ",(0,i.jsx)(n.code,{children:"apply()"})]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"basic-example",children:"Basic Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from multiprocessing import Pool\nimport time\n\ndef square(x):\n    print(f"Processing {x}")\n    time.sleep(1)  # Simulate work\n    return x * x\n\nif __name__ == \'__main__\':\n    numbers = [1, 2, 3, 4, 5]\n\n    # Create pool with 3 workers\n    with Pool(3) as pool:\n        results = pool.map(square, numbers)\n\n    print(f"Squares: {results}")\n    # Output after ~2 seconds (not 5):\n    # [1, 4, 9, 16, 25]\n'})}),"\n",(0,i.jsx)(n.h3,{id:"async-example-non-blocking",children:"Async Example (Non-Blocking)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from multiprocessing import Pool\n\ndef cube(x):\n    return x ** 3\n\nif __name__ == '__main__':\n    with Pool() as pool:  # Defaults to CPU count\n        async_result = pool.map_async(cube, [1, 2, 3])\n\n        # Do other work here while processing...\n        print(\"Main thread working...\")\n\n        # Get results when ready\n        print(async_result.get())  # [1, 8, 27]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def safe_divide(x):\n    try:\n        return 100 / x\n    except Exception as e:\n        return f\"Error: {e}\"\n\nwith Pool(2) as pool:\n    print(pool.map(safe_divide, [10, 0, 5]))\n    # [10.0, 'Error: division by zero', 20.0]\n"})}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-process-pools",children:"When to Use Process Pools?"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Batch processing similar operations"}),"\n",(0,i.jsx)(n.li,{children:"CPU-bound tasks with independent data"}),"\n",(0,i.jsx)(n.li,{children:"When you need ordered results"}),"\n",(0,i.jsx)(n.li,{children:"For better resource management than manual processes"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"sharing-data-between-processes",children:"Sharing Data Between Processes"}),"\n",(0,i.jsx)(n.p,{children:"Since processes don't share memory by default, we need special techniques:"}),"\n",(0,i.jsx)(n.h3,{id:"using-queues-for-communication",children:"Using Queues for Communication"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from multiprocessing import Process, Queue\n\ndef producer(queue, items):\n    """Adds items to a shared queue"""\n    for item in items:\n        print(f"Producing {item}")\n        queue.put(item)\n\ndef consumer(queue):\n    """Processes items from queue"""\n    while True:\n        item = queue.get()\n        if item is None:  # Poison pill to stop\n            break\n        print(f"Consuming {item}")\n\nif __name__ == \'__main__\':\n    q = Queue()\n    items = [\'A\', \'B\', \'C\', \'D\']\n\n    # Start producer and consumer\n    p1 = Process(target=producer, args=(q, items))\n    p2 = Process(target=consumer, args=(q,))\n\n    p1.start()\n    p2.start()\n\n    p1.join()\n    q.put(None)  # Signal consumer to stop\n    p2.join()\n'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Explanation:"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Queue()"})," creates a process-safe FIFO queue"]}),"\n",(0,i.jsx)(n.li,{children:"Producer puts items in queue"}),"\n",(0,i.jsx)(n.li,{children:"Consumer takes items out"}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"None"}),' acts as a "poison pill" to stop consumer']}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"shared-memory-with-value-and-array",children:"Shared Memory with Value and Array"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from multiprocessing import Process, Value, Array\n\ndef increment_counter(counter):\n    """Modifies a shared counter"""\n    for _ in range(1000):\n        counter.value += 1\n\ndef modify_array(arr):\n    """Changes shared array elements"""\n    for i in range(len(arr)):\n        arr[i] *= 2\n\nif __name__ == \'__main__\':\n    # Shared integer\n    counter = Value(\'i\', 0)  # \'i\' = signed integer\n\n    # Shared array\n    arr = Array(\'d\', [1.0, 2.0, 3.0])  # \'d\' = double\n\n    # Create processes\n    p1 = Process(target=increment_counter, args=(counter,))\n    p2 = Process(target=modify_array, args=(arr,))\n\n    p1.start()\n    p2.start()\n\n    p1.join()\n    p2.join()\n\n    print(f"Final counter: {counter.value}")\n    print(f"Modified array: {list(arr)}")\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note:"})," For shared variables, you should use locks to prevent race conditions."]}),"\n",(0,i.jsx)(n.h2,{id:"synchronization-between-processes",children:"Synchronization Between Processes"}),"\n",(0,i.jsx)(n.h3,{id:"using-locks-for-safe-access",children:"Using Locks for Safe Access"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'from multiprocessing import Process, Lock, Value\nimport time\n\ndef safe_increment(lock, counter):\n    """Thread-safe counter increment"""\n    for _ in range(5):\n        time.sleep(0.1)  # Simulate work\n        with lock:\n            counter.value += 1\n            print(f"Process {os.getpid()} incremented to {counter.value}")\n\nif __name__ == \'__main__\':\n    lock = Lock()\n    counter = Value(\'i\', 0)\n\n    processes = []\n    for _ in range(3):\n        p = Process(target=safe_increment, args=(lock, counter))\n        processes.append(p)\n        p.start()\n\n    for p in processes:\n        p.join()\n\n    print(f"Final counter value: {counter.value}")\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Concepts"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Lock()"})," creates a process-safe lock"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"with lock:"})," creates a critical section"]}),"\n",(0,i.jsx)(n.li,{children:"Only one process can execute the locked code at a time"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"when-to-use-multiprocessing",children:"When to Use Multiprocessing?"}),"\n",(0,i.jsx)(n.h3,{id:"good-use-cases",children:"Good Use Cases"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Number crunching"})," (math, statistics)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Machine learning"})," model training"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Data processing"})," (large datasets)"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.strong,{children:"Image/video processing"})}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"when-to-avoid",children:"When to Avoid"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Simple scripts"})," (overhead isn't worth it)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"I/O-bound tasks"})," (use threading or asyncio instead)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"When sharing lots of data"})," (IPC has overhead)"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:["Use ",(0,i.jsx)(n.code,{children:"if __name__ == '__main__':"})]})," to prevent infinite process spawning"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prefer Pool for batch processing"})," when possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimize shared state"})," - processes work best when independent"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use queues instead of shared memory"})," when possible"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Consider ProcessPoolExecutor"})," for future compatibility"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>a});var r=s(96540);const i={},o=r.createContext(i);function t(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);