"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[993],{6395:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"programming-languages/python/data-structure","title":"Common Data Structures in Python","description":"An overview of common data structures in Python, including properties, pros, cons, and mutability.","source":"@site/docs/programming-languages/python/data-structure.md","sourceDirName":"programming-languages/python","slug":"/programming-languages/python/data-structure","permalink":"/docs/programming-languages/python/data-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/programming-languages/python/data-structure.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1734169521000,"sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Variable Scoping","permalink":"/docs/programming-languages/python/scoping"}}');var r=s(4848),t=s(8453);const l={sidebar_position:4},d="Common Data Structures in Python",o={},c=[{value:"Lists",id:"lists",level:2},{value:"Tuples",id:"tuples",level:2},{value:"Sets",id:"sets",level:2},{value:"Dictionaries",id:"dictionaries",level:2},{value:"Strings",id:"strings",level:2},{value:"Byte Arrays and Bytes",id:"byte-arrays-and-bytes",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Deque",id:"deque",level:2},{value:"Heaps",id:"heaps",level:2},{value:"Named Tuples",id:"named-tuples",level:2},{value:"Summary Table of Common Python",id:"summary-table-of-common-python",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"common-data-structures-in-python",children:"Common Data Structures in Python"})}),"\n",(0,r.jsx)(n.p,{children:"An overview of common data structures in Python, including properties, pros, cons, and mutability."}),"\n",(0,r.jsx)(n.h2,{id:"lists",children:"Lists"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Ordered, mutable collection of items."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"my_list = [1, 2, 3]"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Mutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Dynamic: Can grow and shrink as needed."}),"\n",(0,r.jsx)(n.li,{children:"Supports heterogeneous data (elements of different types)."}),"\n",(0,r.jsx)(n.li,{children:"Supports indexing and slicing."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Slower in search operations compared to sets."}),"\n",(0,r.jsx)(n.li,{children:"More memory usage compared to arrays in other languages."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Managing ordered collections where you may need to add, modify, or remove elements frequently."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tuples",children:"Tuples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Ordered, immutable collection of items."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"my_tuple = (1, 2, 3)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Immutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Faster than lists due to immutability."}),"\n",(0,r.jsx)(n.li,{children:"Hashable (can be used as keys in dictionaries if they contain only hashable types)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Cannot be modified (added to, removed from, or updated)."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Storing fixed collections of items, like coordinates or configurations that should not change."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"sets",children:"Sets"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Unordered collection of unique items."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"my_set = {1, 2, 3}"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Mutable (also an immutable variant ",(0,r.jsx)(n.code,{children:"frozenset"}),")"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast membership testing and duplicates are automatically removed."}),"\n",(0,r.jsx)(n.li,{children:"Useful for mathematical set operations like union, intersection, and difference."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Unordered, so elements cannot be accessed by index."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Removing duplicates, mathematical set operations, or efficient membership testing."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"dictionaries",children:"Dictionaries"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Collection of key-value pairs, unordered until Python 3.7."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"my_dict = {'a': 1, 'b': 2}"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Mutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Provides fast lookups and updates using keys."}),"\n",(0,r.jsx)(n.li,{children:"Flexible for storing complex data with relationships."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses more memory due to hashing."}),"\n",(0,r.jsx)(n.li,{children:"Keys must be unique and hashable (immutable types like strings, numbers, or tuples)."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Mapping relationships between data, configuration settings, counting occurrences, or creating indexable objects."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"strings",children:"Strings"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Sequence of Unicode characters."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:'my_string = "Hello"'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Immutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Efficient memory management with rich functionality for string operations."}),"\n",(0,r.jsx)(n.li,{children:"Supports indexing and slicing."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Immutability requires creating a new string for modifications."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Text processing, storing fixed data that doesn\u2019t change, creating dictionary keys."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"byte-arrays-and-bytes",children:"Byte Arrays and Bytes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Byte-based data structures; ",(0,r.jsx)(n.code,{children:"bytes"})," is immutable, ",(0,r.jsx)(n.code,{children:"bytearray"})," is mutable."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:'my_bytes = b"hello"'})," and ",(0,r.jsx)(n.code,{children:'my_bytearray = bytearray(b"hello")'})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": ",(0,r.jsx)(n.code,{children:"bytes"})," is immutable; ",(0,r.jsx)(n.code,{children:"bytearray"})," is mutable."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Efficient for handling binary data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Limited operations compared to strings."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Handling data in binary format, image processing, file I/O, networking protocols."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"arrays",children:"Arrays"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Homogeneous, efficient sequence of numbers."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"import array; my_array = array.array('i', [1, 2, 3])"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Mutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": More memory-efficient than lists for large numeric data."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Limited to storing only numbers of a single type."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": High-performance applications where memory optimization for numeric data is critical."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"deque",children:"Deque"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Double-ended queue with fast appends and pops from both ends."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"from collections import deque; my_deque = deque([1, 2, 3])"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Mutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Optimized for adding/removing elements from both ends, unlike lists."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Slower random access compared to lists."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Implementing queues or stacks efficiently where both ends need frequent updates."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"heaps",children:"Heaps"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Min-heap, where the smallest element is always at the root."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"import heapq; my_heap = []; heapq.heappush(my_heap, 3)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Mutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Provides a priority queue implementation and efficient access to the smallest element."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Limited to min-heap by default; requires customization for max-heaps."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Priority queues, scheduling tasks, or finding the smallest/largest ",(0,r.jsx)(n.code,{children:"k"})," elements."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"named-tuples",children:"Named Tuples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Tuple-like data structure with named fields."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Syntax"}),": ",(0,r.jsx)(n.code,{children:"from collections import namedtuple; Point = namedtuple('Point', ['x', 'y']); p = Point(1, 2)"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mutability"}),": Immutable"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pros"}),": Readable, self-documenting code without using dictionaries."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Cons"}),": Immutable, so elements cannot be modified."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Cases"}),": Representing simple data structures where fields are fixed, like a coordinate point (x, y)."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary-table-of-common-python",children:"Summary Table of Common Python"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Data Structure"}),(0,r.jsx)(n.th,{children:"Ordered"}),(0,r.jsx)(n.th,{children:"Mutable"}),(0,r.jsx)(n.th,{children:"Unique Elements"}),(0,r.jsx)(n.th,{children:"Access Time"}),(0,r.jsx)(n.th,{children:"Use Case Examples"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"List"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"O(1) index"}),(0,r.jsx)(n.td,{children:"Dynamic, ordered collections"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Tuple"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"O(1) index"}),(0,r.jsx)(n.td,{children:"Immutable, ordered collections"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Set"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"O(1)"}),(0,r.jsx)(n.td,{children:"Unique elements, set operations"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Dictionary"}),(0,r.jsx)(n.td,{children:"No (until 3.7)"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Keys unique"}),(0,r.jsx)(n.td,{children:"O(1) key"}),(0,r.jsx)(n.td,{children:"Key-value pairs, fast lookup"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"String"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"O(1) index"}),(0,r.jsx)(n.td,{children:"Text processing, fixed data"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Bytearray"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"O(1) index"}),(0,r.jsx)(n.td,{children:"Binary data manipulation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Deque"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"N/A"}),(0,r.jsx)(n.td,{children:"O(1) ends"}),(0,r.jsx)(n.td,{children:"Queues, stacks"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Heap (heapq)"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"O(log n)"}),(0,r.jsxs)(n.td,{children:["Priority queues, top ",(0,r.jsx)(n.code,{children:"k"})," elements"]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Named Tuple"}),(0,r.jsx)(n.td,{children:"Yes"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"No"}),(0,r.jsx)(n.td,{children:"O(1) index"}),(0,r.jsx)(n.td,{children:"Readable tuple-like structures"})]})]})]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>d});var i=s(6540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);