"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[5982],{65053:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>t,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"data-structure-and-algorithms/algorithms/recursion","title":"Recursion","description":"Recursion is a programming technique where a function calls itself to solve a problem by reducing it to smaller instances of the same problem.","source":"@site/docs/data-structure-and-algorithms/algorithms/recursion.md","sourceDirName":"data-structure-and-algorithms/algorithms","slug":"/data-structure-and-algorithms/algorithms/recursion","permalink":"/docs/data-structure-and-algorithms/algorithms/recursion","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/data-structure-and-algorithms/algorithms/recursion.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1766931399000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction","permalink":"/docs/data-structure-and-algorithms/algorithms/introduction"},"next":{"title":"Arrays and Hashing","permalink":"/docs/data-structure-and-algorithms/algorithms/arrays-and-hasing"}}');var r=s(74848),a=s(28453);const t={sidebar_position:2},l="Recursion",c={},o=[{value:"Why recursion exists",id:"why-recursion-exists",level:2},{value:"Basic structure of a recursive function",id:"basic-structure-of-a-recursive-function",level:2},{value:"Base case",id:"base-case",level:3},{value:"How recursion works internally",id:"how-recursion-works-internally",level:2},{value:"The call stack: what actually happens",id:"the-call-stack-what-actually-happens",level:3},{value:"Example: factorial",id:"example-factorial",level:3},{value:"Phase 1: call expansion (going down)",id:"phase-1-call-expansion-going-down",level:3},{value:"Base case: stopping stack growth",id:"base-case-stopping-stack-growth",level:3},{value:"Phase 2: stack unwinding (coming back up)",id:"phase-2-stack-unwinding-coming-back-up",level:3},{value:"Why variables don\u2019t clash",id:"why-variables-dont-clash",level:3},{value:"Stack vs heap (important distinction)",id:"stack-vs-heap-important-distinction",level:3},{value:"Tail recursion (internal optimization idea)",id:"tail-recursion-internal-optimization-idea",level:3},{value:"Recursion vs iteration",id:"recursion-vs-iteration",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"recursion",children:"Recursion"})}),"\n",(0,r.jsxs)(n.p,{children:["Recursion is a programming technique where a function calls itself to solve a problem by reducing it to ",(0,r.jsx)(n.strong,{children:"smaller instances of the same problem"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"A recursive solution is valid only if:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["There exists a ",(0,r.jsx)(n.strong,{children:"base case"})," that stops recursion"]}),"\n",(0,r.jsx)(n.li,{children:"Every recursive call moves strictly toward that base case"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Without these, recursion results in infinite calls and stack overflow."}),"\n",(0,r.jsx)(n.h2,{id:"why-recursion-exists",children:"Why recursion exists"}),"\n",(0,r.jsxs)(n.p,{children:["Recursion is used when a problem has a ",(0,r.jsx)(n.strong,{children:"recursive structure"}),", meaning:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The problem can be expressed in terms of itself"}),"\n",(0,r.jsx)(n.li,{children:"The depth of the problem is unknown at compile time"}),"\n",(0,r.jsx)(n.li,{children:"The data structure is hierarchical or branching"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Typical examples:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Trees"}),"\n",(0,r.jsx)(n.li,{children:"Graph traversal (DFS)"}),"\n",(0,r.jsx)(n.li,{children:"Divide-and-conquer algorithms"}),"\n",(0,r.jsx)(n.li,{children:"Backtracking problems"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"basic-structure-of-a-recursive-function",children:"Basic structure of a recursive function"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def f(x):\n    if base_condition:\n        return base_value\n    return f(smaller_x)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Logical interpretation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Solve the smallest possible version directly"}),"\n",(0,r.jsx)(n.li,{children:"Delegate the rest to the same function"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"base-case",children:"Base case"}),"\n",(0,r.jsx)(n.p,{children:"The base case defines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The smallest valid input"}),"\n",(0,r.jsx)(n.li,{children:"A result that does not require further recursion"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Factorial \u2192 ",(0,r.jsx)(n.code,{children:"n == 0"})]}),"\n",(0,r.jsxs)(n.li,{children:["Tree traversal \u2192 ",(0,r.jsx)(n.code,{children:"node is None"})]}),"\n",(0,r.jsxs)(n.li,{children:["Binary search \u2192 ",(0,r.jsx)(n.code,{children:"low > high"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"If the base case is unreachable, recursion is incorrect. Base case is used to end the recursion."}),"\n",(0,r.jsx)(n.h2,{id:"how-recursion-works-internally",children:"How recursion works internally"}),"\n",(0,r.jsxs)(n.p,{children:["Recursion is nothing magical at the machine level. Internally, it is just ",(0,r.jsx)(n.strong,{children:"function calls using the call stack"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"the-call-stack-what-actually-happens",children:"The call stack: what actually happens"}),"\n",(0,r.jsxs)(n.p,{children:["Every time a function is called, the runtime pushes a ",(0,r.jsx)(n.strong,{children:"stack frame"})," onto the call stack."]}),"\n",(0,r.jsx)(n.p,{children:"A stack frame contains:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Function arguments"}),"\n",(0,r.jsx)(n.li,{children:"Local variables"}),"\n",(0,r.jsx)(n.li,{children:"Return address (where execution resumes after the function returns)"}),"\n",(0,r.jsx)(n.li,{children:"Bookkeeping data (saved registers, etc.)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The stack follows ",(0,r.jsx)(n.strong,{children:"LIFO"})," semantics."]}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"flowchart TD\n    A[Call function] --\x3e B[Push stack frame]\n    B --\x3e C[Execute function body]\n    C --\x3e D[Return value]\n    D --\x3e E[Pop stack frame]"})}),"\n",(0,r.jsxs)(n.p,{children:["Recursion works because a function can push ",(0,r.jsx)(n.strong,{children:"another instance of itself"})," onto the stack."]}),"\n",(0,r.jsx)(n.h3,{id:"example-factorial",children:"Example: factorial"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def fact(n):\n    if n == 1:\n        return 1\n    return n * fact(n - 1)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Call:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"fact(4)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"phase-1-call-expansion-going-down",children:"Phase 1: call expansion (going down)"}),"\n",(0,r.jsx)(n.p,{children:"Each recursive call creates a new stack frame. Execution pauses at the recursive call line."}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant Main\n    participant F4 as fact(4)\n    participant F3 as fact(3)\n    participant F2 as fact(2)\n    participant F1 as fact(1)\n\n    Main->>F4: call fact(4)\n    F4->>F3: call fact(3)\n    F3->>F2: call fact(2)\n    F2->>F1: call fact(1)"})}),"\n",(0,r.jsx)(n.p,{children:"Stack state after reaching the base case:"}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:'graph TD\n    S4["fact(4)] --\x3e S3[fact(3)"]\n    S3 --\x3e S2["fact(2)"]\n    S2 --\x3e S1["fact(1)"]'})}),"\n",(0,r.jsx)(n.p,{children:"Key point:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No multiplication has happened yet."}),"\n",(0,r.jsx)(n.li,{children:"Every frame is waiting for the result of the next call."}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"base-case-stopping-stack-growth",children:"Base case: stopping stack growth"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"if n == 1:\n    return 1\n"})}),"\n",(0,r.jsx)(n.p,{children:"Internally:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No new stack frame is created"}),"\n",(0,r.jsx)(n.li,{children:"A concrete value is returned immediately"}),"\n"]}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"flowchart TD\n    B[Base case reached: n == 1] --\x3e R[Return 1]"})}),"\n",(0,r.jsx)(n.p,{children:"This is what prevents infinite stack growth."}),"\n",(0,r.jsx)(n.h3,{id:"phase-2-stack-unwinding-coming-back-up",children:"Phase 2: stack unwinding (coming back up)"}),"\n",(0,r.jsx)(n.p,{children:"Returned values flow upward as stack frames are popped."}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"sequenceDiagram\n    participant F1 as fact(1)\n    participant F2 as fact(2)\n    participant F3 as fact(3)\n    participant F4 as fact(4)\n\n    F1--\x3e>F2: return 1\n    F2--\x3e>F3: return 2\n    F3--\x3e>F4: return 6\n    F4--\x3e>Main: return 24"})}),"\n",(0,r.jsx)(n.p,{children:"Unwinding intuition:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Work is done ",(0,r.jsx)(n.strong,{children:"after"})," recursive calls return"]}),"\n",(0,r.jsx)(n.li,{children:"Each frame completes its pending operation"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"why-variables-dont-clash",children:"Why variables don\u2019t clash"}),"\n",(0,r.jsx)(n.p,{children:"Each recursive call has its own stack frame."}),"\n",(0,r.jsx)(n.p,{children:"Example:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def f(n):\n    x = n + 1\n    return f(n - 1)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Even though x has the same name:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"x in f(4) is different from x in f(3)"}),"\n",(0,r.jsx)(n.li,{children:"They live in different stack frames"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Memory-wise:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-text",children:"frame f(4): x = 5\nframe f(3): x = 4\nframe f(2): x = 3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"stack-vs-heap-important-distinction",children:"Stack vs heap (important distinction)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stack"}),": function calls, parameters, local variables"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Heap"}),": dynamically allocated objects"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Recursion mainly consumes ",(0,r.jsx)(n.strong,{children:"stack memory"}),"."]}),"\n",(0,r.jsx)("div",{style:{textAlign:"center"},children:(0,r.jsx)(n.mermaid,{value:"flowchart LR\n    Stack[Call Stack] --\x3e|frames| Overflow[Stack Overflow]\n    Heap[Heap Memory] --\x3e Objects[Objects / Data]"})}),"\n",(0,r.jsx)(n.p,{children:"Too deep recursion \u2192 stack overflow."}),"\n",(0,r.jsx)(n.h3,{id:"tail-recursion-internal-optimization-idea",children:"Tail recursion (internal optimization idea)"}),"\n",(0,r.jsxs)(n.p,{children:["A function is tail-recursive if the recursive call is the ",(0,r.jsx)(n.strong,{children:"last operation"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"def fact(n, acc=1):\n    if n == 0:\n        return acc\n    return fact(n - 1, acc * n)\n"})}),"\n",(0,r.jsx)(n.p,{children:"Internally:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"No work is pending after the recursive call"}),"\n",(0,r.jsx)(n.li,{children:"In theory, the compiler/runtime can reuse the same stack frame"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This is called ",(0,r.jsx)(n.strong,{children:"Tail Call Optimization (TCO)"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"Reality:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"C, Scheme: often optimized"}),"\n",(0,r.jsxs)(n.li,{children:["Python, Java, JavaScript: ",(0,r.jsx)(n.strong,{children:"no TCO"})]}),"\n",(0,r.jsxs)(n.li,{children:["Go: ",(0,r.jsx)(n.strong,{children:"no TCO"})]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So even tail recursion still consumes stack in most mainstream languages."}),"\n",(0,r.jsx)(n.h2,{id:"recursion-vs-iteration",children:"Recursion vs iteration"}),"\n",(0,r.jsx)(n.p,{children:"Recursion:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Uses call stack"}),"\n",(0,r.jsx)(n.li,{children:"Cleaner for hierarchical problems"}),"\n",(0,r.jsx)(n.li,{children:"Risk of stack overflow"}),"\n",(0,r.jsx)(n.li,{children:"Often slower due to function call overhead"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Iteration:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Constant stack usage"}),"\n",(0,r.jsx)(n.li,{children:"Better for linear problems"}),"\n",(0,r.jsx)(n.li,{children:"Usually faster"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Python does ",(0,r.jsx)(n.strong,{children:"not"})," optimize tail recursion."]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>t,x:()=>l});var i=s(96540);const r={},a=i.createContext(r);function t(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);