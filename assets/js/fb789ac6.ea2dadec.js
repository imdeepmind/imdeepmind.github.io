"use strict";(self.webpackChunkimdeepmind=self.webpackChunkimdeepmind||[]).push([[3027],{90742:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"frameworks-libraries/react/error-handling","title":"Error Handling and Error Boundaries","description":"Error handling is an essential part of building robust applications. In React, error handling ensures that unexpected issues in one part of the application do not crash the entire UI. React provides Error Boundaries as a mechanism to handle runtime errors in the component tree.","source":"@site/docs/frameworks-libraries/react/error-handling.md","sourceDirName":"frameworks-libraries/react","slug":"/frameworks-libraries/react/error-handling","permalink":"/docs/frameworks-libraries/react/error-handling","draft":false,"unlisted":false,"editUrl":"https://github.com/imdeepmind/imdeepmind.github.io/blob/main/docs/frameworks-libraries/react/error-handling.md","tags":[],"version":"current","lastUpdatedBy":"Abhishek Chatterjee","lastUpdatedAt":1735711473000,"sidebarPosition":15,"frontMatter":{"sidebar_position":15},"sidebar":"tutorialSidebar","previous":{"title":"Portals","permalink":"/docs/frameworks-libraries/react/portals"},"next":{"title":"React Under the Hood","permalink":"/docs/frameworks-libraries/react/under-the-hood"}}');var i=n(74848),s=n(28453);const a={sidebar_position:15},t="Error Handling and Error Boundaries",l={},d=[{value:"Error Handling in React",id:"error-handling-in-react",level:2},{value:"Common Sources of Errors",id:"common-sources-of-errors",level:3},{value:"Manual Error Handling Example",id:"manual-error-handling-example",level:3},{value:"What are Error Boundaries?",id:"what-are-error-boundaries",level:2},{value:"Key Points",id:"key-points",level:3},{value:"How to Create an Error Boundary",id:"how-to-create-an-error-boundary",level:2},{value:"Example of an Error Boundary",id:"example-of-an-error-boundary",level:3},{value:"Usage of an Error Boundary",id:"usage-of-an-error-boundary",level:3},{value:"getDerivedStateFromError and componentDidCatch",id:"getderivedstatefromerror-and-componentdidcatch",level:2},{value:"Fallback UI",id:"fallback-ui",level:2},{value:"Error Boundaries with Third-Party Libraries",id:"error-boundaries-with-third-party-libraries",level:2},{value:"Error Handling in Event Handlers",id:"error-handling-in-event-handlers",level:2},{value:"Error Handling in Functional Components",id:"error-handling-in-functional-components",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(r){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...r.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"error-handling-and-error-boundaries",children:"Error Handling and Error Boundaries"})}),"\n",(0,i.jsxs)(e.p,{children:["Error handling is an essential part of building robust applications. In React, error handling ensures that unexpected issues in one part of the application do not crash the entire UI. React provides ",(0,i.jsx)(e.strong,{children:"Error Boundaries"})," as a mechanism to handle runtime errors in the component tree."]}),"\n",(0,i.jsx)(e.h2,{id:"error-handling-in-react",children:"Error Handling in React"}),"\n",(0,i.jsxs)(e.p,{children:["React uses JavaScript\u2019s standard ",(0,i.jsx)(e.strong,{children:"try-catch"})," mechanism for error handling in most cases. However, rendering errors in React components cannot be caught by a typical ",(0,i.jsx)(e.code,{children:"try-catch"})," block because React renders components asynchronously. This is where ",(0,i.jsx)(e.strong,{children:"Error Boundaries"})," come into play."]}),"\n",(0,i.jsx)(e.h3,{id:"common-sources-of-errors",children:"Common Sources of Errors"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Syntax errors in JSX."}),"\n",(0,i.jsx)(e.li,{children:"Runtime errors during rendering."}),"\n",(0,i.jsx)(e.li,{children:"Errors in lifecycle methods."}),"\n",(0,i.jsx)(e.li,{children:"Errors triggered by asynchronous operations (e.g., API calls)."}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"manual-error-handling-example",children:"Manual Error Handling Example"}),"\n",(0,i.jsx)(e.p,{children:"In some scenarios, you might handle errors manually:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:'const MyComponent = () => {\n  try {\n    // Perform some risky operation\n    throw new Error("An error occurred!");\n  } catch (error) {\n    console.error(error);\n    return <h1>Something went wrong.</h1>;\n  }\n};\n'})}),"\n",(0,i.jsx)(e.p,{children:"However, this approach is limited to specific operations and does not cover rendering errors."}),"\n",(0,i.jsx)(e.h2,{id:"what-are-error-boundaries",children:"What are Error Boundaries?"}),"\n",(0,i.jsxs)(e.p,{children:["Error Boundaries are React components designed to catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire app. They do ",(0,i.jsx)(e.strong,{children:"not"})," catch:"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Errors inside event handlers."}),"\n",(0,i.jsxs)(e.li,{children:["Errors in asynchronous code (like ",(0,i.jsx)(e.code,{children:"setTimeout"})," or ",(0,i.jsx)(e.code,{children:"fetch"}),")."]}),"\n",(0,i.jsx)(e.li,{children:"Errors in server-side rendering."}),"\n",(0,i.jsx)(e.li,{children:"Errors thrown from the Error Boundary itself."}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"key-points",children:"Key Points"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["Error Boundaries catch ",(0,i.jsx)(e.strong,{children:"rendering errors"}),", ",(0,i.jsx)(e.strong,{children:"lifecycle method errors"}),", and ",(0,i.jsx)(e.strong,{children:"constructor errors"})," in their child components."]}),"\n",(0,i.jsxs)(e.li,{children:["They work only for class components. Functional components cannot be error boundaries, but they can leverage hooks like ",(0,i.jsx)(e.code,{children:"ErrorBoundary"})," wrappers from libraries."]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"how-to-create-an-error-boundary",children:"How to Create an Error Boundary"}),"\n",(0,i.jsxs)(e.p,{children:["Error Boundaries are implemented using ",(0,i.jsx)(e.strong,{children:"class components"})," that implement the ",(0,i.jsx)(e.code,{children:"componentDidCatch"})," and ",(0,i.jsx)(e.code,{children:"getDerivedStateFromError"})," lifecycle methods."]}),"\n",(0,i.jsx)(e.h3,{id:"example-of-an-error-boundary",children:"Example of an Error Boundary"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:'import React, { Component } from "react";\n\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n\n  static getDerivedStateFromError(error) {\n    // Update state so the next render shows the fallback UI\n    return { hasError: true };\n  }\n\n  componentDidCatch(error, errorInfo) {\n    // Log the error to an external service or console\n    console.error("Error Boundary Caught:", error, errorInfo);\n  }\n\n  render() {\n    if (this.state.hasError) {\n      // Render fallback UI\n      return <h1>Something went wrong.</h1>;\n    }\n\n    return this.props.children;\n  }\n}\n\nexport default ErrorBoundary;\n'})}),"\n",(0,i.jsx)(e.h3,{id:"usage-of-an-error-boundary",children:"Usage of an Error Boundary"}),"\n",(0,i.jsxs)(e.p,{children:["Wrap components that you suspect might throw an error inside the ",(0,i.jsx)(e.code,{children:"ErrorBoundary"}),"."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:"<ErrorBoundary>\n  <MyComponent />\n</ErrorBoundary>\n"})}),"\n",(0,i.jsx)(e.h2,{id:"getderivedstatefromerror-and-componentdidcatch",children:"getDerivedStateFromError and componentDidCatch"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"getDerivedStateFromError(error)"})}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Invoked during the render phase when an error is thrown."}),"\n",(0,i.jsx)(e.li,{children:"Updates the component's state to display a fallback UI."}),"\n",(0,i.jsx)(e.li,{children:"Should return an updated state object."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:(0,i.jsx)(e.code,{children:"componentDidCatch(error, errorInfo)"})}),":"]}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Invoked after an error is thrown in the component tree."}),"\n",(0,i.jsx)(e.li,{children:"Used for logging errors or side effects (e.g., sending logs to an error reporting service like Sentry)."}),"\n",(0,i.jsx)(e.li,{children:"Provides additional error information (e.g., component stack trace)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"fallback-ui",children:"Fallback UI"}),"\n",(0,i.jsx)(e.p,{children:"The fallback UI is the content displayed when an error is caught by the Error Boundary. It should inform users that something went wrong without crashing the rest of the application."}),"\n",(0,i.jsx)(e.p,{children:"Example of a fallback UI:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:"render() {\n  if (this.state.hasError) {\n    return <h1>Oops! Something went wrong. Please try again later.</h1>;\n  }\n  return this.props.children;\n}\n"})}),"\n",(0,i.jsx)(e.h2,{id:"error-boundaries-with-third-party-libraries",children:"Error Boundaries with Third-Party Libraries"}),"\n",(0,i.jsx)(e.p,{children:"Some libraries provide reusable Error Boundary components for functional components or extended use cases. For example:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"react-error-boundary"}),": A popular library to implement Error Boundaries in functional components using hooks."]}),"\n"]}),"\n",(0,i.jsx)(e.p,{children:"Example:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:'import { ErrorBoundary } from "react-error-boundary";\n\nconst Fallback = () => <div>An error occurred!</div>;\n\n<ErrorBoundary FallbackComponent={Fallback}>\n  <MyComponent />\n</ErrorBoundary>;\n'})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling-in-event-handlers",children:"Error Handling in Event Handlers"}),"\n",(0,i.jsxs)(e.p,{children:["Error Boundaries do not catch errors in event handlers. You need to handle such errors manually using ",(0,i.jsx)(e.code,{children:"try-catch"})," blocks."]}),"\n",(0,i.jsx)(e.p,{children:"Example:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:'const handleClick = () => {\n  try {\n    throw new Error("An error in event handler!");\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nreturn <button onClick={handleClick}>Click Me</button>;\n'})}),"\n",(0,i.jsx)(e.h2,{id:"error-handling-in-functional-components",children:"Error Handling in Functional Components"}),"\n",(0,i.jsxs)(e.p,{children:["Functional components cannot implement Error Boundaries directly. However, you can achieve similar behavior by using ",(0,i.jsx)(e.strong,{children:"Error Boundary wrappers"})," or external libraries like ",(0,i.jsx)(e.code,{children:"react-error-boundary"}),". Alternatively, you can combine ",(0,i.jsx)(e.code,{children:"try-catch"})," with ",(0,i.jsx)(e.code,{children:"useState"})," for limited error handling."]}),"\n",(0,i.jsx)(e.p,{children:"Example:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-jsx",children:'const FunctionalErrorBoundary = ({ children }) => {\n  const [hasError, setHasError] = React.useState(false);\n\n  try {\n    if (hasError) {\n      throw new Error("Error detected!");\n    }\n    return children;\n  } catch (error) {\n    console.error(error);\n    return <h1>Something went wrong.</h1>;\n  }\n};\n'})}),"\n",(0,i.jsx)(e.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:"Use Error Boundaries sparingly and only around parts of your app prone to errors (e.g., dynamic content, third-party components)."}),"\n",(0,i.jsx)(e.li,{children:"Log errors to external services (e.g., Sentry, LogRocket) for debugging and monitoring."}),"\n",(0,i.jsx)(e.li,{children:"Avoid using Error Boundaries to suppress errors silently; provide meaningful fallback UI for users."}),"\n",(0,i.jsx)(e.li,{children:"Combine Error Boundaries with other error handling techniques (e.g., event handler error handling and API-level error handling)."}),"\n"]})]})}function h(r={}){const{wrapper:e}={...(0,s.R)(),...r.components};return e?(0,i.jsx)(e,{...r,children:(0,i.jsx)(c,{...r})}):c(r)}},28453:(r,e,n)=>{n.d(e,{R:()=>a,x:()=>t});var o=n(96540);const i={},s=o.createContext(i);function a(r){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof r?r(e):{...e,...r}}),[e,r])}function t(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(i):r.components||i:a(r.components),o.createElement(s.Provider,{value:e},r.children)}}}]);