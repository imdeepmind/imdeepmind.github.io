---
sidebar_position: 11
---

# Nested Relationships and Hyperlinked APIs

Django Rest Framework (DRF) offers tools to manage related models effectively. This includes using hyperlinks for relationships and handling deeply nested relationships.

## Hyperlinked APIs and `HyperlinkedModelSerializer`

### What is a Hyperlinked API?

- In Hyperlinked APIs, relationships between resources are represented by URLs (hyperlinks) rather than raw data or primary keys.
- URLs improve API usability and adhere to REST principles by providing direct references to related resources.

### `HyperlinkedModelSerializer`

- A specialized serializer class that uses hyperlinks for relationships instead of primary keys.
- Ideal for APIs where navigation between resources is a priority.

#### Usage

1. **Basic Setup**:

   ```python
   from rest_framework import serializers
   from myapp.models import Author, Book

   class AuthorSerializer(serializers.HyperlinkedModelSerializer):
       class Meta:
           model = Author
           fields = ['url', 'id', 'name', 'books']
           extra_kwargs = {'url': {'view_name': 'author-detail'}}

   class BookSerializer(serializers.HyperlinkedModelSerializer):
       class Meta:
           model = Book
           fields = ['url', 'id', 'title', 'author']
           extra_kwargs = {'url': {'view_name': 'book-detail'}}
   ```

   - `url`: Automatically generated by `HyperlinkedModelSerializer`.
   - `view_name`: Specifies the name of the view used to generate the hyperlink.

2. **Views**:

   ```python
   from rest_framework import viewsets
   from myapp.models import Author, Book
   from myapp.serializers import AuthorSerializer, BookSerializer

   class AuthorViewSet(viewsets.ModelViewSet):
       queryset = Author.objects.all()
       serializer_class = AuthorSerializer

   class BookViewSet(viewsets.ModelViewSet):
       queryset = Book.objects.all()
       serializer_class = BookSerializer
   ```

3. **URLs**:
   Define routes in `urls.py` using a router:

   ```python
   from rest_framework.routers import DefaultRouter
   from myapp.views import AuthorViewSet, BookViewSet

   router = DefaultRouter()
   router.register(r'authors', AuthorViewSet)
   router.register(r'books', BookViewSet)

   urlpatterns = router.urls
   ```

4. **Example API Response**:

   ```json
   {
     "id": 1,
     "name": "J.K. Rowling",
     "books": [
       "http://example.com/api/books/1/",
       "http://example.com/api/books/2/"
     ],
     "url": "http://example.com/api/authors/1/"
   }
   ```

#### Advantages

- Provides clear navigation paths.
- Simplifies client-side integration by allowing direct resource lookup.

## Nested Relationships

### What are Nested Relationships?

- In nested relationships, related data is embedded within the parent object’s representation.
- Commonly used for complex objects or when related data is required as part of the API response.

### Implementing Nested Relationships

1. **Direct Nesting**:
   Serialize related objects directly using another serializer.

   ```python
   from rest_framework import serializers
   from myapp.models import Author, Book

   class BookSerializer(serializers.ModelSerializer):
       class Meta:
           model = Book
           fields = ['id', 'title']

   class AuthorSerializer(serializers.ModelSerializer):
       books = BookSerializer(many=True)  # Nested serializer

       class Meta:
           model = Author
           fields = ['id', 'name', 'books']
   ```

   **Example Response**:

   ```json
   {
     "id": 1,
     "name": "J.K. Rowling",
     "books": [
       { "id": 1, "title": "Harry Potter and the Philosopher's Stone" },
       { "id": 2, "title": "Harry Potter and the Chamber of Secrets" }
     ]
   }
   ```

2. **Writable Nested Relationships**:
   To support creating or updating nested objects, override `create` and `update` methods in the serializer.

   ```python
   class AuthorSerializer(serializers.ModelSerializer):
       books = BookSerializer(many=True)

       class Meta:
           model = Author
           fields = ['id', 'name', 'books']

       def create(self, validated_data):
           books_data = validated_data.pop('books')
           author = Author.objects.create(**validated_data)
           for book_data in books_data:
               Book.objects.create(author=author, **book_data)
           return author

       def update(self, instance, validated_data):
           books_data = validated_data.pop('books')
           instance.name = validated_data.get('name', instance.name)
           instance.save()

           # Update or create books
           for book_data in books_data:
               book, created = Book.objects.update_or_create(
                   author=instance, id=book_data.get('id'),
                   defaults=book_data
               )
           return instance
   ```

3. **Depth Option**:
   Use the `depth` option to automatically serialize related fields to a specified depth.

   ```python
   class AuthorSerializer(serializers.ModelSerializer):
       class Meta:
           model = Author
           fields = ['id', 'name', 'books']
           depth = 1
   ```

   - **Limitations**: `depth` is read-only and doesn’t support writable nested objects.

### Key Considerations

## When to Use Hyperlinked vs Nested Relationships

| **Hyperlinked Relationships**   | **Nested Relationships**                   |
| ------------------------------- | ------------------------------------------ |
| Useful for RESTful navigation.  | Better for complex, hierarchical data.     |
| Keeps responses smaller.        | Can lead to larger payloads.               |
| Best for referencing resources. | Best for including detailed, related data. |

## Performance

- **Hyperlinked Relationships**: May require multiple database queries to resolve related object URLs.
- **Nested Relationships**: Can lead to large payloads, so ensure efficient queries using techniques like `select_related` and `prefetch_related`.

## Validation

- When using writable nested serializers, ensure proper validation for related objects.

## Example: Combining Hyperlinked and Nested Relationships

```python
from rest_framework import serializers
from myapp.models import Author, Book, Publisher

class BookSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = Book
        fields = ['url', 'id', 'title']

class PublisherSerializer(serializers.ModelSerializer):
    class Meta:
        model = Publisher
        fields = ['id', 'name']

class AuthorSerializer(serializers.HyperlinkedModelSerializer):
    books = BookSerializer(many=True)
    publisher = PublisherSerializer()

    class Meta:
        model = Author
        fields = ['url', 'id', 'name', 'books', 'publisher']
```
